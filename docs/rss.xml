<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>blog :: Brent -> [String]</title>
        <link>http://byorgey.github.io/blog</link>
        <description><![CDATA[Brent Yorgey's academic blog]]></description>
        <atom:link href="http://byorgey.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 25 Jun 2025 00:00:00 UT</lastBuildDate>
        <item>
    <title>Competitive programming in Haskell: prefix sums</title>
    <link>http://byorgey.github.io/blog/posts/2025/06/27/prefix-sums.html</link>
    <description><![CDATA[
<h1>Competitive programming in Haskell: prefix sums</h1>

<div class="info">
  Posted on June 25, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;monoid&#39;." href="/tag/monoid.html" rel="tag">monoid</a>, <a title="All pages tagged &#39;range&#39;." href="/tag/range.html" rel="tag">range</a>, <a title="All pages tagged &#39;query&#39;." href="/tag/query.html" rel="tag">query</a>, <a title="All pages tagged &#39;prefix&#39;." href="/tag/prefix.html" rel="tag">prefix</a>, <a title="All pages tagged &#39;sum&#39;." href="/tag/sum.html" rel="tag">sum</a>, <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>
  
</div>

<section>
<p>In a <a href="https://byorgey.github.io/blog/posts/2025/06/23/range-queries-classified.html">previous blog
post</a>
I categorized a number of different techniques for calculating <em>range queries</em>.
Today, I will discuss one of those techniques which is simple but frequently
useful.</p>
<section id="precomputing-prefix-sums" class="level2">
<h2>Precomputing prefix sums</h2>
<p>Suppose we have a static sequence of values <span class="math inline">\(a_1, a_2, a_3, \dots, a_n\)</span> drawn from some
<a href="https://en.wikipedia.org/wiki/Group_(mathematics)">group</a><span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">That is,
there is an associative binary operation, and
every element has an inverse.<br />
<br />
</span></span>, and want
to be able to compute the total value (according to the group
operation) of any contiguous subrange. That is, given a range
<span class="math inline">\([i,j]\)</span>, we want to compute <span class="math inline">\(a_i \diamond a_{i+1} \diamond \dots \diamond a_j\)</span> (where <span class="math inline">\(\diamond\)</span> is the group operation). For example,
we might have a sequence of integers and want to compute the sum, or
perhaps the bitwise xor (but not the maximum) of all the values in any particular
subrange.</p>
<p>Of course, we could simply compute <span class="math inline">\(a_i \diamond \dots \diamond a_j\)</span>
directly, but that takes <span class="math inline">\(O(n)\)</span> time. With some simple preprocessing,
it’s possible to compute the value of any range in constant time.</p>
<p>The key idea is to precompute an array <span class="math inline">\(P\)</span> of <em>prefix sums</em>, so <span class="math inline">\(P_i = a_1 \diamond \dots \diamond a_i\)</span>. This can be computed in linear time
via a <em>scan</em>; for example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (scanl&#39;)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">prefix ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">Int</span> a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>prefix a <span class="ot">=</span> listArray (<span class="dv">0</span>, <span class="fu">length</span> a) <span class="op">$</span> scanl&#39; (<span class="op">&lt;&gt;</span>) <span class="fu">mempty</span> a</span></code></pre></div>
<p><span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">Actually, I would typically use an <em>unboxed</em> array, which is
faster but slightly more limited in its uses: import
<code>Data.Array.Unboxed</code>, use <code>UArray</code> instead of <code>Array</code>, and add an
<code>IArray UArray a</code> constraint.<br />
<br />
</span></span></p>
<p>Note that we set <span class="math inline">\(P_0 = 0\)</span> (or whatever the identity element is for
the group); this is why I had the sequence of values indexed starting
from <span class="math inline">\(1\)</span>, so <span class="math inline">\(P_0\)</span> corresponds to the empty sum, <span class="math inline">\(P_1 = a_1\)</span>, <span class="math inline">\(P_2 = a_1 \diamond a_2\)</span>, and so on.</p>
<p>Now, for the value of the range <span class="math inline">\([i,j]\)</span>, just compute <span class="math inline">\(P_j \diamond P_{i-1}^{-1}\)</span>—that is, we start with a prefix that ends at the right place, then
cancel or “subtract” the prefix that ends right before the range we
want. For example, to find the sum of the integers <span class="math inline">\(a_5 + \dots + a_{10}\)</span>, we can compute <span class="math inline">\(P_{10} - P_4\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span><span class="ot"> ::</span> <span class="dt">Group</span> a <span class="ot">=&gt;</span> <span class="dt">Array</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span> p i j <span class="ot">=</span> p<span class="op">!</span>j <span class="op">&lt;&gt;</span> inv (p<span class="op">!</span>(i<span class="op">-</span><span class="dv">1</span>))</span></code></pre></div>
<p>That’s why this only works for groups but not for general monoids:
only in a group can we <em>cancel</em> unwanted values. So, for example,
this works for finding the sum of any range, but not the maximum.</p>
</section>
<section id="practice-problems" class="level2">
<h2>Practice problems</h2>
<p>Want to practice? Here are a few problems that can be solved using
techniques discussed in this post:</p>
<ul>
<li><a href="https://open.kattis.com/problems/nucleotides">Determining Nucleotide Assortments</a></li>
<li><a href="https://open.kattis.com/problems/einvigi">Einvígi</a></li>
<li><a href="https://open.kattis.com/problems/srednji">Srednji</a></li>
<li><a href="https://open.kattis.com/problems/veggjakalli">Veggja Kalli</a></li>
</ul>
<p>It is possible to generalize this scheme to 2D—that is, to compute
the value of any <em>subrectangle</em> of a <em>2D grid</em> of values from some
group in only <span class="math inline">\(O(1)\)</span> time. I will leave you the fun of figuring out
the details.</p>
<ul>
<li><a href="https://open.kattis.com/problems/prozor">Prozor</a></li>
<li><a href="https://open.kattis.com/problems/rust">Rust</a></li>
</ul>
<p>If you’re looking for an extra challenge, here are a few harder
problems which use techniques from this post as an important
component, but require some additional nontrivial ingredients:</p>
<ul>
<li><a href="https://open.kattis.com/problems/killingchaos">Killing Chaos</a></li>
<li><a href="https://open.kattis.com/problems/ozljeda">Ozljeda</a></li>
<li><a href="https://open.kattis.com/problems/vudu">Vudu</a></li>
</ul>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive programming in Haskell: prefix sums" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2025-06-25T00:00:00Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/06/27/prefix-sums.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive programming in Haskell: range queries, classified</title>
    <link>http://byorgey.github.io/blog/posts/2025/06/23/range-queries-classified.html</link>
    <description><![CDATA[
<h1>Competitive programming in Haskell: range queries, classified</h1>

<div class="info">
  Posted on June 23, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;semigroup&#39;." href="/tag/semigroup.html" rel="tag">semigroup</a>, <a title="All pages tagged &#39;monoid&#39;." href="/tag/monoid.html" rel="tag">monoid</a>, <a title="All pages tagged &#39;range&#39;." href="/tag/range.html" rel="tag">range</a>, <a title="All pages tagged &#39;query&#39;." href="/tag/query.html" rel="tag">query</a>, <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>
  
</div>

<section>
<section id="static-range-queries" class="level2">
<h2>Static range queries</h2>
<p>Suppose we have a sequence of values, which is <em>static</em> in the sense
that the values in the sequence will never change, and we want to
perform <em>range queries</em>, that is, for various ranges we want to
compute the total of all consecutive values in the range, according to
some binary combining operation. For example, we might want to
compute the maximum, sum, or product of all the consecutive values in
a certain subrange. We have various options depending on the kind of
ranges we want and the algebraic properties of the operation.</p>
<ul>
<li><p>If we want ranges corresponding to a <em>sliding window</em>, we can use
<a href="https://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html">an amortized queue
structure</a>
to find the total of each range in <span class="math inline">\(O(1)\)</span>, for an arbitrary
monoid.
<!-- ^[If we have a group, then no special data structure is -->
<!-- needed: just keep track of the value of the current window, and add -->
<!-- and subtract values as they enter and leave the window, -->
<!-- respectively.] --></p></li>
<li><p>If we want arbitrary ranges but the operation is a <em>group</em>, the
solution is relatively straightforward: we can precompute all
<em>prefix sums</em>, and subtract to find the result for an arbitrary
range in <span class="math inline">\(O(1)\)</span>. I will write about this in an upcoming blog post.</p></li>
<li><p>If the operation is an <em>idempotent semigroup</em> (that is, it has the
property that <span class="math inline">\(x \diamond x = x\)</span> for all <span class="math inline">\(x\)</span>), we can use a <em><a href="https://cp-algorithms.com/data_structures/sparse-table.html">sparse
table</a></em>, which takes <span class="math inline">\(O(n \lg n)\)</span> time and space for precomputation,
and then allows us to answer arbitrary range queries in <span class="math inline">\(O(1)\)</span>. I
also plan to write about this in an upcoming blog post.</p></li>
<li><p>If the operation is an arbitrary monoid, we can use a <em><a href="https://cp-algorithms.com/data_structures/sqrt-tree.html">sqrt tree</a></em>,
which uses <span class="math inline">\(O(n \lg \lg n)\)</span> precomputed time and space, and allows
answering arbitrary range queries in <span class="math inline">\(O(\lg \lg n)\)</span>. I will write
about this in a future post.</p></li>
</ul>
</section>
<section id="dynamic-range-queries" class="level2">
<h2>Dynamic range queries</h2>
<p>What if we want <em>dynamic</em> range queries, that is, we want to be able
to interleave range queries with arbitrary updates to the values of
the sequence?</p>
<ul>
<li>If the operation is an arbitrary monoid, we can use a segment
tree.</li>
<li>If the operation is a group, we can use a <a href="https://cp-algorithms.com/data_structures/fenwick.html">Fenwick tree</a>.</li>
</ul>
<p>I published <a href="https://byorgey.github.io/blog/posts/2025/01/23/Fenwick.html">a paper about Fenwick
trees</a>,
which also discusses segment trees, but I should write more about
them here!</p>
</section>
<section id="table" class="level2">
<h2>Table</h2>
<p>Here’s a table summarizing the above classification scheme. I plan to
fill in links as I write blog posts about each row.</p>
<figure class="fullwidth">
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 14%" />
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 16%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Sequence</th>
<th style="text-align: left;">Ranges</th>
<th style="text-align: left;">Operation</th>
<th style="text-align: left;">Solution</th>
<th style="text-align: left;">Precomputation</th>
<th style="text-align: left;">Queries</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Static</td>
<td style="text-align: left;">Sliding window</td>
<td style="text-align: left;">Monoid</td>
<td style="text-align: left;"><a href="https://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html">Amortized queue</a></td>
<td style="text-align: left;"><span class="math inline">\(O(1)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Static</td>
<td style="text-align: left;">Arbitrary</td>
<td style="text-align: left;">Group</td>
<td style="text-align: left;">Prefix sum table</td>
<td style="text-align: left;"><span class="math inline">\(O(n)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Static</td>
<td style="text-align: left;">Arbitrary</td>
<td style="text-align: left;">Idempotent semigroup</td>
<td style="text-align: left;">Sparse table</td>
<td style="text-align: left;"><span class="math inline">\(O(n \lg n)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Static</td>
<td style="text-align: left;">Arbitrary</td>
<td style="text-align: left;">Monoid</td>
<td style="text-align: left;">Sqrt table</td>
<td style="text-align: left;"><span class="math inline">\(O(n \lg \lg n)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(\lg \lg n)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Dynamic</td>
<td style="text-align: left;">Arbitrary</td>
<td style="text-align: left;">Group</td>
<td style="text-align: left;">Fenwick tree</td>
<td style="text-align: left;"><span class="math inline">\(O(n)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(\lg n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Dynamic</td>
<td style="text-align: left;">Arbitrary</td>
<td style="text-align: left;">Monoid</td>
<td style="text-align: left;">Segment tree</td>
<td style="text-align: left;"><span class="math inline">\(O(n)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(\lg n)\)</span></td>
</tr>
</tbody>
</table>
</figure>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive programming in Haskell: range queries, classified" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 23 Jun 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/06/23/range-queries-classified.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Monads are not like burritos</title>
    <link>http://byorgey.github.io/blog/posts/2025/06/16/monads-are-not-burritos.html</link>
    <description><![CDATA[
<h1>Monads are not like burritos</h1>

<div class="info">
  Posted on June 16, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;monad&#39;." href="/tag/monad.html" rel="tag">monad</a>, <a title="All pages tagged &#39;pedagogy&#39;." href="/tag/pedagogy.html" rel="tag">pedagogy</a>, <a title="All pages tagged &#39;meme&#39;." href="/tag/meme.html" rel="tag">meme</a>, <a title="All pages tagged &#39;burrito&#39;." href="/tag/burrito.html" rel="tag">burrito</a>, <a title="All pages tagged &#39;analogy&#39;." href="/tag/analogy.html" rel="tag">analogy</a>, <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>
  
</div>

<section>
<p>In January 2009, while just a baby first-year PhD student, I wrote a
blog post titled <a href="https://byorgey.github.io/blog/posts/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy.html">Abstraction, intuition, and the “monad tutorial
fallacy”</a>.
In it, I made the argument that humans tend to learn best by first
grappling with concrete examples, and only later proceeding to
higher-level intuition and analogies; hence, it’s a mistake to
think that clearly presenting your intuition for a topic will help
other people understand it. Analogies and intuition can help, but
only when accompanied by concrete examples and active engagement. To
illustrate the point, I made up a fictitious programmer with a
fictitious analogy.</p>
<blockquote>
<p>But now Joe goes and writes a monad tutorial called “Monads are
Burritos,” under the well-intentioned but mistaken assumption that
if other people read his magical insight, learning about monads will
be a snap for them. “Monads are easy,” Joe writes. “Think of them as
burritos.” Joe hides all the actual details about types and such
because those are scary, and people will learn better if they can
avoid all that difficult and confusing stuff. Of course, exactly
the opposite is true, and all Joe has done is make it <em>harder</em> for
people to learn about monads…</p>
</blockquote>
<p>My intention was to choose a fictitious analogy which was obviously
ridiculous and silly, as a parody of many of the monad tutorials which
existed at the time (and still do). <a href="https://blog.plover.com/meta/about-me.html">Mark Jason Dominus</a>
then wrote a blog post, <a href="https://blog.plover.com/prog/burritos.html">Monads are like
burritos</a>, pointing out
that actually, monads <em>are</em> kinda like burritos. It’s really funny,
though I don’t think it’s actually a very good analogy, and my guess
is that Mark would agree: it was clearly written as a silly joke and
not as a real way to explain monads.</p>
<p>In any case, from that point the “monads are burritos” meme took on a
life of its own. For example:</p>
<ul>
<li><a href="https://chrisdone.com/posts/monads-are-burritos/">Chris Done made a webcomic about
it</a></li>
<li><a href="https://edwardmorehouse.github.io/silliness/burrito_monads.pdf">Ed Morehouse wrote a ridiculous paper exploring the categorical
foundations of burritos</a></li>
<li><a href="https://github.com/withoutboats/burrito">Someone made a <code>burrito</code> library in Rust</a></li>
<li><a href="https://x.com/DrEugeniaCheng/status/1316817271961116679">Dr Eugenia Cheng tweeted about it</a></li>
</ul>
<p>I even joined in the fun and made this meme image about bad monad
tutorials:</p>
<p><img src="images/monad_tutorial.jpg" /></p>
<p>Of course there are <a href="https://www.reddit.com/r/haskell/comments/6bxk1v/why_monads_always_get_compared_to_burritos/">lots of people who still understand that it was all just a silly joke</a>.
Recently, however, I’ve seen several instances where people apparently
believe “monads are burritos” is a real, helpful thing and not just a
joke meme. For example, see <a href="https://lobste.rs/s/xmpj1p/you_probably_wrote_half_monad_by_accident">this thread on
lobste.rs</a>,
or <a href="https://mathstodon.xyz/@CubeRootOfTrue/114404282908533701">this Mastodon post</a>.</p>
<p>So, to set the record straight: “monads are burritos” is <em>not</em> a helpful
analogy!<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Yes, I am writing a blog post because <a href="https://xkcd.com/386/">People Are Wrong On
The Internet</a>, and I know it probably won’t
make any difference, but here we are.<br />
<br />
</span></span> Why not, you ask?
To expand on my reasons from a <a href="https://www.reddit.com/r/haskell/comments/3bdrlj/comment/ct24jmc/">10-year-old Reddit
comment</a>:</p>
<ul>
<li>The burrito analogy strongly implies that a value of type <code>m a</code>
somehow “contains” a value (or values) of type <code>a</code>. But that is not
true for all monads (e.g. there is no sense in which a value of type
<code>IO String</code> contains a <code>String</code>).</li>
<li>Relatedly, the analogy also implies that a value of type <code>m a</code> can
be “unwrapped” to get an <code>a</code>, but this is impossible for many monads.</li>
<li>It is not actually very easy to take a burrito containing a burrito
and merge it into a single-level burrito. At least this is not in
any sense a natural operation on burritos. Perhaps you could argue
that it is always easy to remove outer tortilla layers (but not the
innermost one since the food will all fall out), but this is a bad
analogy, since in general <code>join</code> does not just “remove” an outer
layer, but somehow merges the effects of two layers into one.</li>
</ul>
<p>Actually, burritos are a great analogy for the <code>Identity</code> monad!
…but not much beyond that.</p>
<p>On a more positive note, my sense is that the average
pedagogical quality of Haskell materials, and monad tutorials in
particular, has indeed gone up significantly since 2009. I’d love to
think this can be at least partially attributed to my original blog
post, though of course it’s impossible to know that for sure.</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Monads are not like burritos" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 16 Jun 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/06/16/monads-are-not-burritos.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Introduction to competitive programming in Haskell</title>
    <link>http://byorgey.github.io/blog/posts/2025/06/10/comprog-hs-intro.html</link>
    <description><![CDATA[
<h1>Introduction to competitive programming in Haskell</h1>

<div class="info">
  Posted on June 10, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>, <a title="All pages tagged &#39;haskell&#39;." href="/tag/haskell.html" rel="tag">haskell</a>
  
</div>

<section>
<p>A few days ago I gave a talk at <a href="https://zfoh.ch/zurihac2025/">ZuriHac
2025</a> entitled <em>Haskell for Competitive
Programming</em>, a basic introduction to competitive programming in
general, and the joy of using Haskell for competitive programming in
particular. This is an expanded version of my talk in blog post form.
(For an even gentler introduction to competitive programming in
Haskell, see <a href="https://byorgey.github.io/blog/posts/2019/04/24/competitive-programming-in-haskell-basic-setup.html">this old blog post from
2019</a>.)</p>
<section id="competitive-programming" class="level2">
<h2>Competitive Programming</h2>
<p>First of all, what is <em>competitive programming</em>? It’s a broad term,
but when I talk about competitive programming I have something in mind
along the following lines:</p>
<ul>
<li>There are well-specified input and output formats, usually with a
few examples, and a precise specification of what the output should
be for a given input.</li>
<li>Your job is to write a program which transforms input meeting the
specification into a correct output.</li>
<li>You submit your program, which is tested on a number of inputs and
declared correct if and only if it yields the correct output for all
the tested inputs.</li>
<li>There is often time pressure involved—that is, you have a limited
amount of time in which to write your program. However, it is also
possible to participate “recreationally”, simply for the joy of
problem-solving, without time pressure (in fact, the vast majority
of the competitive programming I do is of this form, though I have
occasionally participated in timed contests).</li>
</ul>
<p>There are many variations: whether you are allowed to use code
libraries prepared ahead of time, or must type everything from
scratch; outputs can be scored according to some criteria rather
than simply being judged right or wrong; and so on.</p>
<p>There are many sites which allow you to participate in contests and/or
solve competitive programming problems recreationally. My favorite is
<a href="https://open.kattis.com">Open Kattis</a>; I mention some others at the
end of this post.</p>
</section>
<section id="pot-a-first-example" class="level2">
<h2>Pot: a first example</h2>
<p>As an introductory example, let’s look at
<a href="https://open.kattis.com/problems/pot">Pot</a>. As usual, there’s a silly
story, but what it boils down to is that we will be given a sequence
of numbers, and we should interpret the last digit of each number as an
exponent, then sum the results. For example, if given <code>125</code>, we
should interpret it as <span class="math inline">\(12^5\)</span>, and so on.</p>
<section id="dealing-with-io-via-interact" class="level3">
<h3>Dealing with I/O via <code>interact</code></h3>
<p>An imperative approach to such a problem would involve doing a
sequence of input commands, some computation, and a sequence of output
commands—possibly interleaved with one another—and we might
immediately think to start using functions like <code>getLine</code> and
<code>putStrLn</code> to do the required I/O in Haskell. However, there is a
much more fruitful functional perspective: we are simply being asked
to implement a particular (partial) function of type <code>String -&gt; String</code>. The fact that the function’s input and output should be
hooked up to the program’s standard input and output is just an
implementation detail. Competitive programming is functional at
heart!</p>
<p>It turns out that Haskell’s standard library already has the perfect
built-in function for this scenario:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">interact</span><span class="ot"> ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p><code>interact</code> takes a pure <code>String -&gt; String</code> function and turns it into
an <code>IO</code> action which reads from standard input, passes the input to
the given <code>String -&gt; String</code> function, and prints the result to standard output. It even
does this using <em>lazy</em> I/O—that is, the input is
read lazily, as demanded by the function, so that the output and input
can be automatically interleaved depending on which parts of the
output depend on which parts of the input. In particular, this means
that that the entire input need not be stored in memory at once. If
the inputs can be processed into outputs in a streaming fashion—as
is the case in the example problem we are currently
considering—then the input and output will be interleaved. In
general, this kind of lazy I/O is
<a href="https://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o">problematic</a>
and even unsafe, but it’s perfect for this scenario.</p>
</section>
<section id="solving-the-problem-with-a-pipeline" class="level3">
<h3>Solving the problem with a pipeline</h3>
<p>So <code>interact</code> does all the <code>IO</code> for us, and all we have to do is write
a pure <code>String -&gt; String</code> function which transforms the input to the
output. In this case, we can split the input into <code>lines</code>, <code>drop</code> the
first line (we don’t need to know how many lines of input there
are—we just get a list of all of them, since <code>interact</code> will read
until EOF), <code>read</code> each number and turn it into the first digits
raised to the power of the last digit, then <code>sum</code> them and <code>show</code> the
result. The full solution is below. Notice how I use the “backwards
composition” operator <code>(&gt;&gt;&gt;)</code>, since I find it more convenient to type
from left to right as I’m thinking about transforming from input to
output.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> <span class="op">$</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">drop</span> <span class="dv">1</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">&gt;&gt;&gt;</span> process) <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">show</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>process n <span class="ot">=</span> (n <span class="ot">`div`</span> <span class="dv">10</span>) <span class="op">^</span> (n <span class="ot">`mod`</span> <span class="dv">10</span>)</span></code></pre></div>
<p>I use <code>Integer</code> here since raw performance doesn’t matter much for
this easy problem, and <code>Integer</code> avoids any potential problems with
overflow. However, using <code>Int</code> instead of <code>Integer</code> can make a big
difference for some compute-intensive problems. On Kattis, <code>Int</code> will
always be 64 bits, but last time I checked <code>Int</code> can be 32 bits on
Codeforces.</p>
</section>
</section>
<section id="shopping-list-wholemeal-programming-and-bytestring" class="level2">
<h2>Shopping List: wholemeal programming and ByteString</h2>
<p>Let’s consider <a href="https://open.kattis.com/problems/shoppinglist">Shopping List</a> as a second example. In this
problem, we are given a list of shopping lists, where each shopping
list consists of a list of space-separated items on a single line. We
are asked to find the items which are common to all the shopping
lists, and print them in alphabetical order.</p>
<section id="wholemeal-programming-with-standard-data-structures" class="level3">
<h3>Wholemeal programming with standard data structures</h3>
<p>This problem is very amenable to a <a href="https://www.cs.ox.ac.uk/ralf.hinze/publications/ICFP09.pdf">“wholemeal programming”
approach</a>,
where we work entirely at the level of whole data structure
transformations rather than looping over individual elements. We can
turn each shopping list into a set, then find the intersection of all
the sets. Moreover, if we use <code>Data.Set</code>, which uses an ordering on
the elements, we will get the result in alphabetical order “for free”
(“free” as in the amount of code we have to write, not necessarily
runtime cost). Haskell has a decent collection of data structures in
the <code>containers</code> library (<code>(Int)Set</code>, <code>(Int)Map</code>, <code>Seq</code>, <code>Tree</code>, and
even <code>Graph</code>) with a large collection of standard methods to construct
and manipulate them, which are bread and butter for many competitive
programming problems.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Set</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> <span class="op">$</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">drop</span> <span class="dv">1</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">words</span> <span class="op">&gt;&gt;&gt;</span> S.fromList) <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr1</span> S.intersection <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  (\s <span class="ot">-&gt;</span> <span class="fu">show</span> (S.size s) <span class="op">:</span> S.toList s) <span class="op">&gt;&gt;&gt;</span> <span class="fu">unlines</span></span></code></pre></div>
</section>
<section id="bytestring-vs-string" class="level3">
<h3><code>ByteString</code> vs <code>String</code></h3>
<p>Unfortunately, when we try submitting this code, we get a Time Limit
Exceeded error! What’s wrong?</p>
<p>The issue is our use of <code>String</code>, which is an actual linked list of
characters and is very slow, especially when we have many short
strings, as in this problem. In the worst case, we could have 100
shopping lists, each with 5000 items of length 10, for a total of up
to 5 MB of input; with that much input data to read, any overhead
associated with reading and parsing the input can make a significant
difference.</p>
<p>Switching to <code>ByteString</code> is much faster. Why not <code>Text</code>, you ask?
Well, <code>Text</code> has to do a bunch of extra work to deal properly with
Unicode encodings, but in 99.99% of all competitive programming problems
I’ve ever seen, the input is guaranteed to be ASCII. So not
only do we not need <code>Text</code>, we can get away with a version of
<code>ByteString</code> that simply assumes every character is a single 8-bit
byte!</p>
<p>Once we import it, all we need to do is replace a bunch of
<code>String</code> operations with corresponding <code>ByteString</code> ones.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Set</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  BS.lines <span class="op">&gt;&gt;&gt;</span> <span class="fu">drop</span> <span class="dv">1</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (BS.words <span class="op">&gt;&gt;&gt;</span> S.fromList) <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr1</span> S.intersection <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  (\s <span class="ot">-&gt;</span> BS.pack (<span class="fu">show</span> (S.size s)) <span class="op">:</span> S.toList s) <span class="op">&gt;&gt;&gt;</span> BS.unlines</span></code></pre></div>
</section>
</section>
<section id="a-favourable-ending-input-parsing-and-lazy-recursive-structures" class="level2">
<h2>A Favourable Ending: input parsing and lazy recursive structures</h2>
<p>As a last example, let’s look at <a href="https://open.kattis.com/problems/favourable">A Favourable
Ending</a>. This problem
consists of a number of test cases; each test case describes a
choose-your-own-adventure book with a number of sections, where each
section is either an ending (either good or bad), or allows the reader
to choose among three sections to proceed to next. For each test case,
we are asked how many distinct stories there are with good endings.</p>
<p>More abstractly, since we are guaranteed that there are no loops, the
sections of the book form a
<a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>, and we
are asked to count the number of distinct paths in a DAG from a
distinguished start node to any of a distinguished set of “good”
leaves.</p>
<section id="parsing-with-scanner" class="level3">
<h3>Parsing with Scanner</h3>
<p>Parsing the input for this problem is trickier than the other
examples so far. In theory, we could still ignore the first number
specifying the number of test cases, and just continue reading test
cases until EOF. However, each test case begins with a number
specifying the number of sections in the book, and we cannot ignore
this number: we need to know how many lines to read before the start
of the next test case. Doing this manually involves pattern-matching
on a list of lines, using <code>splitAt</code> to split off the lines for each
test case, and manually passing around the list of the remaining
lines: tedious.</p>
<p>Fortunately, Haskell is great at building abstractions to insulate us
from such tedium. I’ve developed a <a href="https://byorgey.github.io/blog/posts/2019/05/22/competitive-programming-in-haskell-scanner.html">simple <code>Scanner</code>
abstraction</a>
which works well in this context.</p>
<p>We begin by creating some data types to represent the input in
structured form:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Book</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Section</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Section</span> <span class="ot">=</span> <span class="dt">End</span> <span class="dt">Disposition</span> <span class="op">|</span> <span class="dt">Choice</span> [<span class="dt">Int</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Disposition</span> <span class="ot">=</span> <span class="dt">Favourably</span> <span class="op">|</span> <span class="dt">Catastrophically</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>)</span></code></pre></div>
<p>Now we can write a <code>Scanner</code> to read a <code>Book</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">book ::</span> <span class="dt">Scanner</span> <span class="dt">Book</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>book <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">&lt;-</span> int</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  M.fromList <span class="op">&lt;$&gt;</span> s <span class="op">&gt;&lt;</span> ((,) <span class="op">&lt;$&gt;</span> int <span class="op">&lt;*&gt;</span> section)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="ot">section ::</span> <span class="dt">Scanner</span> <span class="dt">Section</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>section <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> peek</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="fu">isDigit</span> (BS.head t)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">Choice</span> <span class="op">&lt;$&gt;</span> (<span class="dv">3</span> <span class="op">&gt;&lt;</span> int)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">End</span> <span class="op">.</span> readLower <span class="op">.</span> BS.unpack <span class="op">&lt;$&gt;</span> str</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">readLower ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>readLower <span class="ot">=</span> <span class="fu">read</span> <span class="op">.</span> onHead <span class="fu">toUpper</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="ot">onHead ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>onHead _ [] <span class="ot">=</span> []</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>onHead f (x <span class="op">:</span> xs) <span class="ot">=</span> f x <span class="op">:</span> xs</span></code></pre></div>
<p>(<code>readLower</code> and <code>onHead</code> are functions in my personal competitive
programming template, included here for completeness).</p>
<p>One more piece of boilerplate we can write at this point is the <code>main</code>
function, which simply consists of running the <code>Scanner</code> to read all the
test cases, solving each test case, and formatting the output.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner (numberOf book) <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (solve <span class="op">&gt;&gt;&gt;</span> showB) <span class="op">&gt;&gt;&gt;</span> BS.unlines</span></code></pre></div>
</section>
<section id="dp-topsort-with-a-lazy-recursive-map" class="level3">
<h3>DP + topsort with a lazy recursive map</h3>
<p>With all that framework out of the way, we can turn to actually
solving the problem. And here is where something really fun happens.
In a typical imperative language, we would have to first topologically
sort the book sections, then use dynamic programming to compute the
number of good stories beginning at each section, starting with the
leaves and proceeding backwards through the topological sort to the
start—dozens of lines of code. However, in Haskell we can get all
of this for free, just by defining a lazy, recursive map!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">Book</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>solve book <span class="ot">=</span> endings <span class="op">!</span> <span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    endings <span class="ot">=</span> M.fromList [(p, endingsFrom (book<span class="op">!</span>p)) <span class="op">|</span> p <span class="ot">&lt;-</span> M.keys book]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    endingsFrom (<span class="dt">End</span> d) <span class="ot">=</span> <span class="kw">if</span> d <span class="op">==</span> <span class="dt">Favourably</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    endingsFrom (<span class="dt">Choice</span> ps) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">map</span> (endings <span class="op">!</span>) ps</span></code></pre></div>
<p><code>endings</code> is a <code>Map</code> from each book section to the number of favorable
stories starting with that section. Notice how its values are defined
via the <code>endingsFrom</code> function, which is in turn defined, in the
<code>Choice</code> case, by looking up the values of the choices in the
<code>endings</code> map and summing them. <code>endings</code> is thus defined
recursively, which works because it is lazy in the values. When we
demand the value of <code>endings ! 1</code>, the runtime system starts evaluating
thunks in the map as needed, implicitly doing a topological sort for us.</p>
<p>Here’s another way to think about this: what we really want is the
function <code>endingsFrom : Section -&gt; Int</code>, which tells us how many good
endings there are starting at a given section. It can be defined via a
recurrence; however, if we were to literally implement it as a
recursive function, our program would spend a ridiculous amount of
time recomputing the same values over and over again. So, we insert a
lazy map in the middle to memoize it (there are <a href="https://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html">other data
structures</a>
that can be used for this purpose as well).</p>
</section>
</section>
<section id="resources" class="level2">
<h2>Resources</h2>
<p>Here are some resources in case you’re interested in exploring more.</p>
<ul>
<li><a href="https://open.kattis.com">Open Kattis</a> has a collection of thousands
of high-quality problems which can be solved in Haskell (or many
other languages). If you just want to try solving some problems for
fun, it’s a great place to start.</li>
<li>There are also other sites which accept Haskell, such as
<a href="https://codeforces.com/">Codeforces</a>. Check these out if you want
to actually participate in timed contests.</li>
<li>My public <a href="http://ozark.hendrix.edu/~yorgey/kattis.html">listing of Kattis problems I have solved</a>, with my own personal
rating system.</li>
<li>I’ve written a series of <a href="https://byorgey.github.io/blog/tag/competitive%20programming.html">blog posts</a> about competitive
programming in Haskell, on a variety of topics.</li>
<li>I also have a <a href="https://github.com/byorgey/comprog-hs/">repository of modules</a> I’ve developed
specifically for competitive programming. Many of the modules are
documented in one or more blog posts.</li>
<li>Soumik Sarkar has an even <a href="https://github.com/meooow25/haccepted">larger collection of Haskell libraries for
competitive programming</a>.</li>
</ul>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Introduction to competitive programming in Haskell" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 10 Jun 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/06/10/comprog-hs-intro.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Hendrix College Programming Contest 2025</title>
    <link>http://byorgey.github.io/blog/posts/2025/03/13/HCPC25.html</link>
    <description><![CDATA[
<h1>Hendrix College Programming Contest 2025</h1>

<div class="info">
  Posted on March 13, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>, <a title="All pages tagged &#39;Hendrix&#39;." href="/tag/Hendrix.html" rel="tag">Hendrix</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;contest&#39;." href="/tag/contest.html" rel="tag">contest</a>, <a title="All pages tagged &#39;HCPC&#39;." href="/tag/HCPC.html" rel="tag">HCPC</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>I haven’t written on here in a while, mostly because a lot of my time
has gone into preparing for the second annual <a href="https://hendrix-cs.github.io/hcpc/">Hendrix College
Programming Contest</a>, which will
take place this <a href="https://www.timeanddate.com/worldclock/fixedtime.html?msg=Hendrix+College+Programming+Contest+2025&amp;iso=20250315T1230&amp;p1=134&amp;ah=5">Saturday, March 15, from 12:30-5:30pm CDT (17:30-22:30 UTC)</a>.</p>
<p>I’ve created an <a href="https://hcpc25.kattis.com/contests/vxtved">open mirror
contest</a> which will run in
parallel to the official contest, so if you want to grab some friends
and try solving some of the problems together using your favorite
language, be my guest!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Hendrix College Programming Contest 2025" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 13 Mar 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/03/13/HCPC25.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>You could have invented Fenwick trees</title>
    <link>http://byorgey.github.io/blog/posts/2025/01/23/Fenwick.html</link>
    <description><![CDATA[
<h1>You could have invented Fenwick trees</h1>

<div class="info">
  Posted on January 23, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;segment&#39;." href="/tag/segment.html" rel="tag">segment</a>, <a title="All pages tagged &#39;Fenwick&#39;." href="/tag/Fenwick.html" rel="tag">Fenwick</a>, <a title="All pages tagged &#39;tree&#39;." href="/tag/tree.html" rel="tag">tree</a>, <a title="All pages tagged &#39;JFP&#39;." href="/tag/JFP.html" rel="tag">JFP</a>, <a title="All pages tagged &#39;journal&#39;." href="/tag/journal.html" rel="tag">journal</a>, <a title="All pages tagged &#39;paper&#39;." href="/tag/paper.html" rel="tag">paper</a>
  
</div>

<section>
<p>My paper, <a href="http://ozark.hendrix.edu/~yorgey/pub/Fenwick-ext.pdf">You could have invented Fenwick
trees</a>, has just
been published as a <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/B4628279D4E54229CED97249E96F721D/S0956796824000169a.pdf/you-could-have-invented-fenwick-trees.pdf">Functional Pearl in the Journal of Functional
Programming</a>.
This blog post is an advertisement for the paper, which presents a
novel way to derive the <em>Fenwick tree</em> data structure from first
principles.</p>
<p>Suppose we have a sequence of integers <span class="math inline">\(a_1, \dots, a_n\)</span> and want to be
able to perform two operations:</p>
<ul>
<li>we can <em>update</em> any <span class="math inline">\(a_i\)</span> by adding some value <span class="math inline">\(v\)</span> to it; or</li>
<li>we can perform a <em>range query</em>, which asks for the sum of the values
<span class="math inline">\(a_i + \dots + a_j\)</span> for any range <span class="math inline">\([i,j]\)</span>.</li>
</ul>
<p>There are several ways to solve this problem. For example:</p>
<ol type="1">
<li>We could just keep the sequence of integers in a mutable array.
Updating is <span class="math inline">\(O(1)\)</span>, but range queries are <span class="math inline">\(O(n)\)</span> since we must
actually loop through the range and add up all the values.</li>
<li>We could keep a separate array of <em>prefix sums</em> on the side, so
that <span class="math inline">\(P_i\)</span> stores the sum <span class="math inline">\(a_1 + \dots + a_i\)</span>. Then the range
query on <span class="math inline">\([i,j]\)</span> can be computed as <span class="math inline">\(P_j - P_{i-1}\)</span>, which only
takes <span class="math inline">\(O(1)\)</span>; however, updates now take <span class="math inline">\(O(n)\)</span> since we must also
update all the prefix sums which include the updated element.</li>
<li>We can get the best of both worlds using a <em>segment tree</em>, a binary
tree storing the elements at the leaves, with each internal node
caching the sum of its children. Then both update and range query
can be done in <span class="math inline">\(O(\lg n)\)</span>.</li>
</ol>
<p>I won’t go through the details of this third solution here, but it is
relatively straightforward to understand and implement, especially in
a functional language.</p>
<p>However, there is a fourth solution, known as a <em>Fenwick tree</em> or
<em>Fenwick array</em>, independently invented by <span class="citation" data-cites="ryabko1989fast">Ryabko (1989)</span> and
<span class="citation" data-cites="fenwick1994new">Fenwick (1994)</span>. Here’s a typical Java implementation of a Fenwick
tree:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode .java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FenwickTree <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">long</span><span class="op">[]</span> a<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">FenwickTree</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> a <span class="op">=</span> <span class="kw">new</span> <span class="dt">long</span><span class="op">[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">prefix</span><span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">-=</span> <span class="fu">LSB</span><span class="op">(</span>i<span class="op">))</span> s <span class="op">+=</span> a<span class="op">[</span>i<span class="op">];</span> <span class="cf">return</span> s<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">long</span> delta<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> i <span class="op">&lt;</span> a<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i <span class="op">+=</span> <span class="fu">LSB</span><span class="op">(</span>i<span class="op">))</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> delta<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">range</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">prefix</span><span class="op">(</span>j<span class="op">)</span> <span class="op">-</span> <span class="fu">prefix</span><span class="op">(</span>i<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">get</span><span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="fu">range</span><span class="op">(</span>i<span class="op">,</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">set</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">long</span> v<span class="op">)</span> <span class="op">{</span> <span class="fu">update</span><span class="op">(</span>i<span class="op">,</span> v <span class="op">-</span> <span class="fu">get</span><span class="op">(</span>i<span class="op">));</span> <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">LSB</span><span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">&amp;</span> <span class="op">(-</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I know what you’re thinking: what the heck!? There are some loops adding and
subtracting <code>LSB(i)</code>, which is defined as the bitwise AND of <code>i</code> and
<code>-i</code>? What on earth is this doing? Unless you have seen this
before, this code is probably a complete mystery, as it was for me the
first time I encountered it.</p>
<p>However, from the right point of view, we can derive this mysterious imperative
code as an optimization of segment trees. In particular, in my
paper I show how we can:</p>
<ol type="1">
<li>Start with a segment tree.</li>
<li>Delete some redundant info from the segment tree, and shove the
remaining values into an array in a systematic way.</li>
<li>Define operations for moving around in the resulting Fenwick array by
converting array indices to indices in a segment tree, moving
around the tree appropriately, and converting back.</li>
<li>Describe these operations using a Haskell EDSL for
infinite-precision 2’s complement binary arithmetic, and fuse away
all the intermediate conversion steps, until the above mysterious
implementation pops out.</li>
<li>Profit.</li>
</ol>
<p>I may be exaggerating step 5 a teensy bit. But you’ll find everything
else described in much greater detail, with pretty pictures, in the
paper! The <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/you-could-have-invented-fenwick-trees/B4628279D4E54229CED97249E96F721D">official JFP version is here</a>, and here’s an <a href="http://ozark.hendrix.edu/~yorgey/pub/Fenwick-ext.pdf">extended
version with an appendix containing an omitted proof</a>.</p>
<section id="references" class="level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-fenwick1994new" class="csl-entry" role="listitem">
Fenwick, Peter M. 1994. <span>“A New Data Structure for Cumulative Frequency Tables.”</span> <em>Software: Practice and <span>E</span>xperience</em> 24 (3): 327–36.
</div>
<div id="ref-ryabko1989fast" class="csl-entry" role="listitem">
Ryabko, Boris Yakovlevich. 1989. <span>“A Fast on-Line Code.”</span> In <em>Doklady Akademii Nauk</em>, 306:548–52. 3. Russian Academy of Sciences.
</div>
</div>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="You could have invented Fenwick trees" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 23 Jan 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/01/23/Fenwick.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: stacks, queues, and monoidal sliding windows</title>
    <link>http://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: stacks, queues, and monoidal sliding windows</h1>

<div class="info">
  Posted on November 27, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;stack&#39;." href="/tag/stack.html" rel="tag">stack</a>, <a title="All pages tagged &#39;queue&#39;." href="/tag/queue.html" rel="tag">queue</a>, <a title="All pages tagged &#39;sliding window&#39;." href="/tag/sliding%20window.html" rel="tag">sliding window</a>, <a title="All pages tagged &#39;monoid&#39;." href="/tag/monoid.html" rel="tag">monoid</a>, <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>, <a title="All pages tagged &#39;haskell&#39;." href="/tag/haskell.html" rel="tag">haskell</a>
  
</div>

<section>
<p>Suppose we have a list of items of length <span class="math inline">\(n\)</span>, and we want to
consider <em>windows</em> (<em>i.e.</em> contiguous subsequences) of width <span class="math inline">\(w\)</span>
within the list.</p>
<p><span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">A list of numbers, with contiguous size-3 windows highlighted<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/84a9401ef1ac9137.svg" />
</figure>
<p>We can compute the <em>sum</em> of each window by brute
force in <span class="math inline">\(O(nw)\)</span> time, by simply generating the list of all the
windows and then summing each. But, of course, we can do better: keep
track of the sum of the current window; every time we slide the window
one element to the right we can add the new element that enters the
window on the right and subtract the element that falls of the window
to the left. Using this “sliding window” technique, we can compute the
sum of every window in only <span class="math inline">\(O(n)\)</span> total time instead of <span class="math inline">\(O(nw)\)</span>.</p>
<p>How about finding the <em>maximum</em> of every window? Of course the brute
force <span class="math inline">\(O(nw)\)</span> algorithm still works, but doing it in only <span class="math inline">\(O(n)\)</span> is
considerably trickier! We can’t use the same trick as we did for sums
since there’s no way to “subtract” the element falling off the left.
This really comes down to the fact that addition forms a <em>group</em>
(<em>i.e.</em> a monoid-with-inverses), but <code>max</code> does not. So more
generally, the question is: how can we compute a <em>monoidal</em> summary
for every window in only <span class="math inline">\(O(n)\)</span> time?</p>
<p>Today I want to show you how to solve this problem using one of my
favorite competitive programming tricks, which fits beautifully in a
functional context. Along the way we’ll also see how to implement
simple yet efficient functional queues.</p>
<section id="stacks" class="level2">
<h2>Stacks</h2>
<p>Before we get to queues, we need to take a detour through stacks.
Stacks in Haskell are pretty boring. We can just use a list, with the
front of the list corresponding to the top of the stack. However, to
make things more interesting—and because it will come in very handy
later—we’re going to implement <em>monoidally-annotated</em> stacks. Every
element on the stack will have a <em>measure</em>, which is a value from some
monoid <code>m</code>. We then want to be able to query any stack for the total
of all the measures in <span class="math inline">\(O(1)\)</span>. For example, perhaps we want to always
be able to find the sum or max of all the elements on a stack.</p>
<p>If we wanted to implement stacks annotated by a <em>group</em>, we could just
do something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GroupStack</span> g a <span class="ot">=</span> <span class="dt">GroupStack</span> (a <span class="ot">-&gt;</span> g) <span class="op">!</span>g [a]</span></code></pre></div>
<p>That is, a <code>GroupStack</code> stores a <em>measure function</em>, which assigns to
each element of type <code>a</code> a measure of type <code>g</code> (which is intended to
be a <code>Group</code>); a value of type <code>g</code> representing the sum (via the group
operation) of measures of all elements on the stack; and the actual
stack itself. To push, we would just compute the measure of the new element
and add it to the cached <code>g</code> value; to pop, we subtract the measure of
the element being popped, something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">push ::</span> a <span class="ot">-&gt;</span> <span class="dt">GroupStack</span> g a <span class="ot">-&gt;</span> <span class="dt">GroupStack</span> g a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>push a (<span class="dt">GroupStack</span> f g as) <span class="ot">=</span> <span class="dt">GroupStack</span> f (f a <span class="op">&lt;&gt;</span> g) (a<span class="op">:</span>as)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">GroupStack</span> g a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">GroupStack</span> g a)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>pop (<span class="dt">GroupStack</span> f g as) <span class="ot">=</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  (a<span class="op">:</span>as&#39;) <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, <span class="dt">GroupStack</span> f (inv (f a) <span class="op">&lt;&gt;</span> g) as&#39;)</span></code></pre></div>
<p>But this won’t work for a monoid, of course. The problem is <code>pop</code>, where
we can’t just subtract the measure for the element being
popped. Instead, we need to be able to <em>restore</em> the measure of a
previous stack. Hmmm… sounds like we might be able to use… a stack! We
could just store a stack of measures alongside the stack of elements;
even better is to store a stack of <em>pairs</em>. That is, each element on
the stack is paired with an annotation representing the sum of all the
measures at or below it. Here, then, is our representation of
monoidally-annotated stacks:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Stack</span> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stack</span> m a <span class="ot">=</span> <span class="dt">Stack</span> (a <span class="ot">-&gt;</span> m) <span class="op">!</span><span class="dt">Int</span> [(m, a)]</span></code></pre></div>
<p>A <code>Stack m a</code> stores three things:</p>
<ol type="1">
<li><p>A measure function of type <code>a -&gt; m</code>.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Incidentally, what if we want
to be able to specify an arbitrary measure for each element, and
even give different measures to the same element at different
times? Easy: just use <code>(m,a)</code> pairs as elements, and use <code>fst</code> as
the measure function.<br />
<br />
</span></span></p></li>
<li><p>An <code>Int</code> representing the size of the stack. This is not strictly
necessary, especially since one could always just use a monoidal
annotation to keep track of the size; but wanting the size is so
ubiquitous that it seems convenient to just include it as a special
case.</p></li>
<li><p>The aforementioned stack of (annotation, element) pairs.</p></li>
</ol>
<p>Note that we cannot write a <code>Functor</code> instance for <code>Stack m</code>, since
<code>a</code> occurs contravariantly in <code>(a -&gt; m)</code>. But this makes sense: if we
change all the <code>a</code> values, the cached measures would no longer be valid.</p>
<p>When creating a new, empty stack, we have to specify the measure
function; to get the measure of a stack, we just look up the measure
on top, or return <code>mempty</code> for an empty stack.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>new f <span class="ot">=</span> <span class="dt">Stack</span> f <span class="dv">0</span> []</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Stack</span> _ n _) <span class="ot">=</span> n</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">measure ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> m</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>measure (<span class="dt">Stack</span> _ _ as) <span class="ot">=</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="fu">mempty</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  (m, _) <span class="op">:</span> _ <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>Now let’s implement <code>push</code> and <code>pop</code>. Both are relatively
straightforward.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">push ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>push a s<span class="op">@</span>(<span class="dt">Stack</span> f n as) <span class="ot">=</span> <span class="dt">Stack</span> f (n <span class="op">+</span> <span class="dv">1</span>) ((f a <span class="op">&lt;&gt;</span> measure s, a) <span class="op">:</span> as)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Stack</span> m a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>pop (<span class="dt">Stack</span> f n as) <span class="ot">=</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  (_, a) <span class="op">:</span> as&#39; <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, <span class="dt">Stack</span> f (n <span class="op">-</span> <span class="dv">1</span>) as&#39;)</span></code></pre></div>
<p>Note that if we care about using <em>non-commutative</em> monoids,
in the implementation of <code>push</code> we have a choice to make between <code>f a &lt;&gt; measure s</code> and <code>measure s &lt;&gt; f a</code>. The former seems nicer to me,
since it keeps the measures “in the same order” as the list
representing the stack. For example, if we push a list of elements
onto a stack via <code>foldr</code>, using the measure function <code>(:[])</code> that injects
each element into the monoid of lists, the resulting <code>measure</code> is just
the original list:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>measure <span class="op">.</span> <span class="fu">foldr</span> push (new (<span class="op">:</span>[])) <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>And more generally, for any measure function <code>f</code>, we have</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>measure <span class="op">.</span> <span class="fu">foldr</span> push (new f) <span class="op">==</span> <span class="fu">foldMap</span> f</span></code></pre></div>
<p>Finally, we are going to want a function to <em>reverse</em> a stack, which
is a one-liner:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> (<span class="dt">Stack</span> f _ as) <span class="ot">=</span> foldl&#39; (<span class="fu">flip</span> push) (new f) (<span class="fu">map</span> <span class="fu">snd</span> as)</span></code></pre></div>
<p>That is, to reverse a stack, we extract the elements and then use
<code>foldl'</code> to push the elements one at a time onto a new stack using the
same measure function.</p>
<p>There is a <a href="https://github.com/byorgey/comprog-hs/blob/master/Stack.hs">bit more code you can find on
GitHub</a>,
such as <code>Show</code> and <code>Eq</code> instances.</p>
</section>
<section id="queues" class="level2">
<h2>Queues</h2>
<p>Now that we have monoidally-annotated stacks under our belt, let’s
turn to queues. And here’s where my favorite trick is revealed: we
can implement a queue out of two stacks, so that enqueue and dequeue
run in <span class="math inline">\(O(1)\)</span> amortized time; and if we use monoidally-annotated
stacks, we get monoidally-annotated queues for free!</p>
<p>First, some imports.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Queue</span> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (second)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Stack</span> (<span class="dt">Stack</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Stack</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">Stack</span></span></code></pre></div>
<p>A <code>Queue m a</code> just consists of two stacks, one for the front and one
for the back. To create a <code>new</code> queue, we just create two new stacks;
to get the <code>size</code> of a queue, we just add the sizes of the stacks; to
get the <code>measure</code> of a queue, we just combine the measures of the
stacks. Easy peasy.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CommutativeMonoid</span> <span class="ot">=</span> <span class="dt">Monoid</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Queue</span> m a <span class="ot">=</span> <span class="dt">Queue</span> {<span class="ot">getFront ::</span> <span class="dt">Stack</span> m a,<span class="ot"> getBack ::</span> <span class="dt">Stack</span> m a}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>new f <span class="ot">=</span> <span class="dt">Queue</span> (Stack.new f) (Stack.new f)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Queue</span> front back) <span class="ot">=</span> Stack.size front <span class="op">+</span> Stack.size back</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">measure ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> m</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>measure (<span class="dt">Queue</span> front back) <span class="ot">=</span> Stack.measure front <span class="op">&lt;&gt;</span> Stack.measure back</span></code></pre></div>
<p>Note the restriction to <em>commutative</em> monoids, since the queue
elements are stored in different orders in the front and back stacks.
If we really cared about making this work with non-commutative
monoids, we would have to make two different <code>push</code> methods for the
front and back stacks, to combine the measures in opposite orders.
That just doesn’t seem worth it. But if you have a good example
requiring the use of a queue annotated by a non-commutative monoid,
I’d love to hear it!</p>
<p>Now, to <code>enqueue</code>, we just push the new element on the back:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">enqueue ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>enqueue a (<span class="dt">Queue</span> front back) <span class="ot">=</span> <span class="dt">Queue</span> front (Stack.push a back)</span></code></pre></div>
<p>Dequeueing is the magic bit that makes everything work. If there are
any elements in the front stack, we can just pop from there.
Otherwise, we need to first reverse the back stack into the front
stack. This means <code>dequeue</code> may occasionally take <span class="math inline">\(O(n)\)</span> time, but it’s
still <span class="math inline">\(O(1)\)</span> amortized.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">The easiest way to see this is to note that
every element is touched exactly three times: once when it is pushed
on the back; once when it is transferred from the back to the front;
and once when it is popped from the front. So, overall, we do <span class="math inline">\(O(1)\)</span>
work per element.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dequeue ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Queue</span> m a)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>dequeue (<span class="dt">Queue</span> front back)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> Stack.size front <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> Stack.size back <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> Stack.size front <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> dequeue (<span class="dt">Queue</span> (Stack.reverse back) front)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> second (\front&#39; <span class="ot">-&gt;</span> <span class="dt">Queue</span> front&#39; back) <span class="op">&lt;$&gt;</span> Stack.pop</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  front</span></code></pre></div>
<p>Finally, for convenience, we can make a function <code>drop1</code> which just
dequeues an item from the front of a queue and throws it away.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">drop1 ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>drop1 q <span class="ot">=</span> <span class="kw">case</span> dequeue q <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> q</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (_, q&#39;) <span class="ot">-&gt;</span> q&#39;</span></code></pre></div>
<p>This “banker’s queue” method of building a queue out of two stacks is
discussed in <em>Purely Functional Data Structures</em> by Okasaki, though I
don’t think he was the first to come up with the idea. It’s also
possible to use some clever tricks to <a href="https://www.hedonisticlearning.com/posts/global-rebuilding-coroutines-and-defunctionalization.html">make both <code>enqueue</code> and
<code>dequeue</code> take <span class="math inline">\(O(1)\)</span> time in the <em>worst</em>
case</a>.
In a future post I’d like to do some benchmarking to compare various
queue implementations (<em>i.e.</em> banker’s queues, <code>Data.Sequence</code>,
circular array queues built on top of <code>STArray</code>). At least
anecdotally, in solving some sliding window problems, banker’s queues
seem quite fast so far.</p>
</section>
<section id="sliding-windows" class="level2">
<h2>Sliding windows</h2>
<p>I hope you can see how this solves the initial motivating problem: to
find <em>e.g.</em> the max of a sliding window, we can just put the elements
in a monoidally-annotated queue, enqueueing and dequeueing one element
every time we slide the window over.<span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">More generally, of course, it
doesn’t even matter if the left and right ends of the window stay
exactly in sync; we can enqueue and dequeue as many times as we want.<br />
<br />
</span></span> The following <code>windows</code> function computes the monoidal sum <code>foldMap f window</code> for each window of width <span class="math inline">\(w\)</span>, in only <span class="math inline">\(O(n)\)</span> time
overall.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">windows ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [m]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>windows w f as <span class="ot">=</span> go startQ rest</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  (start, rest) <span class="ot">=</span> <span class="fu">splitAt</span> w as</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  startQ <span class="ot">=</span> foldl&#39; (<span class="fu">flip</span> enqueue) (new f) start</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  go q as <span class="ot">=</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    measure q <span class="op">:</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      [] <span class="ot">-&gt;</span> []</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      a <span class="op">:</span> as <span class="ot">-&gt;</span> go (enqueue a (drop1 q)) as</span></code></pre></div>
<p>“But…maximum and minimum do not form monoids, only semigroups!”
I hear you cry. Well, we can just adjoin special positive or negative
infinity elements as needed, like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Max</span> a <span class="ot">=</span> <span class="dt">NegInf</span> <span class="op">|</span> <span class="dt">Max</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Max</span> a) <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NegInf</span> <span class="op">&lt;&gt;</span> a <span class="ot">=</span> a</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  a <span class="op">&lt;&gt;</span> <span class="dt">NegInf</span> <span class="ot">=</span> a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Max</span> a <span class="op">&lt;&gt;</span> <span class="dt">Max</span> b <span class="ot">=</span> <span class="dt">Max</span> (<span class="fu">max</span> a b)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Max</span> a) <span class="kw">where</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">NegInf</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Min</span> a <span class="ot">=</span> <span class="dt">Min</span> a <span class="op">|</span> <span class="dt">PosInf</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Min</span> a) <span class="kw">where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PosInf</span> <span class="op">&lt;&gt;</span> a <span class="ot">=</span> a</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  a <span class="op">&lt;&gt;</span> <span class="dt">PosInf</span> <span class="ot">=</span> a</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Min</span> a <span class="op">&lt;&gt;</span> <span class="dt">Min</span> b <span class="ot">=</span> <span class="dt">Min</span> (<span class="fu">min</span> a b)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Min</span> a) <span class="kw">where</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">PosInf</span></span></code></pre></div>
<p>Now we can write, for example, <code>windows 3 Max [1,4,2,8,9,4,4,6]</code> which
yields <code>[Max 4, Max 8, Max 9, Max 9, Max 9, Max 6]</code>, the maximums of
each 3-element window.</p>
</section>
<section id="challenges" class="level2">
<h2>Challenges</h2>
<p>If you’d like to try solving some problems using the techniques from this
blog post, I can recommend the following (generally in order of difficulty):</p>
<ul>
<li><a href="https://open.kattis.com/problems/tiredterry">Tired Terry</a></li>
<li><a href="https://open.kattis.com/problems/treeshopping">Tree Shopping</a></li>
<li><a href="https://open.kattis.com/problems/einvigi">Einvígi</a></li>
<li><a href="https://open.kattis.com/problems/hockeyfans">Hockey Fans</a></li>
</ul>
<p>In a future post I’ll walk through my solution to <a href="https://open.kattis.com/problems/hockeyfans">Hockey
Fans</a>. And here’s another
couple problems along similar lines; unlike the previous problems I am
not so sure how to solve these in a nice way. I may write about them
in the future.</p>
<ul>
<li><a href="https://open.kattis.com/problems/martiandna">Martian DNA</a></li>
<li><a href="https://open.kattis.com/problems/slidecount">Slide Count</a></li>
</ul>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: stacks, queues, and monoidal sliding windows" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Wed, 27 Nov 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Union-Find, part II</title>
    <link>http://byorgey.github.io/blog/posts/2024/11/18/UnionFind-sols.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Union-Find, part II</h1>

<div class="info">
  Posted on November 18, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;union-find&#39;." href="/tag/union-find.html" rel="tag">union-find</a>, <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>, <a title="All pages tagged &#39;haskell&#39;." href="/tag/haskell.html" rel="tag">haskell</a>
  
</div>

<section>
<p>In my <a href="https://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html">previous
post</a>
I explained how to implement a reasonably efficient <em>union-find</em> data
structure in Haskell, and challenged you to solve a couple Kattis
problems. In this post, I will (1) touch on a few generalizations
brought up in the comments of my last post, (2) go over my solutions
to the two challenge problems, and (3) briefly discuss generalizing
the second problem’s solution to finding max-edge decompositions of
weighted trees.</p>
<section id="generalizations" class="level2">
<h2>Generalizations</h2>
<p>Before going on to explain my solutions to those problems, I want to
highlight some things from a <a href="https://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html#isso-1971">comment by Derek
Elkins</a>
and a related <a href="https://www.philipzucker.com/union-find-groupoid/">blog post by Philip
Zucker</a>. The first
is that instead of (or in addition to) annotating each set with a
value from a commutative semigroup, we can also annotate the <em>edges</em>
between nodes with elements from a
<a href="https://en.wikipedia.org/wiki/Group_(mathematics)">group</a> (or, more
generally, a <a href="https://en.wikipedia.org/wiki/Groupoid">groupoid</a>). The
idea is that each edge records some information about, or evidence
for, the <em>relationship</em> between the endpoints of the edge. To compute
information about the relationship between two arbitrary nodes in the
same set, we can compose elements along the path between them. This
is a nifty idea—I have never personally seen it used for a
competitive programming problem, but it probably has been at some
point. (It kind of makes me want to write such a problem!) And of
course it has “real” applications beyond competitive programming as
well. I have not actually generalized my union-find code to allow
edge annotations; I leave it as an exercise for the reader.</p>
<p>The other idea to highlight is that instead of thinking in terms of
<em>disjoint sets</em>, what we are really doing is building an <a href="https://www.jonmsterling.com/jms-00L3.xml"><em>equivalence
relation</em></a>, which
partitions the elements into disjoint equivalence classes. In
particular, we do this by incrementally building a relation <span class="math inline">\(R\)</span>, where
the union-find structure represents the reflexive, transitive,
symmetric closure of <span class="math inline">\(R\)</span>. We start with the empty relation <span class="math inline">\(R\)</span> (whose
reflexive, transitive, symmetric closure is the discrete equivalence
relation, with every element in its own equivalence class); every
<span class="math inline">\(\mathit{union}(x,y)\)</span> operation adds <span class="math inline">\((x,y)\)</span> to <span class="math inline">\(R\)</span>; and the <span class="math inline">\(\mathit{find}(x)\)</span>
operation computes a canonical representative of the equivalence class
of <span class="math inline">\(x\)</span>. In other words, given some facts about which things are
related to which other things (possibly along with some associated
evidence), the union-find structure keeps track of everything we can
infer from the given facts and the assumption that the relation is an
equivalence.</p>
<p>Finally, through the comments I also learned about other
potentially-faster-in-practice schemes for doing path compression such
as <a href="https://algocoding.wordpress.com/2015/05/13/simple-union-find-techniques/">Rem’s
Algorithm</a>;
I leave it for future me to try these out and see if they speed things up.</p>
<p>Now, on to the solutions!</p>
</section>
<section id="duck-journey" class="level2">
<h2>Duck Journey</h2>
<p>In <a href="https://open.kattis.com/problems/andvag">Duck Journey</a>, we are
essentially given a graph with edges labelled by bitstrings, where
edges along a path are combined using bitwise OR. We are then asked
to find the <em>greatest</em> possible value of a path between two given
vertices, assuming that we are allowed to retrace our steps as much as
we want.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Incidentally, if we are <em>not</em> allowed to retrace our steps,
this problem probably becomes NP-hard.<br />
<br />
</span></span> If we can retrace our steps,
then on our way from A to B we might as well visit every edge in the
entire connected component, so this problem is not really
about path-finding at all. It boils down to two things: (1) being
able to quickly test whether two given vertices are in the same
connected component or not, and (2) computing the bitwise OR of all
the edge labels in each connected component.</p>
<p>One way to solve this would be to first use some kind of graph
traversal, like DFS, to find the connected components and build a map
from vertices to component labels; then partition the edges by
component and take the bitwise OR of all the edge weights in each
component. To answer queries we could first look up the component
label of the two vertices; if the labels are the same then we look up
the total weight for that component.</p>
<p>This works, and is in some sense the most “elemantary” solution, but
it requires building some kind of graph data structure, storing all
the edges in memory, doing the component labelling via DFS and
building another map, and so on. An alternative solution is to use a
union-find structure with a bitstring annotation for each set: as we
read in the edges in the input, we simply union the endpoints of the
edge, and then update the bitstring for the resulting equivalence
class with the bitstring for the edge. If we take a union-find library
as given, this solution seems simpler to me.</p>
<p>First, some imports and the top-level <code>main</code> function. (<a href="https://github.com/byorgey/comprog-hs/blob/master/ScannerBS.hs">See here for the <code>ScannerBS</code> module</a>.)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bits</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> (<span class="dt">ByteString</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ScannerBS</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">UnionFind</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">UF</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner tc <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> format</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ot">format ::</span> [<span class="dt">Maybe</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>format <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">maybe</span> <span class="st">&quot;-1&quot;</span> (<span class="fu">show</span> <span class="op">&gt;&gt;&gt;</span> BS.pack)) <span class="op">&gt;&gt;&gt;</span> BS.unlines</span></code></pre></div>
<p>Next, some data types to represent the input, and a <code>Scanner</code> to read
it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Each edge is a &quot;filter&quot; represented as a bitstring stored as an Int.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Filter</span> <span class="ot">=</span> <span class="dt">Filter</span> <span class="dt">Int</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Filter</span> <span class="kw">where</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Filter</span> x <span class="op">&lt;&gt;</span> <span class="dt">Filter</span> y <span class="ot">=</span> <span class="dt">Filter</span> (x <span class="op">.|.</span> y)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">filterSize ::</span> <span class="dt">Filter</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>filterSize (<span class="dt">Filter</span> f) <span class="ot">=</span> popCount f</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Channel</span> <span class="ot">=</span> <span class="dt">Channel</span> <span class="dt">UF.Node</span> <span class="dt">UF.Node</span> <span class="dt">Filter</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot">n ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> channels ::</span> [<span class="dt">Channel</span>],<span class="ot"> queries ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]}</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> int</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  q <span class="ot">&lt;-</span> int</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  channels <span class="ot">&lt;-</span> m <span class="op">&gt;&lt;</span> (<span class="dt">Channel</span> <span class="op">&lt;$&gt;</span> int <span class="op">&lt;*&gt;</span> int <span class="op">&lt;*&gt;</span> (<span class="dt">Filter</span> <span class="op">&lt;$&gt;</span> int))</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  queries <span class="ot">&lt;-</span> q <span class="op">&gt;&lt;</span> pair int int</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span> {<span class="op">..</span>}</span></code></pre></div>
<p>Finally, here’s the solution itself: process each channel with a
union-find structure, then process queries. The annoying thing, of
course, is that this all has to be in the <code>ST</code> monad, but other than
that it’s quite straightforward.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">TC</span> <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> <span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>solve <span class="dt">TC</span> {<span class="op">..</span>} <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  uf <span class="ot">&lt;-</span> UF.new (n <span class="op">+</span> <span class="dv">1</span>) (<span class="dt">Filter</span> <span class="dv">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (addChannel uf) channels</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM</span> (answer uf) queries</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">addChannel ::</span> <span class="dt">UF.UnionFind</span> s <span class="dt">Filter</span> <span class="ot">-&gt;</span> <span class="dt">Channel</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>addChannel uf (<span class="dt">Channel</span> a b f) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  UF.union uf a b</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  UF.updateAnn uf a f</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">answer ::</span> <span class="dt">UF.UnionFind</span> s <span class="dt">Filter</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>answer uf (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> UF.connected uf a b</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> c <span class="kw">of</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">.</span> filterSize <span class="op">&lt;$&gt;</span> UF.getAnn uf a</span></code></pre></div>
</section>
<section id="inventing-test-data" class="level2">
<h2>Inventing Test Data</h2>
<p>In <a href="https://open.kattis.com/problems/inventing">Inventing Test Data</a>,
we are given a tree <span class="math inline">\(T\)</span> with integer weights on its edges, and asked
to find the minimum possible weight of a complete graph for which <span class="math inline">\(T\)</span>
is the unique <a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning
tree</a> (MST).</p>
<p><span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote"><img src="images/T-with-non-edge.png" /><br />
<br />
</span></span></p>
<p>Let <span class="math inline">\(e = (x,y)\)</span> be some edge which is not in <span class="math inline">\(T\)</span>. There must be a
unique path between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> in <span class="math inline">\(T\)</span> (so adding <span class="math inline">\(e\)</span> to <span class="math inline">\(T\)</span> would
complete a cycle); let <span class="math inline">\(m\)</span> be the maximum weight of the edges along
this path. Then I claim that we must give edge <span class="math inline">\(e\)</span> weight <span class="math inline">\(m+1\)</span>:</p>
<ul>
<li>On the one hand, this ensures <span class="math inline">\(e\)</span> can never be in any MST, since an
edge which is strictly the largest edge in some cycle can never be
part of an MST (this is often called the “cycle property”).</li>
<li>Conversely, if <span class="math inline">\(e\)</span> had a weight less than or equal to <span class="math inline">\(m\)</span>, then <span class="math inline">\(T\)</span>
would not be a MST (or at least not uniquely): we
could remove any edge in the path from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> through <span class="math inline">\(T\)</span> and
replace it with <span class="math inline">\(e\)</span>, resulting in a spanning tree with a lower (or
equal) weight.</li>
</ul>
<p>Hence, every edge not in <span class="math inline">\(T\)</span> must be given a weight one more than the
largest weight in the unique <span class="math inline">\(T\)</span>-path connecting its endpoints; these
are the minimum weights that ensure <span class="math inline">\(T\)</span> is a unique MST.</p>
</section>
<section id="a-false-start" class="level2">
<h2>A false start</h2>
<p>At first, I thought what we needed was a way to quickly compute this
max weight along any path in the tree (where by “quickly” I mean
something like “faster than linear in the length of the path”). There
are indeed ways to do this, for example, using a heavy-light
decomposition and then putting a data structure on each heavy path
that allows us to query subranges of the path quickly. (If we use a
segment tree on each path we can even support operations to <em>update</em>
the edge weights quickly.)</p>
<p>All this is fascinating, and something I
may very well write about later. But it doesn’t actually help! Even
if we could find the max weight along any path in <span class="math inline">\(O(1)\)</span>, there are
still <span class="math inline">\(O(V^2)\)</span> edges to loop over, which is too big. There can be up
to <span class="math inline">\(V = 15\,000\)</span> nodes in the tree, so <span class="math inline">\(V^2 = 2.25 \times 10^8\)</span>. A
good rule of thumb is <span class="math inline">\(10^8\)</span> operations per second, and there are
likely to be very high constant factors hiding in whatever complex
data structures we use to query paths efficiently.</p>
<p>So we need a way to somehow process many edges at once. As usual, a
change in perspective is helpful; to get there we first need to take a
slight detour.</p>
</section>
<section id="kruskals-algorithm" class="level2">
<h2>Kruskal’s Algorithm</h2>
<p>It helps to be familiar with <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal’s
Algorithm</a>, which
is the simplest algorithm I know for finding minimum spanning
trees:</p>
<ul>
<li>Sort the edges from smallest to biggest weight.</li>
<li>Initialize <span class="math inline">\(T\)</span> to an empty set of edges.</li>
<li>For each edge <span class="math inline">\(e\)</span> in order from smallest to biggest:
<ul>
<li>If <span class="math inline">\(e\)</span> does not complete a cycle with the other edges already in
<span class="math inline">\(T\)</span>, add <span class="math inline">\(e\)</span> to <span class="math inline">\(T\)</span>.</li>
</ul></li>
</ul>
<p>To efficiently check whether <span class="math inline">\(e\)</span> completes a cycle with the other
edges in <span class="math inline">\(T\)</span>, we can use a union-find, of course: we maintain
equivalence classes of vertices under the “is connected to”
equivalence relation; adding <span class="math inline">\(e\)</span> would complete a cycle if and only if
the endpoints of <span class="math inline">\(e\)</span> are already connected to each other in <span class="math inline">\(T\)</span>. If
we do add an edge <span class="math inline">\(e\)</span>, we can just <span class="math inline">\(\mathit{union}\)</span> its endpoints to properly
maintain the relation.</p>
</section>
<section id="a-change-of-perspective" class="level2">
<h2>A change of perspective</h2>
<p>So how does this help us solve “Inventing Test Data”? After all, we
are not being directly asked to find a minimum spanning tree.
However, it’s still helpful to think about the process Kruskal’s
Algorithm <em>would</em> go through, in order to choose edge weights that
will force it to do what we want (<em>i.e.</em> pick all the edges in <span class="math inline">\(T\)</span>).
That is, instead of thinking about each individual edge <em>not</em> in <span class="math inline">\(T\)</span>,
we can instead think about the edges that <em>are</em> in <span class="math inline">\(T\)</span>, and what must
be true to force Kruskal’s algorithm to pick each one.</p>
<p>Suppose we are part of the way through running Kruskal’s algorithm,
and that it is about to consider a given edge <span class="math inline">\(e = (x,y) \in T\)</span> which
has weight <span class="math inline">\(w_e\)</span>. At this point it has already considered any edges
with smaller weight, and (we shall assume) chosen all the
smaller-weight edges in <span class="math inline">\(T\)</span>. So let <span class="math inline">\(X\)</span> be the set of vertices
reachable from <span class="math inline">\(x\)</span> by edges in <span class="math inline">\(T\)</span> with weight less than or equal to
<span class="math inline">\(w_e\)</span>, and similarly let <span class="math inline">\(Y\)</span> be those reachable from <span class="math inline">\(y\)</span>. Kruskal’s
algorithm will pick edge <span class="math inline">\(e\)</span> after checking that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are
disjoint.</p>
<p><span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote"><img src="images/XY-edges.png" /><br />
<br />
</span></span></p>
<p>Think about all the <em>other</em> edges from <span class="math inline">\(X\)</span> to <span class="math inline">\(Y\)</span>: all of them must
have weight greater than <span class="math inline">\(w_e\)</span>, because otherwise Kruskal’s algorithm
would have already considered them earlier, and used one of them to
connect <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. In fact, <em>all</em> of these edges must have weight
<span class="math inline">\(w_e + 1\)</span>, as we argued earlier, since <span class="math inline">\(e\)</span> is the largest-weight edge
on the <span class="math inline">\(T\)</span>-path between their endpoints (all the other edges on these
paths were already chosen earlier and hence have smaller weight). The
number of such edges is just <span class="math inline">\(|X| |Y| - 1\)</span> (there is an edge for every
pair of vertices, but we do not want to count <span class="math inline">\(e\)</span> itself). Hence they
contribute a total of <span class="math inline">\((|X||Y| - 1)(w_e + 1)\)</span> to the sum of edge
weights.</p>
<p>Hopefully the solution is now becoming clear: we process the edges of
<span class="math inline">\(T\)</span> in order from smallest to biggest, using a union-find to keep
track equivalence classes of connected vertices so far. For each edge
<span class="math inline">\((x,y)\)</span> we look up the sizes of the equivalence classes of <span class="math inline">\(x\)</span> and
<span class="math inline">\(y\)</span>, add <span class="math inline">\((|X||Y| - 1)(w_e + 1)\)</span> to a running total, and union. This
accounts for all the edges not in <span class="math inline">\(T\)</span>; finally we must also add the
weights of the edges in <span class="math inline">\(T\)</span> themselves.</p>
<p>First some standard pragmas and imports, along with some data types
and a <code>Scanner</code> to parse the input. Note the custom <code>Ord</code> instance
for <code>Edge</code>, so we can sort edges by weight.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sort)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ord</span> (comparing)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ScannerBS</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">UnionFind</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">UF</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner (numberOf tc) <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (solve <span class="op">&gt;&gt;&gt;</span> <span class="fu">show</span> <span class="op">&gt;&gt;&gt;</span> BS.pack) <span class="op">&gt;&gt;&gt;</span> BS.unlines</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Edge</span> <span class="ot">=</span> <span class="dt">Edge</span> {<span class="ot">a ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> w ::</span> <span class="op">!</span><span class="dt">Integer</span>}</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Edge</span> <span class="kw">where</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> <span class="ot">=</span> comparing w</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot">n ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> edges ::</span> [<span class="dt">Edge</span>]}</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">&lt;-</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">&gt;&lt;</span> (<span class="dt">Edge</span> <span class="op">&lt;$&gt;</span> int <span class="op">&lt;*&gt;</span> int <span class="op">&lt;*&gt;</span> integer)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span> {<span class="op">..</span>}</span></code></pre></div>
<p>Finally, the (remarkably short) solution proper: we <code>sort</code> the edges
and process them from smallest to biggest; for each edge we update an
accumulator according to the formula discussed above. Since we’re
already tied to the <code>ST</code> monad anyway, we might as well keep the
accumulator in a mutable <code>STRef</code> cell.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">TC</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>solve <span class="dt">TC</span> {<span class="op">..</span>} <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  uf <span class="ot">&lt;-</span> UF.new (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  total <span class="ot">&lt;-</span> newSTRef (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Integer</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (processEdge uf total) (<span class="fu">sort</span> edges)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  readSTRef total</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ot">processEdge ::</span> <span class="dt">UF.UnionFind</span> s <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Edge</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>processEdge uf total (<span class="dt">Edge</span> a b w) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  modifySTRef&#39; total (<span class="op">+</span> w)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  sa <span class="ot">&lt;-</span> UF.size uf a</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  sb <span class="ot">&lt;-</span> UF.size uf b</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  modifySTRef&#39; total (<span class="op">+</span> (<span class="fu">fromIntegral</span> sa <span class="op">*</span> <span class="fu">fromIntegral</span> sb <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (w <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  UF.union uf a b</span></code></pre></div>
</section>
<section id="max-edge-decomposition" class="level2">
<h2>Max-edge decomposition</h2>
<p><span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="marginnote"><img src="images/max-edge-decomp.png" /><br />
<br />
</span></span></p>
<p>Incidentally, there’s something a bit more general going on here: for
a given nonempty weighted tree <span class="math inline">\(T\)</span>, a <em>max-edge decomposition</em> of
<span class="math inline">\(T\)</span> is a binary tree defined as follows:</p>
<ul>
<li>The max-edge decomposition of a trivial single-vertex tree is a
single vertex.</li>
<li>Otherwise, the max-edge decomposition of <span class="math inline">\(T\)</span> consists of a root node
with two children, which are the max-edge decompositions of the two
trees that result from deleting a largest-weight edge from <span class="math inline">\(T\)</span>.</li>
</ul>
<p>Any max-edge decomposition of a tree <span class="math inline">\(T\)</span> with <span class="math inline">\(n\)</span> vertices will have
<span class="math inline">\(n\)</span> leaf nodes and <span class="math inline">\(n-1\)</span> internal nodes. Typically we think of the
leaf nodes of the decomposition as being labelled by the vertices of
<span class="math inline">\(T\)</span>, and the internal nodes as being labelled by the edges of <span class="math inline">\(T\)</span>.</p>
<p>An alternative way to think of the max-edge decomposition is as the
binary tree of union operations performed by Kruskal’s algorithm while
building <span class="math inline">\(T\)</span>, starting with each vertex in a singleton leaf and then
merging two trees into one with every union operation. Thinking
about, or even explicitly building, this max-edge decomposition
occasionally comes in handy. For example, see
<a href="https://open.kattis.com/problems/vedur">Veður</a> and <a href="https://open.kattis.com/problems/tollroads">Toll
Roads</a>.</p>
<p>Incidentally, I can’t remember whether I got the term “max-edge
decomposition” from somewhere else or if I made it up myself; in any
case, regardless of what it is called, I think I first learned of it
from <a href="https://blog.mitrichev.ch/2022/02/an-alphaweek.html">this blog post by Petr
Mitrichev</a>.</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: Union-Find, part II" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 18 Nov 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/11/18/UnionFind-sols.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Union-Find</title>
    <link>http://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Union-Find</h1>

<div class="info">
  Posted on November  2, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;union-find&#39;." href="/tag/union-find.html" rel="tag">union-find</a>, <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>, <a title="All pages tagged &#39;haskell&#39;." href="/tag/haskell.html" rel="tag">haskell</a>
  
</div>

<section>
<section id="union-find" class="level2">
<h2>Union-find</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure"><em>union-find</em> data
structure</a>
(also known as a <em>disjoint set</em> data structure) keeps track of a
<em>collection of disjoint sets</em>, typically with elements drawn from
<span class="math inline">\(\{0, \dots, n-1\}\)</span>. For example, we might have the sets</p>
<p><span class="math inline">\(\{1,3\}, \{0, 4, 2\}, \{5, 6, 7\}\)</span></p>
<p>A union-find structure must support three basic operations:</p>
<ul>
<li><p>We can <span class="math inline">\(\mathit{create}\)</span> a union-find structure with <span class="math inline">\(n\)</span> singleton sets
<span class="math inline">\(\{0\}\)</span> through <span class="math inline">\(\{n-1\}\)</span>. (Alternatively, we could support two
operations: creating an empty union-find structure, and adding a new
singleton set; occasionally this more fine-grained approach is
useful, but we will stick with the simpler <span class="math inline">\(\mathit{create}\)</span> API for now.)</p></li>
<li><p>We can <span class="math inline">\(\mathit{find}\)</span> a given <span class="math inline">\(x \in \{0, \dots, n-1\}\)</span>, returning some sort
of “name” for the set <span class="math inline">\(x\)</span> is in. It doesn’t matter what these names
are; the only thing that matters is that for any <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>,
<span class="math inline">\(\mathit{find}(x) = \mathit{find}(y)\)</span> if and only if <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are in the same
set. The most important application of <span class="math inline">\(\mathit{find}\)</span> is therefore to check
whether two given elements are in the same set or not.</p></li>
<li><p>We can <span class="math inline">\(\mathit{union}\)</span> two elements, so the sets that contain them become
one set. For example, if we <span class="math inline">\(\mathit{union}(2,5)\)</span> then we would have</p>
<p><span class="math inline">\(\{1,3\}, \{0, 4, 2, 5, 6, 7\}\)</span></p></li>
</ul>
<p>Note that <span class="math inline">\(\mathit{union}\)</span> is a one-way operation: once two sets have been
unioned together, there’s no way to split them apart again. (If both
merging and splitting are required, one can use a <a href="https://en.wikipedia.org/wiki/Link/cut_tree">link/cut
tree</a>, which is very cool—and possibly something I will write
about in the future—but much more complex.) However, these three
operations are enough for union-find structures to have a large number
of interesting applications!</p>
<p>In addition, we can annotate each set with a value taken from some
commutative semigroup. When creating a new union-find structure, we
must specify the starting value for each singleton set; when unioning
two sets, we combine their annotations via the semigroup operation.</p>
<ul>
<li>For example, we could annotate each set with its <em>size</em>; singleton
sets always start out with size 1, and every time we union two sets
we add their sizes.</li>
<li>We could also annotate each set with the sum, product, maximum, or
minumum of all its elements.</li>
<li>Of course there are many more exotic examples as well.</li>
</ul>
<p>We typically use a commutative semigroup, as in the examples above;
this guarantees that a given set always has a single well-defined
annotation value, regardless of the sequence of union-find operations
that were used to create it. However, we can actually use any binary
operation at all (<em>i.e.</em> any <em>magma</em>), in which case the annotations
on a set may reflect the precise tree of calls to <span class="math inline">\(\mathit{union}\)</span> that were
used to construct it; this can occasionally be useful.</p>
<ul>
<li><p>For example, we could annotate each set with a list of values, and
combine annotations using list concatenation; the order of elements
in the list associated to a given set will depend on the order of
arguments to <span class="math inline">\(\mathit{union}\)</span>.</p></li>
<li><p>We could also annotate each set with a binary tree storing values at
the leaves. Each singleton set is annotated with a single leaf; to
combine two trees we create a new branch node with the two trees as
its children. Then each set ends up annotated with the precise tree
of calls to <span class="math inline">\(\mathit{union}\)</span> that were used to create it.</p></li>
</ul>
</section>
<section id="implementing-union-find" class="level2">
<h2>Implementing union-find</h2>
<p>My implementation is based on <a href="https://kseo.github.io/posts/2014-01-30-implementing-union-find-in-haskell.html">one by Kwang Yul
Seo</a>,
but I have modified it quite a bit. The code is <a href="https://github.com/byorgey/comprog-hs/blob/master/UnionFind.hs">also available in my
<code>comprog-hs</code>
repository</a>. This
blog post is not intended to be a comprehensive union-find tutorial,
but I will explain some things as we go.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">UnionFind</span> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array.ST</span></span></code></pre></div>
<p>Let’s start with the definition of the <code>UnionFind</code> type itself.
<code>UnionFind</code> has two type parameters: <code>s</code> is a phantom type parameter
used to limit the scope to a given <code>ST</code> computation; <code>m</code> is the type
of the arbitrary annotations. Note that the elements are also
sometimes called “nodes”, since, as we will see, they are organized
into trees.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UnionFind</span> s m <span class="ot">=</span> <span class="dt">UnionFind</span> {</span></code></pre></div>
<p>The basic idea is to maintain three mappings:</p>
<ul>
<li>First, each element is mapped to a <em>parent</em> (another element).
There are no cycles, except that some elements can be their own
parent. This means that the elements form a <em>forest</em> of rooted
trees, with the self-parenting elements as roots. We
store the parent mapping as an <code>STUArray</code> (<a href="https://byorgey.github.io/blog/posts/2021/11/17/competitive-programming-in-haskell-bfs-part-4-implementation-via-stuarray.html">see here</a> for another post where we used <code>STUArray</code>) for
efficiency.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  parent ::</span> <span class="op">!</span>(<span class="dt">STUArray</span> s <span class="dt">Node</span> <span class="dt">Node</span>),</span></code></pre></div>
<ul>
<li><p>Each element is also mapped to a <em>size</em>. We maintain the
invariant that for any element which is a root (<em>i.e.</em> any element
which is its own parent), we store the size of the tree rooted at
that element. The size associated to other, non-root elements
does not matter.</p>
<p>(Many implementations store the <em>height</em> of each tree instead of
the size, but it does not make much practical difference, and the
size seems more generally useful.)</p></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  sz ::</span> <span class="op">!</span>(<span class="dt">STUArray</span> s <span class="dt">Node</span> <span class="dt">Int</span>),</span></code></pre></div>
<ul>
<li>Finally, we map each element to a custom annotation value; again,
we only care about the annotation values for root nodes.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  ann ::</span> <span class="op">!</span>(<span class="dt">STArray</span> s <span class="dt">Node</span> m) }</span></code></pre></div>
<p>To <span class="math inline">\(\mathit{create}\)</span> a new union-find structure, we need a size and a
function mapping each element to an initial annotation value. Every
element starts as its own parent, with a size of 1. For convenience,
we can also make a variant of <code>createWith</code> that gives every element
the same constant annotation value.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">createWith ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Node</span> <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s m)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>createWith n m <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnionFind</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> newListArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) [<span class="dv">0</span> <span class="op">..</span> n <span class="op">-</span> <span class="dv">1</span>]    <span class="co">-- Every node is its own parent</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> newArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) <span class="dv">1</span>                   <span class="co">-- Every node has size 1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> newListArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) (<span class="fu">map</span> m [<span class="dv">0</span> <span class="op">..</span> n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">create ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s m)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>create n m <span class="ot">=</span> createWith n (<span class="fu">const</span> m)</span></code></pre></div>
<p>To perform a <span class="math inline">\(\mathit{find}\)</span> operation, we keep following <em>parent</em>
references up the tree until reaching a root. We can also do a cool
optimization known as <em>path compression</em>: after finding a
root, we can directly update the parent of every node along the path
we just traversed to be the root. This means <span class="math inline">\(\mathit{find}\)</span> can be very
efficient, since it tends to create trees that are extremely wide and
shallow.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">find ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Node</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>find uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> readArray parent x</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> p <span class="op">/=</span> x</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>      r <span class="ot">&lt;-</span> find uf p</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      writeArray parent x r</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> r</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">pure</span> x</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ot">connected ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Bool</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>connected uf x y <span class="ot">=</span> (<span class="op">==</span>) <span class="op">&lt;$&gt;</span> find uf x <span class="op">&lt;*&gt;</span> find uf y</span></code></pre></div>
<p>Finally, to implement <span class="math inline">\(\mathit{union}\)</span>, we find the roots of the given nodes;
if they are not the same we make the root with the smaller tree the
child of the other root, combining sizes and annotations as
appropriate.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">union ::</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>union uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x y <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> find uf y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  when (x <span class="op">/=</span> y) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    sx <span class="ot">&lt;-</span> readArray sz x</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    sy <span class="ot">&lt;-</span> readArray sz y</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    mx <span class="ot">&lt;-</span> readArray ann x</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    my <span class="ot">&lt;-</span> readArray ann y</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> sx <span class="op">&lt;</span> sy</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        writeArray parent x y</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        writeArray sz y (sx <span class="op">+</span> sy)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        writeArray ann y (mx <span class="op">&lt;&gt;</span> my)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        writeArray parent y x</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        writeArray sz x (sx <span class="op">+</span> sy)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        writeArray ann x (mx <span class="op">&lt;&gt;</span> my)</span></code></pre></div>
<p>Note the trick of writing <code>x &lt;- find uf x</code>: this looks kind of like an
imperative statement that updates the value of a mutable variable <code>x</code>,
but really it just makes a new variable <code>x</code> which shadows the old
one.</p>
<p>Finally, a few utility functions. First, one to get the size of
the set containing a given node:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>size uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  readArray sz x</span></code></pre></div>
<p>Also, we can provide functions to update and fetch the custom
annotation value associated to the set containing a given node.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateAnn ::</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>updateAnn uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  old <span class="ot">&lt;-</span> readArray ann x</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  writeArray ann x (old <span class="op">&lt;&gt;</span> m)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We could use modifyArray above, but the version of the standard library</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- installed on Kattis doesn&#39;t have it</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">getAnn ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s m</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>getAnn uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  readArray ann x</span></code></pre></div>
</section>
<section id="challenge" class="level2">
<h2>Challenge</h2>
<p>Here are a couple of problems I challenge you to solve for next time:</p>
<ul>
<li><a href="https://open.kattis.com/problems/andvag">Duck Journey</a></li>
<li><a href="https://open.kattis.com/problems/inventing">Inventing Test Data</a></li>
</ul>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: Union-Find" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Sat, 02 Nov 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>MonadRandom: major or minor version bump?</title>
    <link>http://byorgey.github.io/blog/posts/2024/10/14/MonadRandom-version-bump.html</link>
    <description><![CDATA[
<h1>MonadRandom: major or minor version bump?</h1>

<div class="info">
  Posted on October 14, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Hackage&#39;." href="/tag/Hackage.html" rel="tag">Hackage</a>, <a title="All pages tagged &#39;MonadRandom&#39;." href="/tag/MonadRandom.html" rel="tag">MonadRandom</a>, <a title="All pages tagged &#39;random&#39;." href="/tag/random.html" rel="tag">random</a>, <a title="All pages tagged &#39;version&#39;." href="/tag/version.html" rel="tag">version</a>, <a title="All pages tagged &#39;PVP&#39;." href="/tag/PVP.html" rel="tag">PVP</a>, <a title="All pages tagged &#39;haskell&#39;." href="/tag/haskell.html" rel="tag">haskell</a>, <a title="All pages tagged &#39;meta&#39;." href="/tag/meta.html" rel="tag">meta</a>
  
</div>

<section>
<p><strong>tl;dr</strong>: a fix to the <code>MonadRandom</code> package may cause <code>fromListMay</code>
and related functions to <em>extremely rarely</em> output different results than
they used to. This could only possibly affect anyone who is using
fixed seed(s) to generate random values and is depending on the
specific values being produced, <em>e.g.</em> a unit test where you use a
specific seed and test that you get a specific result. Do you think
this should be a major or minor version bump?</p>
<hr />
<section id="the-fix" class="level2">
<h2>The Fix</h2>
<p>Since 2013 I have been the maintainer of
<a href="https://hackage.haskell.org/package/MonadRandom"><code>MonadRandom</code></a>,
which defines a monad and monad transformer for generating random
values, along with a number of related utilities.</p>
<p>Recently, <a href="https://github.com/Flupp">Toni Dietze</a> pointed out <a href="https://github.com/byorgey/MonadRandom/issues/53">a rare
situation that could cause the <code>fromListMay</code> function to
crash</a> (as well as
the other functions which depend on it: <code>fromList</code>, <code>weighted</code>,
<code>weightedMay</code>, <code>uniform</code>, and <code>uniformMay</code>). This function is
supposed to draw a weighted random sample from a list of values
decorated with weights. I’m not going to explain the details of the
issue here; suffice it to say that it has to do with conversions
between <code>Rational</code> (the type of the weights) and <code>Double</code> (the type
that was being used internally for generating random numbers).</p>
<p>Even though this could only happen in rare and/or strange
circumstances, fixing it definitely seemed like the right thing to
do. After a bit of discussion, Toni came up with a good suggestion
for a fix: we should no longer use <code>Double</code> internally for generating
random numbers, but rather <code>Word64</code>, which avoids conversion and
rounding issues.</p>
<p>In fact, <code>Word64</code> is already used internally in the generation of
random <code>Double</code> values, so we can emulate the behavior of the <code>Double</code>
instance (which was <a href="https://github.com/byorgey/MonadRandom/issues/53#issuecomment-2294862625">slightly
tricky</a>
to figure out)
so that we make exactly the same random choices as before, but without
actually converting to <code>Double</code>.</p>
</section>
<section id="the-change" class="level2">
<h2>The Change</h2>
<p>…well, not <em>exactly</em> the same random choices as before, and therein
lies the rub! If <code>fromListMay</code> happens to pick a random value which
is extremely close to a boundary between choices, it’s possible that
the value will fall on one side of the boundary when using exact
calculations with <code>Word64</code> and <code>Rational</code>, whereas before it would
have fallen on the other side of the boundary after converting to
<code>Double</code> due to rounding. In other words, it will output the
same results <em>almost all the time</em>, but for a list of <span class="math inline">\(n\)</span> weighted
choices there is something like an <span class="math inline">\(n/2^{64}\)</span> chance (or less) that
any given random choice will be different from what it used to be. I
have never observed this happening in my tests, and indeed, I do not
expect to ever observe it! If we generated one billion random samples
per second continuously for a thousand years, we might expect to see
it happen once or twice. I am not even sure how to engineer a test
scenario to force it to happen, because we would have to pick an
initial PRNG seed that forces a certain <code>Word64</code> value to be
generated.</p>
</section>
<section id="to-pvp-or-not-to-pvp" class="level2">
<h2>To PVP or not to PVP?</h2>
<p>Technically, a function exported by <code>MonadRandom</code> has changed
behavior, so <a href="https://pvp.haskell.org/">according to the Haskell PVP
specification</a> this should be a major
version bump (<em>i.e.</em> <code>0.6</code> to <code>0.7</code>).<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Actually, I am not even
100% clear on this. <a href="https://pvp.haskell.org/#decision-tree">The decision
tree</a> on the PVP page says
that changing the <em>behavior</em> of an exported function necessitates a
major version bump; but the <a href="https://pvp.haskell.org/#version-numbers">actual
specification</a> does not
refer to <em>behavior</em> at all—as I read it, it is exclusively concerned
with API compatibility, <em>i.e.</em> whether things will still compile.<br />
<br />
</span></span> But
there seem to be some good arguments for doing just a minor version
bump (<em>i.e.</em> <code>0.6</code> to <code>0.6.1</code>).</p>
<ul>
<li><p>Arguments in favor of a minor version bump:</p>
<ul>
<li><p>A major version bump would cause a lot of (probably unnecessary)
breakage! <code>MonadRandom</code> has <a href="https://hackage.haskell.org/package/MonadRandom/reverse/verbose">149 direct reverse dependencies,
and about 3500 distinct transitive reverse
dependencies</a>. Forcing
all those packages to update their upper bound on <code>MonadRandom</code>
would be a lot of churn.</p></li>
<li><p>What exactly constitutes the “behavior” of a function to
generate random values? It depends on your point of view. If
we view the function as a pure mathematical function which
takes a PRNG state as input and produces some value as
output, then its behavior is defined precisely by which outputs
it returns for which input seeds, and its behavior has changed.
However, if we think of it in more effectful terms, we could say
its “behavior” is just to output random values according to a
certain distribution, in which case its behavior has <em>not</em>
changed.</p></li>
<li><p>It’s extremely unlikely that this change will cause any
breakage; moreover, <a href="https://mathstodon.xyz/@BoydStephenSmithJr@hachyderm.io/113250878388960212">as argued by Boyd Stephen Smith</a>, anyone who cares enough about
reproducibility to be relying on specific outputs for specific
seeds is probably already pinning all their package versions.</p></li>
</ul></li>
<li><p>Arguments in favor of a major version bump:</p>
<ul>
<li><p>It’s what the PVP specifies; what’s the point of having a
specification if we don’t follow it?</p></li>
<li><p>In the unlikely event that this change <em>does</em> cause any
breakage, it could be extremely difficult for package
maintainers to track down. If the behavior of a random
generation function completely changes, the source of the issue
is obvious. But if it only changes for very rare inputs, you
might reasonably think the problem is something else. A major
version bump will force maintainers to read the changelog for
<code>MonadRandom</code> and assess whether this is a change that could
possibly affect them.</p></li>
</ul></li>
</ul>
<p>So, do you have opinions on this? Would the release affect you one
way or the other? Feel free to leave a comment here, or send me an
email with your thoughts. Note there has already been <a href="https://mathstodon.xyz/@byorgey/113250843195905599">a bit of discussion on
Mastodon</a> as well.</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="MonadRandom: major or minor version bump?" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 14 Oct 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/10/14/MonadRandom-version-bump.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>

    </channel>
</rss>
