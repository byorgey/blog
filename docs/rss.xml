<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>blog :: Brent -> [String]</title>
        <link>http://byorgey.github.io/blog</link>
        <description><![CDATA[Brent Yorgey's academic blog]]></description>
        <atom:link href="http://byorgey.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 13 Mar 2025 00:00:00 UT</lastBuildDate>
        <item>
    <title>Hendrix College Programming Contest 2025</title>
    <link>http://byorgey.github.io/blog/posts/2025/03/13/HCPC25.html</link>
    <description><![CDATA[
<h1>Hendrix College Programming Contest 2025</h1>

<div class="info">
  Posted on March 13, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;competitive programming&#39;." href="/tag/competitive%20programming.html" rel="tag">competitive programming</a>, <a title="All pages tagged &#39;Hendrix&#39;." href="/tag/Hendrix.html" rel="tag">Hendrix</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;contest&#39;." href="/tag/contest.html" rel="tag">contest</a>, <a title="All pages tagged &#39;HCPC&#39;." href="/tag/HCPC.html" rel="tag">HCPC</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>I haven’t written on here in a while, mostly because a lot of my time
has gone into preparing for the second annual <a href="https://hendrix-cs.github.io/hcpc/">Hendrix College
Programming Contest</a>, which will
take place this <a href="https://www.timeanddate.com/worldclock/fixedtime.html?msg=Hendrix+College+Programming+Contest+2025&amp;iso=20250315T1230&amp;p1=134&amp;ah=5">Saturday, March 15, from 12:30-5:30pm CDT (17:30-22:30 UTC)</a>.</p>
<p>I’ve created an <a href="https://hcpc25.kattis.com/contests/vxtved">open mirror
contest</a> which will run in
parallel to the official contest, so if you want to grab some friends
and try solving some of the problems together using your favorite
language, be my guest!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Hendrix College Programming Contest 2025" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 13 Mar 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/03/13/HCPC25.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>You could have invented Fenwick trees</title>
    <link>http://byorgey.github.io/blog/posts/2025/01/23/Fenwick.html</link>
    <description><![CDATA[
<h1>You could have invented Fenwick trees</h1>

<div class="info">
  Posted on January 23, 2025
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;segment&#39;." href="/tag/segment.html" rel="tag">segment</a>, <a title="All pages tagged &#39;Fenwick&#39;." href="/tag/Fenwick.html" rel="tag">Fenwick</a>, <a title="All pages tagged &#39;tree&#39;." href="/tag/tree.html" rel="tag">tree</a>, <a title="All pages tagged &#39;JFP&#39;." href="/tag/JFP.html" rel="tag">JFP</a>, <a title="All pages tagged &#39;journal&#39;." href="/tag/journal.html" rel="tag">journal</a>, <a title="All pages tagged &#39;paper&#39;." href="/tag/paper.html" rel="tag">paper</a>
  
</div>

<section>
<p>My paper, <a href="http://ozark.hendrix.edu/~yorgey/pub/Fenwick-ext.pdf">You could have invented Fenwick
trees</a>, has just
been published as a <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/B4628279D4E54229CED97249E96F721D/S0956796824000169a.pdf/you-could-have-invented-fenwick-trees.pdf">Functional Pearl in the Journal of Functional
Programming</a>.
This blog post is an advertisement for the paper, which presents a
novel way to derive the <em>Fenwick tree</em> data structure from first
principles.</p>
<p>Suppose we have a sequence of integers <span class="math inline">\(a_1, \dots, a_n\)</span> and want to be
able to perform two operations:</p>
<ul>
<li>we can <em>update</em> any <span class="math inline">\(a_i\)</span> by adding some value <span class="math inline">\(v\)</span> to it; or</li>
<li>we can perform a <em>range query</em>, which asks for the sum of the values
<span class="math inline">\(a_i + \dots + a_j\)</span> for any range <span class="math inline">\([i,j]\)</span>.</li>
</ul>
<p>There are several ways to solve this problem. For example:</p>
<ol type="1">
<li>We could just keep the sequence of integers in a mutable array.
Updating is <span class="math inline">\(O(1)\)</span>, but range queries are <span class="math inline">\(O(n)\)</span> since we must
actually loop through the range and add up all the values.</li>
<li>We could keep a separate array of <em>prefix sums</em> on the side, so
that <span class="math inline">\(P_i\)</span> stores the sum <span class="math inline">\(a_1 + \dots + a_i\)</span>. Then the range
query on <span class="math inline">\([i,j]\)</span> can be computed as <span class="math inline">\(P_j - P_{i-1}\)</span>, which only
takes <span class="math inline">\(O(1)\)</span>; however, updates now take <span class="math inline">\(O(n)\)</span> since we must also
update all the prefix sums which include the updated element.</li>
<li>We can get the best of both worlds using a <em>segment tree</em>, a binary
tree storing the elements at the leaves, with each internal node
caching the sum of its children. Then both update and range query
can be done in <span class="math inline">\(O(\lg n)\)</span>.</li>
</ol>
<p>I won’t go through the details of this third solution here, but it is
relatively straightforward to understand and implement, especially in
a functional language.</p>
<p>However, there is a fourth solution, known as a <em>Fenwick tree</em> or
<em>Fenwick array</em>, independently invented by <span class="citation" data-cites="ryabko1989fast">Ryabko (1989)</span> and
<span class="citation" data-cites="fenwick1994new">Fenwick (1994)</span>. Here’s a typical Java implementation of a Fenwick
tree:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode .java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FenwickTree <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">long</span><span class="op">[]</span> a<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">FenwickTree</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> a <span class="op">=</span> <span class="kw">new</span> <span class="dt">long</span><span class="op">[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">prefix</span><span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">-=</span> <span class="fu">LSB</span><span class="op">(</span>i<span class="op">))</span> s <span class="op">+=</span> a<span class="op">[</span>i<span class="op">];</span> <span class="cf">return</span> s<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">update</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">long</span> delta<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> i <span class="op">&lt;</span> a<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i <span class="op">+=</span> <span class="fu">LSB</span><span class="op">(</span>i<span class="op">))</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> delta<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">range</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">prefix</span><span class="op">(</span>j<span class="op">)</span> <span class="op">-</span> <span class="fu">prefix</span><span class="op">(</span>i<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">get</span><span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="fu">range</span><span class="op">(</span>i<span class="op">,</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">set</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">long</span> v<span class="op">)</span> <span class="op">{</span> <span class="fu">update</span><span class="op">(</span>i<span class="op">,</span> v <span class="op">-</span> <span class="fu">get</span><span class="op">(</span>i<span class="op">));</span> <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">LSB</span><span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">&amp;</span> <span class="op">(-</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I know what you’re thinking: what the heck!? There are some loops adding and
subtracting <code>LSB(i)</code>, which is defined as the bitwise AND of <code>i</code> and
<code>-i</code>? What on earth is this doing? Unless you have seen this
before, this code is probably a complete mystery, as it was for me the
first time I encountered it.</p>
<p>However, from the right point of view, we can derive this mysterious imperative
code as an optimization of segment trees. In particular, in my
paper I show how we can:</p>
<ol type="1">
<li>Start with a segment tree.</li>
<li>Delete some redundant info from the segment tree, and shove the
remaining values into an array in a systematic way.</li>
<li>Define operations for moving around in the resulting Fenwick array by
converting array indices to indices in a segment tree, moving
around the tree appropriately, and converting back.</li>
<li>Describe these operations using a Haskell EDSL for
infinite-precision 2’s complement binary arithmetic, and fuse away
all the intermediate conversion steps, until the above mysterious
implementation pops out.</li>
<li>Profit.</li>
</ol>
<p>I may be exaggerating step 5 a teensy bit. But you’ll find everything
else described in much greater detail, with pretty pictures, in the
paper! The <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/you-could-have-invented-fenwick-trees/B4628279D4E54229CED97249E96F721D">official JFP version is here</a>, and here’s an <a href="http://ozark.hendrix.edu/~yorgey/pub/Fenwick-ext.pdf">extended
version with an appendix containing an omitted proof</a>.</p>
<section id="references" class="level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-fenwick1994new" class="csl-entry" role="listitem">
Fenwick, Peter M. 1994. <span>“A New Data Structure for Cumulative Frequency Tables.”</span> <em>Software: Practice and <span>E</span>xperience</em> 24 (3): 327–36.
</div>
<div id="ref-ryabko1989fast" class="csl-entry" role="listitem">
Ryabko, Boris Yakovlevich. 1989. <span>“A Fast on-Line Code.”</span> In <em>Doklady Akademii Nauk</em>, 306:548–52. 3. Russian Academy of Sciences.
</div>
</div>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="You could have invented Fenwick trees" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 23 Jan 2025 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2025/01/23/Fenwick.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: stacks, queues, and monoidal sliding windows</title>
    <link>http://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: stacks, queues, and monoidal sliding windows</h1>

<div class="info">
  Posted on November 27, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;stack&#39;." href="/tag/stack.html" rel="tag">stack</a>, <a title="All pages tagged &#39;queue&#39;." href="/tag/queue.html" rel="tag">queue</a>, <a title="All pages tagged &#39;sliding window&#39;." href="/tag/sliding%20window.html" rel="tag">sliding window</a>, <a title="All pages tagged &#39;monoid&#39;." href="/tag/monoid.html" rel="tag">monoid</a>
  
</div>

<section>
<p>Suppose we have a list of items of length <span class="math inline">\(n\)</span>, and we want to
consider <em>windows</em> (<em>i.e.</em> contiguous subsequences) of width <span class="math inline">\(w\)</span>
within the list.</p>
<p><span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">A list of numbers, with contiguous size-3 windows highlighted<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/84a9401ef1ac9137.svg" />
</figure>
<p>We can compute the <em>sum</em> of each window by brute
force in <span class="math inline">\(O(nw)\)</span> time, by simply generating the list of all the
windows and then summing each. But, of course, we can do better: keep
track of the sum of the current window; every time we slide the window
one element to the right we can add the new element that enters the
window on the right and subtract the element that falls of the window
to the left. Using this “sliding window” technique, we can compute the
sum of every window in only <span class="math inline">\(O(n)\)</span> total time instead of <span class="math inline">\(O(nw)\)</span>.</p>
<p>How about finding the <em>maximum</em> of every window? Of course the brute
force <span class="math inline">\(O(nw)\)</span> algorithm still works, but doing it in only <span class="math inline">\(O(n)\)</span> is
considerably trickier! We can’t use the same trick as we did for sums
since there’s no way to “subtract” the element falling off the left.
This really comes down to the fact that addition forms a <em>group</em>
(<em>i.e.</em> a monoid-with-inverses), but <code>max</code> does not. So more
generally, the question is: how can we compute a <em>monoidal</em> summary
for every window in only <span class="math inline">\(O(n)\)</span> time?</p>
<p>Today I want to show you how to solve this problem using one of my
favorite competitive programming tricks, which fits beautifully in a
functional context. Along the way we’ll also see how to implement
simple yet efficient functional queues.</p>
<section id="stacks" class="level2">
<h2>Stacks</h2>
<p>Before we get to queues, we need to take a detour through stacks.
Stacks in Haskell are pretty boring. We can just use a list, with the
front of the list corresponding to the top of the stack. However, to
make things more interesting—and because it will come in very handy
later—we’re going to implement <em>monoidally-annotated</em> stacks. Every
element on the stack will have a <em>measure</em>, which is a value from some
monoid <code>m</code>. We then want to be able to query any stack for the total
of all the measures in <span class="math inline">\(O(1)\)</span>. For example, perhaps we want to always
be able to find the sum or max of all the elements on a stack.</p>
<p>If we wanted to implement stacks annotated by a <em>group</em>, we could just
do something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GroupStack</span> g a <span class="ot">=</span> <span class="dt">GroupStack</span> (a <span class="ot">-&gt;</span> g) <span class="op">!</span>g [a]</span></code></pre></div>
<p>That is, a <code>GroupStack</code> stores a <em>measure function</em>, which assigns to
each element of type <code>a</code> a measure of type <code>g</code> (which is intended to
be a <code>Group</code>); a value of type <code>g</code> representing the sum (via the group
operation) of measures of all elements on the stack; and the actual
stack itself. To push, we would just compute the measure of the new element
and add it to the cached <code>g</code> value; to pop, we subtract the measure of
the element being popped, something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">push ::</span> a <span class="ot">-&gt;</span> <span class="dt">GroupStack</span> g a <span class="ot">-&gt;</span> <span class="dt">GroupStack</span> g a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>push a (<span class="dt">GroupStack</span> f g as) <span class="ot">=</span> <span class="dt">GroupStack</span> f (f a <span class="op">&lt;&gt;</span> g) (a<span class="op">:</span>as)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">GroupStack</span> g a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">GroupStack</span> g a)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>pop (<span class="dt">GroupStack</span> f g as) <span class="ot">=</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  (a<span class="op">:</span>as&#39;) <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, <span class="dt">GroupStack</span> f (inv (f a) <span class="op">&lt;&gt;</span> g) as&#39;)</span></code></pre></div>
<p>But this won’t work for a monoid, of course. The problem is <code>pop</code>, where
we can’t just subtract the measure for the element being
popped. Instead, we need to be able to <em>restore</em> the measure of a
previous stack. Hmmm… sounds like we might be able to use… a stack! We
could just store a stack of measures alongside the stack of elements;
even better is to store a stack of <em>pairs</em>. That is, each element on
the stack is paired with an annotation representing the sum of all the
measures at or below it. Here, then, is our representation of
monoidally-annotated stacks:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Stack</span> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stack</span> m a <span class="ot">=</span> <span class="dt">Stack</span> (a <span class="ot">-&gt;</span> m) <span class="op">!</span><span class="dt">Int</span> [(m, a)]</span></code></pre></div>
<p>A <code>Stack m a</code> stores three things:</p>
<ol type="1">
<li><p>A measure function of type <code>a -&gt; m</code>.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Incidentally, what if we want
to be able to specify an arbitrary measure for each element, and
even give different measures to the same element at different
times? Easy: just use <code>(m,a)</code> pairs as elements, and use <code>fst</code> as
the measure function.<br />
<br />
</span></span></p></li>
<li><p>An <code>Int</code> representing the size of the stack. This is not strictly
necessary, especially since one could always just use a monoidal
annotation to keep track of the size; but wanting the size is so
ubiquitous that it seems convenient to just include it as a special
case.</p></li>
<li><p>The aforementioned stack of (annotation, element) pairs.</p></li>
</ol>
<p>Note that we cannot write a <code>Functor</code> instance for <code>Stack m</code>, since
<code>a</code> occurs contravariantly in <code>(a -&gt; m)</code>. But this makes sense: if we
change all the <code>a</code> values, the cached measures would no longer be valid.</p>
<p>When creating a new, empty stack, we have to specify the measure
function; to get the measure of a stack, we just look up the measure
on top, or return <code>mempty</code> for an empty stack.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>new f <span class="ot">=</span> <span class="dt">Stack</span> f <span class="dv">0</span> []</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Stack</span> _ n _) <span class="ot">=</span> n</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">measure ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> m</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>measure (<span class="dt">Stack</span> _ _ as) <span class="ot">=</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="fu">mempty</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  (m, _) <span class="op">:</span> _ <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>Now let’s implement <code>push</code> and <code>pop</code>. Both are relatively
straightforward.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">push ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>push a s<span class="op">@</span>(<span class="dt">Stack</span> f n as) <span class="ot">=</span> <span class="dt">Stack</span> f (n <span class="op">+</span> <span class="dv">1</span>) ((f a <span class="op">&lt;&gt;</span> measure s, a) <span class="op">:</span> as)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Stack</span> m a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>pop (<span class="dt">Stack</span> f n as) <span class="ot">=</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  (_, a) <span class="op">:</span> as&#39; <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, <span class="dt">Stack</span> f (n <span class="op">-</span> <span class="dv">1</span>) as&#39;)</span></code></pre></div>
<p>Note that if we care about using <em>non-commutative</em> monoids,
in the implementation of <code>push</code> we have a choice to make between <code>f a &lt;&gt; measure s</code> and <code>measure s &lt;&gt; f a</code>. The former seems nicer to me,
since it keeps the measures “in the same order” as the list
representing the stack. For example, if we push a list of elements
onto a stack via <code>foldr</code>, using the measure function <code>(:[])</code> that injects
each element into the monoid of lists, the resulting <code>measure</code> is just
the original list:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>measure <span class="op">.</span> <span class="fu">foldr</span> push (new (<span class="op">:</span>[])) <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>And more generally, for any measure function <code>f</code>, we have</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>measure <span class="op">.</span> <span class="fu">foldr</span> push (new f) <span class="op">==</span> <span class="fu">foldMap</span> f</span></code></pre></div>
<p>Finally, we are going to want a function to <em>reverse</em> a stack, which
is a one-liner:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Stack</span> m a <span class="ot">-&gt;</span> <span class="dt">Stack</span> m a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> (<span class="dt">Stack</span> f _ as) <span class="ot">=</span> foldl&#39; (<span class="fu">flip</span> push) (new f) (<span class="fu">map</span> <span class="fu">snd</span> as)</span></code></pre></div>
<p>That is, to reverse a stack, we extract the elements and then use
<code>foldl'</code> to push the elements one at a time onto a new stack using the
same measure function.</p>
<p>There is a <a href="https://github.com/byorgey/comprog-hs/blob/master/Stack.hs">bit more code you can find on
GitHub</a>,
such as <code>Show</code> and <code>Eq</code> instances.</p>
</section>
<section id="queues" class="level2">
<h2>Queues</h2>
<p>Now that we have monoidally-annotated stacks under our belt, let’s
turn to queues. And here’s where my favorite trick is revealed: we
can implement a queue out of two stacks, so that enqueue and dequeue
run in <span class="math inline">\(O(1)\)</span> amortized time; and if we use monoidally-annotated
stacks, we get monoidally-annotated queues for free!</p>
<p>First, some imports.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Queue</span> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (second)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Stack</span> (<span class="dt">Stack</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Stack</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">Stack</span></span></code></pre></div>
<p>A <code>Queue m a</code> just consists of two stacks, one for the front and one
for the back. To create a <code>new</code> queue, we just create two new stacks;
to get the <code>size</code> of a queue, we just add the sizes of the stacks; to
get the <code>measure</code> of a queue, we just combine the measures of the
stacks. Easy peasy.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CommutativeMonoid</span> <span class="ot">=</span> <span class="dt">Monoid</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Queue</span> m a <span class="ot">=</span> <span class="dt">Queue</span> {<span class="ot">getFront ::</span> <span class="dt">Stack</span> m a,<span class="ot"> getBack ::</span> <span class="dt">Stack</span> m a}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>new f <span class="ot">=</span> <span class="dt">Queue</span> (Stack.new f) (Stack.new f)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Queue</span> front back) <span class="ot">=</span> Stack.size front <span class="op">+</span> Stack.size back</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">measure ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> m</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>measure (<span class="dt">Queue</span> front back) <span class="ot">=</span> Stack.measure front <span class="op">&lt;&gt;</span> Stack.measure back</span></code></pre></div>
<p>Note the restriction to <em>commutative</em> monoids, since the queue
elements are stored in different orders in the front and back stacks.
If we really cared about making this work with non-commutative
monoids, we would have to make two different <code>push</code> methods for the
front and back stacks, to combine the measures in opposite orders.
That just doesn’t seem worth it. But if you have a good example
requiring the use of a queue annotated by a non-commutative monoid,
I’d love to hear it!</p>
<p>Now, to <code>enqueue</code>, we just push the new element on the back:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">enqueue ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>enqueue a (<span class="dt">Queue</span> front back) <span class="ot">=</span> <span class="dt">Queue</span> front (Stack.push a back)</span></code></pre></div>
<p>Dequeueing is the magic bit that makes everything work. If there are
any elements in the front stack, we can just pop from there.
Otherwise, we need to first reverse the back stack into the front
stack. This means <code>dequeue</code> may occasionally take <span class="math inline">\(O(n)\)</span> time, but it’s
still <span class="math inline">\(O(1)\)</span> amortized.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">The easiest way to see this is to note that
every element is touched exactly three times: once when it is pushed
on the back; once when it is transferred from the back to the front;
and once when it is popped from the front. So, overall, we do <span class="math inline">\(O(1)\)</span>
work per element.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dequeue ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Queue</span> m a)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>dequeue (<span class="dt">Queue</span> front back)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> Stack.size front <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> Stack.size back <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> Stack.size front <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> dequeue (<span class="dt">Queue</span> (Stack.reverse back) front)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> second (\front&#39; <span class="ot">-&gt;</span> <span class="dt">Queue</span> front&#39; back) <span class="op">&lt;$&gt;</span> Stack.pop</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  front</span></code></pre></div>
<p>Finally, for convenience, we can make a function <code>drop1</code> which just
dequeues an item from the front of a queue and throws it away.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">drop1 ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Queue</span> m a <span class="ot">-&gt;</span> <span class="dt">Queue</span> m a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>drop1 q <span class="ot">=</span> <span class="kw">case</span> dequeue q <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> q</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (_, q&#39;) <span class="ot">-&gt;</span> q&#39;</span></code></pre></div>
<p>This “banker’s queue” method of building a queue out of two stacks is
discussed in <em>Purely Functional Data Structures</em> by Okasaki, though I
don’t think he was the first to come up with the idea. It’s also
possible to use some clever tricks to <a href="https://www.hedonisticlearning.com/posts/global-rebuilding-coroutines-and-defunctionalization.html">make both <code>enqueue</code> and
<code>dequeue</code> take <span class="math inline">\(O(1)\)</span> time in the <em>worst</em>
case</a>.
In a future post I’d like to do some benchmarking to compare various
queue implementations (<em>i.e.</em> banker’s queues, <code>Data.Sequence</code>,
circular array queues built on top of <code>STArray</code>). At least
anecdotally, in solving some sliding window problems, banker’s queues
seem quite fast so far.</p>
</section>
<section id="sliding-windows" class="level2">
<h2>Sliding windows</h2>
<p>I hope you can see how this solves the initial motivating problem: to
find <em>e.g.</em> the max of a sliding window, we can just put the elements
in a monoidally-annotated queue, enqueueing and dequeueing one element
every time we slide the window over.<span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">More generally, of course, it
doesn’t even matter if the left and right ends of the window stay
exactly in sync; we can enqueue and dequeue as many times as we want.<br />
<br />
</span></span> The following <code>windows</code> function computes the monoidal sum <code>foldMap f window</code> for each window of width <span class="math inline">\(w\)</span>, in only <span class="math inline">\(O(n)\)</span> time
overall.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">windows ::</span> <span class="dt">CommutativeMonoid</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [m]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>windows w f as <span class="ot">=</span> go startQ rest</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  (start, rest) <span class="ot">=</span> <span class="fu">splitAt</span> w as</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  startQ <span class="ot">=</span> foldl&#39; (<span class="fu">flip</span> enqueue) (new f) start</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  go q as <span class="ot">=</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    measure q <span class="op">:</span> <span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      [] <span class="ot">-&gt;</span> []</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      a <span class="op">:</span> as <span class="ot">-&gt;</span> go (enqueue a (drop1 q)) as</span></code></pre></div>
<p>“But…maximum and minimum do not form monoids, only semigroups!”
I hear you cry. Well, we can just adjoin special positive or negative
infinity elements as needed, like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Max</span> a <span class="ot">=</span> <span class="dt">NegInf</span> <span class="op">|</span> <span class="dt">Max</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Max</span> a) <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NegInf</span> <span class="op">&lt;&gt;</span> a <span class="ot">=</span> a</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  a <span class="op">&lt;&gt;</span> <span class="dt">NegInf</span> <span class="ot">=</span> a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Max</span> a <span class="op">&lt;&gt;</span> <span class="dt">Max</span> b <span class="ot">=</span> <span class="dt">Max</span> (<span class="fu">max</span> a b)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Max</span> a) <span class="kw">where</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">NegInf</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Min</span> a <span class="ot">=</span> <span class="dt">Min</span> a <span class="op">|</span> <span class="dt">PosInf</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Min</span> a) <span class="kw">where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PosInf</span> <span class="op">&lt;&gt;</span> a <span class="ot">=</span> a</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  a <span class="op">&lt;&gt;</span> <span class="dt">PosInf</span> <span class="ot">=</span> a</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Min</span> a <span class="op">&lt;&gt;</span> <span class="dt">Min</span> b <span class="ot">=</span> <span class="dt">Min</span> (<span class="fu">min</span> a b)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Min</span> a) <span class="kw">where</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">PosInf</span></span></code></pre></div>
<p>Now we can write, for example, <code>windows 3 Max [1,4,2,8,9,4,4,6]</code> which
yields <code>[Max 4, Max 8, Max 9, Max 9, Max 9, Max 6]</code>, the maximums of
each 3-element window.</p>
</section>
<section id="challenges" class="level2">
<h2>Challenges</h2>
<p>If you’d like to try solving some problems using the techniques from this
blog post, I can recommend the following (generally in order of difficulty):</p>
<ul>
<li><a href="https://open.kattis.com/problems/tiredterry">Tired Terry</a></li>
<li><a href="https://open.kattis.com/problems/treeshopping">Tree Shopping</a></li>
<li><a href="https://open.kattis.com/problems/einvigi">Einvígi</a></li>
<li><a href="https://open.kattis.com/problems/hockeyfans">Hockey Fans</a></li>
</ul>
<p>In a future post I’ll walk through my solution to <a href="https://open.kattis.com/problems/hockeyfans">Hockey
Fans</a>. And here’s another
couple problems along similar lines; unlike the previous problems I am
not so sure how to solve these in a nice way. I may write about them
in the future.</p>
<ul>
<li><a href="https://open.kattis.com/problems/martiandna">Martian DNA</a></li>
<li><a href="https://open.kattis.com/problems/slidecount">Slide Count</a></li>
</ul>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: stacks, queues, and monoidal sliding windows" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Wed, 27 Nov 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Union-Find, part II</title>
    <link>http://byorgey.github.io/blog/posts/2024/11/18/UnionFind-sols.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Union-Find, part II</h1>

<div class="info">
  Posted on November 18, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;union-find&#39;." href="/tag/union-find.html" rel="tag">union-find</a>
  
</div>

<section>
<p>In my <a href="https://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html">previous
post</a>
I explained how to implement a reasonably efficient <em>union-find</em> data
structure in Haskell, and challenged you to solve a couple Kattis
problems. In this post, I will (1) touch on a few generalizations
brought up in the comments of my last post, (2) go over my solutions
to the two challenge problems, and (3) briefly discuss generalizing
the second problem’s solution to finding max-edge decompositions of
weighted trees.</p>
<section id="generalizations" class="level2">
<h2>Generalizations</h2>
<p>Before going on to explain my solutions to those problems, I want to
highlight some things from a <a href="https://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html#isso-1971">comment by Derek
Elkins</a>
and a related <a href="https://www.philipzucker.com/union-find-groupoid/">blog post by Philip
Zucker</a>. The first
is that instead of (or in addition to) annotating each set with a
value from a commutative semigroup, we can also annotate the <em>edges</em>
between nodes with elements from a
<a href="https://en.wikipedia.org/wiki/Group_(mathematics)">group</a> (or, more
generally, a <a href="https://en.wikipedia.org/wiki/Groupoid">groupoid</a>). The
idea is that each edge records some information about, or evidence
for, the <em>relationship</em> between the endpoints of the edge. To compute
information about the relationship between two arbitrary nodes in the
same set, we can compose elements along the path between them. This
is a nifty idea—I have never personally seen it used for a
competitive programming problem, but it probably has been at some
point. (It kind of makes me want to write such a problem!) And of
course it has “real” applications beyond competitive programming as
well. I have not actually generalized my union-find code to allow
edge annotations; I leave it as an exercise for the reader.</p>
<p>The other idea to highlight is that instead of thinking in terms of
<em>disjoint sets</em>, what we are really doing is building an <a href="https://www.jonmsterling.com/jms-00L3.xml"><em>equivalence
relation</em></a>, which
partitions the elements into disjoint equivalence classes. In
particular, we do this by incrementally building a relation <span class="math inline">\(R\)</span>, where
the union-find structure represents the reflexive, transitive,
symmetric closure of <span class="math inline">\(R\)</span>. We start with the empty relation <span class="math inline">\(R\)</span> (whose
reflexive, transitive, symmetric closure is the discrete equivalence
relation, with every element in its own equivalence class); every
<span class="math inline">\(\mathit{union}(x,y)\)</span> operation adds <span class="math inline">\((x,y)\)</span> to <span class="math inline">\(R\)</span>; and the <span class="math inline">\(\mathit{find}(x)\)</span>
operation computes a canonical representative of the equivalence class
of <span class="math inline">\(x\)</span>. In other words, given some facts about which things are
related to which other things (possibly along with some associated
evidence), the union-find structure keeps track of everything we can
infer from the given facts and the assumption that the relation is an
equivalence.</p>
<p>Finally, through the comments I also learned about other
potentially-faster-in-practice schemes for doing path compression such
as <a href="https://algocoding.wordpress.com/2015/05/13/simple-union-find-techniques/">Rem’s
Algorithm</a>;
I leave it for future me to try these out and see if they speed things up.</p>
<p>Now, on to the solutions!</p>
</section>
<section id="duck-journey" class="level2">
<h2>Duck Journey</h2>
<p>In <a href="https://open.kattis.com/problems/andvag">Duck Journey</a>, we are
essentially given a graph with edges labelled by bitstrings, where
edges along a path are combined using bitwise OR. We are then asked
to find the <em>greatest</em> possible value of a path between two given
vertices, assuming that we are allowed to retrace our steps as much as
we want.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Incidentally, if we are <em>not</em> allowed to retrace our steps,
this problem probably becomes NP-hard.<br />
<br />
</span></span> If we can retrace our steps,
then on our way from A to B we might as well visit every edge in the
entire connected component, so this problem is not really
about path-finding at all. It boils down to two things: (1) being
able to quickly test whether two given vertices are in the same
connected component or not, and (2) computing the bitwise OR of all
the edge labels in each connected component.</p>
<p>One way to solve this would be to first use some kind of graph
traversal, like DFS, to find the connected components and build a map
from vertices to component labels; then partition the edges by
component and take the bitwise OR of all the edge weights in each
component. To answer queries we could first look up the component
label of the two vertices; if the labels are the same then we look up
the total weight for that component.</p>
<p>This works, and is in some sense the most “elemantary” solution, but
it requires building some kind of graph data structure, storing all
the edges in memory, doing the component labelling via DFS and
building another map, and so on. An alternative solution is to use a
union-find structure with a bitstring annotation for each set: as we
read in the edges in the input, we simply union the endpoints of the
edge, and then update the bitstring for the resulting equivalence
class with the bitstring for the edge. If we take a union-find library
as given, this solution seems simpler to me.</p>
<p>First, some imports and the top-level <code>main</code> function. (<a href="https://github.com/byorgey/comprog-hs/blob/master/ScannerBS.hs">See here for the <code>ScannerBS</code> module</a>.)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bits</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> (<span class="dt">ByteString</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ScannerBS</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">UnionFind</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">UF</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner tc <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> format</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ot">format ::</span> [<span class="dt">Maybe</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>format <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">maybe</span> <span class="st">&quot;-1&quot;</span> (<span class="fu">show</span> <span class="op">&gt;&gt;&gt;</span> BS.pack)) <span class="op">&gt;&gt;&gt;</span> BS.unlines</span></code></pre></div>
<p>Next, some data types to represent the input, and a <code>Scanner</code> to read
it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Each edge is a &quot;filter&quot; represented as a bitstring stored as an Int.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Filter</span> <span class="ot">=</span> <span class="dt">Filter</span> <span class="dt">Int</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Filter</span> <span class="kw">where</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Filter</span> x <span class="op">&lt;&gt;</span> <span class="dt">Filter</span> y <span class="ot">=</span> <span class="dt">Filter</span> (x <span class="op">.|.</span> y)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">filterSize ::</span> <span class="dt">Filter</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>filterSize (<span class="dt">Filter</span> f) <span class="ot">=</span> popCount f</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Channel</span> <span class="ot">=</span> <span class="dt">Channel</span> <span class="dt">UF.Node</span> <span class="dt">UF.Node</span> <span class="dt">Filter</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot">n ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> channels ::</span> [<span class="dt">Channel</span>],<span class="ot"> queries ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]}</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> int</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  q <span class="ot">&lt;-</span> int</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  channels <span class="ot">&lt;-</span> m <span class="op">&gt;&lt;</span> (<span class="dt">Channel</span> <span class="op">&lt;$&gt;</span> int <span class="op">&lt;*&gt;</span> int <span class="op">&lt;*&gt;</span> (<span class="dt">Filter</span> <span class="op">&lt;$&gt;</span> int))</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  queries <span class="ot">&lt;-</span> q <span class="op">&gt;&lt;</span> pair int int</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span> {<span class="op">..</span>}</span></code></pre></div>
<p>Finally, here’s the solution itself: process each channel with a
union-find structure, then process queries. The annoying thing, of
course, is that this all has to be in the <code>ST</code> monad, but other than
that it’s quite straightforward.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">TC</span> <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> <span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>solve <span class="dt">TC</span> {<span class="op">..</span>} <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  uf <span class="ot">&lt;-</span> UF.new (n <span class="op">+</span> <span class="dv">1</span>) (<span class="dt">Filter</span> <span class="dv">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (addChannel uf) channels</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM</span> (answer uf) queries</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">addChannel ::</span> <span class="dt">UF.UnionFind</span> s <span class="dt">Filter</span> <span class="ot">-&gt;</span> <span class="dt">Channel</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>addChannel uf (<span class="dt">Channel</span> a b f) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  UF.union uf a b</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  UF.updateAnn uf a f</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">answer ::</span> <span class="dt">UF.UnionFind</span> s <span class="dt">Filter</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>answer uf (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> UF.connected uf a b</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> c <span class="kw">of</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">.</span> filterSize <span class="op">&lt;$&gt;</span> UF.getAnn uf a</span></code></pre></div>
</section>
<section id="inventing-test-data" class="level2">
<h2>Inventing Test Data</h2>
<p>In <a href="https://open.kattis.com/problems/inventing">Inventing Test Data</a>,
we are given a tree <span class="math inline">\(T\)</span> with integer weights on its edges, and asked
to find the minimum possible weight of a complete graph for which <span class="math inline">\(T\)</span>
is the unique <a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning
tree</a> (MST).</p>
<p><span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote"><img src="images/T-with-non-edge.png" /><br />
<br />
</span></span></p>
<p>Let <span class="math inline">\(e = (x,y)\)</span> be some edge which is not in <span class="math inline">\(T\)</span>. There must be a
unique path between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> in <span class="math inline">\(T\)</span> (so adding <span class="math inline">\(e\)</span> to <span class="math inline">\(T\)</span> would
complete a cycle); let <span class="math inline">\(m\)</span> be the maximum weight of the edges along
this path. Then I claim that we must give edge <span class="math inline">\(e\)</span> weight <span class="math inline">\(m+1\)</span>:</p>
<ul>
<li>On the one hand, this ensures <span class="math inline">\(e\)</span> can never be in any MST, since an
edge which is strictly the largest edge in some cycle can never be
part of an MST (this is often called the “cycle property”).</li>
<li>Conversely, if <span class="math inline">\(e\)</span> had a weight less than or equal to <span class="math inline">\(m\)</span>, then <span class="math inline">\(T\)</span>
would not be a MST (or at least not uniquely): we
could remove any edge in the path from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> through <span class="math inline">\(T\)</span> and
replace it with <span class="math inline">\(e\)</span>, resulting in a spanning tree with a lower (or
equal) weight.</li>
</ul>
<p>Hence, every edge not in <span class="math inline">\(T\)</span> must be given a weight one more than the
largest weight in the unique <span class="math inline">\(T\)</span>-path connecting its endpoints; these
are the minimum weights that ensure <span class="math inline">\(T\)</span> is a unique MST.</p>
</section>
<section id="a-false-start" class="level2">
<h2>A false start</h2>
<p>At first, I thought what we needed was a way to quickly compute this
max weight along any path in the tree (where by “quickly” I mean
something like “faster than linear in the length of the path”). There
are indeed ways to do this, for example, using a heavy-light
decomposition and then putting a data structure on each heavy path
that allows us to query subranges of the path quickly. (If we use a
segment tree on each path we can even support operations to <em>update</em>
the edge weights quickly.)</p>
<p>All this is fascinating, and something I
may very well write about later. But it doesn’t actually help! Even
if we could find the max weight along any path in <span class="math inline">\(O(1)\)</span>, there are
still <span class="math inline">\(O(V^2)\)</span> edges to loop over, which is too big. There can be up
to <span class="math inline">\(V = 15\,000\)</span> nodes in the tree, so <span class="math inline">\(V^2 = 2.25 \times 10^8\)</span>. A
good rule of thumb is <span class="math inline">\(10^8\)</span> operations per second, and there are
likely to be very high constant factors hiding in whatever complex
data structures we use to query paths efficiently.</p>
<p>So we need a way to somehow process many edges at once. As usual, a
change in perspective is helpful; to get there we first need to take a
slight detour.</p>
</section>
<section id="kruskals-algorithm" class="level2">
<h2>Kruskal’s Algorithm</h2>
<p>It helps to be familiar with <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal’s
Algorithm</a>, which
is the simplest algorithm I know for finding minimum spanning
trees:</p>
<ul>
<li>Sort the edges from smallest to biggest weight.</li>
<li>Initialize <span class="math inline">\(T\)</span> to an empty set of edges.</li>
<li>For each edge <span class="math inline">\(e\)</span> in order from smallest to biggest:
<ul>
<li>If <span class="math inline">\(e\)</span> does not complete a cycle with the other edges already in
<span class="math inline">\(T\)</span>, add <span class="math inline">\(e\)</span> to <span class="math inline">\(T\)</span>.</li>
</ul></li>
</ul>
<p>To efficiently check whether <span class="math inline">\(e\)</span> completes a cycle with the other
edges in <span class="math inline">\(T\)</span>, we can use a union-find, of course: we maintain
equivalence classes of vertices under the “is connected to”
equivalence relation; adding <span class="math inline">\(e\)</span> would complete a cycle if and only if
the endpoints of <span class="math inline">\(e\)</span> are already connected to each other in <span class="math inline">\(T\)</span>. If
we do add an edge <span class="math inline">\(e\)</span>, we can just <span class="math inline">\(\mathit{union}\)</span> its endpoints to properly
maintain the relation.</p>
</section>
<section id="a-change-of-perspective" class="level2">
<h2>A change of perspective</h2>
<p>So how does this help us solve “Inventing Test Data”? After all, we
are not being directly asked to find a minimum spanning tree.
However, it’s still helpful to think about the process Kruskal’s
Algorithm <em>would</em> go through, in order to choose edge weights that
will force it to do what we want (<em>i.e.</em> pick all the edges in <span class="math inline">\(T\)</span>).
That is, instead of thinking about each individual edge <em>not</em> in <span class="math inline">\(T\)</span>,
we can instead think about the edges that <em>are</em> in <span class="math inline">\(T\)</span>, and what must
be true to force Kruskal’s algorithm to pick each one.</p>
<p>Suppose we are part of the way through running Kruskal’s algorithm,
and that it is about to consider a given edge <span class="math inline">\(e = (x,y) \in T\)</span> which
has weight <span class="math inline">\(w_e\)</span>. At this point it has already considered any edges
with smaller weight, and (we shall assume) chosen all the
smaller-weight edges in <span class="math inline">\(T\)</span>. So let <span class="math inline">\(X\)</span> be the set of vertices
reachable from <span class="math inline">\(x\)</span> by edges in <span class="math inline">\(T\)</span> with weight less than or equal to
<span class="math inline">\(w_e\)</span>, and similarly let <span class="math inline">\(Y\)</span> be those reachable from <span class="math inline">\(y\)</span>. Kruskal’s
algorithm will pick edge <span class="math inline">\(e\)</span> after checking that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are
disjoint.</p>
<p><span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote"><img src="images/XY-edges.png" /><br />
<br />
</span></span></p>
<p>Think about all the <em>other</em> edges from <span class="math inline">\(X\)</span> to <span class="math inline">\(Y\)</span>: all of them must
have weight greater than <span class="math inline">\(w_e\)</span>, because otherwise Kruskal’s algorithm
would have already considered them earlier, and used one of them to
connect <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. In fact, <em>all</em> of these edges must have weight
<span class="math inline">\(w_e + 1\)</span>, as we argued earlier, since <span class="math inline">\(e\)</span> is the largest-weight edge
on the <span class="math inline">\(T\)</span>-path between their endpoints (all the other edges on these
paths were already chosen earlier and hence have smaller weight). The
number of such edges is just <span class="math inline">\(|X| |Y| - 1\)</span> (there is an edge for every
pair of vertices, but we do not want to count <span class="math inline">\(e\)</span> itself). Hence they
contribute a total of <span class="math inline">\((|X||Y| - 1)(w_e + 1)\)</span> to the sum of edge
weights.</p>
<p>Hopefully the solution is now becoming clear: we process the edges of
<span class="math inline">\(T\)</span> in order from smallest to biggest, using a union-find to keep
track equivalence classes of connected vertices so far. For each edge
<span class="math inline">\((x,y)\)</span> we look up the sizes of the equivalence classes of <span class="math inline">\(x\)</span> and
<span class="math inline">\(y\)</span>, add <span class="math inline">\((|X||Y| - 1)(w_e + 1)\)</span> to a running total, and union. This
accounts for all the edges not in <span class="math inline">\(T\)</span>; finally we must also add the
weights of the edges in <span class="math inline">\(T\)</span> themselves.</p>
<p>First some standard pragmas and imports, along with some data types
and a <code>Scanner</code> to parse the input. Note the custom <code>Ord</code> instance
for <code>Edge</code>, so we can sort edges by weight.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sort)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ord</span> (comparing)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ScannerBS</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">UnionFind</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">UF</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner (numberOf tc) <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (solve <span class="op">&gt;&gt;&gt;</span> <span class="fu">show</span> <span class="op">&gt;&gt;&gt;</span> BS.pack) <span class="op">&gt;&gt;&gt;</span> BS.unlines</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Edge</span> <span class="ot">=</span> <span class="dt">Edge</span> {<span class="ot">a ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> w ::</span> <span class="op">!</span><span class="dt">Integer</span>}</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Edge</span> <span class="kw">where</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> <span class="ot">=</span> comparing w</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot">n ::</span> <span class="op">!</span><span class="dt">Int</span>,<span class="ot"> edges ::</span> [<span class="dt">Edge</span>]}</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">&lt;-</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">&gt;&lt;</span> (<span class="dt">Edge</span> <span class="op">&lt;$&gt;</span> int <span class="op">&lt;*&gt;</span> int <span class="op">&lt;*&gt;</span> integer)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span> {<span class="op">..</span>}</span></code></pre></div>
<p>Finally, the (remarkably short) solution proper: we <code>sort</code> the edges
and process them from smallest to biggest; for each edge we update an
accumulator according to the formula discussed above. Since we’re
already tied to the <code>ST</code> monad anyway, we might as well keep the
accumulator in a mutable <code>STRef</code> cell.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">TC</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>solve <span class="dt">TC</span> {<span class="op">..</span>} <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  uf <span class="ot">&lt;-</span> UF.new (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  total <span class="ot">&lt;-</span> newSTRef (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Integer</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (processEdge uf total) (<span class="fu">sort</span> edges)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  readSTRef total</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ot">processEdge ::</span> <span class="dt">UF.UnionFind</span> s <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Edge</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>processEdge uf total (<span class="dt">Edge</span> a b w) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  modifySTRef&#39; total (<span class="op">+</span> w)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  sa <span class="ot">&lt;-</span> UF.size uf a</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  sb <span class="ot">&lt;-</span> UF.size uf b</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  modifySTRef&#39; total (<span class="op">+</span> (<span class="fu">fromIntegral</span> sa <span class="op">*</span> <span class="fu">fromIntegral</span> sb <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (w <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  UF.union uf a b</span></code></pre></div>
</section>
<section id="max-edge-decomposition" class="level2">
<h2>Max-edge decomposition</h2>
<p><span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="marginnote"><img src="images/max-edge-decomp.png" /><br />
<br />
</span></span></p>
<p>Incidentally, there’s something a bit more general going on here: for
a given nonempty weighted tree <span class="math inline">\(T\)</span>, a <em>max-edge decomposition</em> of
<span class="math inline">\(T\)</span> is a binary tree defined as follows:</p>
<ul>
<li>The max-edge decomposition of a trivial single-vertex tree is a
single vertex.</li>
<li>Otherwise, the max-edge decomposition of <span class="math inline">\(T\)</span> consists of a root node
with two children, which are the max-edge decompositions of the two
trees that result from deleting a largest-weight edge from <span class="math inline">\(T\)</span>.</li>
</ul>
<p>Any max-edge decomposition of a tree <span class="math inline">\(T\)</span> with <span class="math inline">\(n\)</span> vertices will have
<span class="math inline">\(n\)</span> leaf nodes and <span class="math inline">\(n-1\)</span> internal nodes. Typically we think of the
leaf nodes of the decomposition as being labelled by the vertices of
<span class="math inline">\(T\)</span>, and the internal nodes as being labelled by the edges of <span class="math inline">\(T\)</span>.</p>
<p>An alternative way to think of the max-edge decomposition is as the
binary tree of union operations performed by Kruskal’s algorithm while
building <span class="math inline">\(T\)</span>, starting with each vertex in a singleton leaf and then
merging two trees into one with every union operation. Thinking
about, or even explicitly building, this max-edge decomposition
occasionally comes in handy. For example, see
<a href="https://open.kattis.com/problems/vedur">Veður</a> and <a href="https://open.kattis.com/problems/tollroads">Toll
Roads</a>.</p>
<p>Incidentally, I can’t remember whether I got the term “max-edge
decomposition” from somewhere else or if I made it up myself; in any
case, regardless of what it is called, I think I first learned of it
from <a href="https://blog.mitrichev.ch/2022/02/an-alphaweek.html">this blog post by Petr
Mitrichev</a>.</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: Union-Find, part II" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 18 Nov 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/11/18/UnionFind-sols.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Union-Find</title>
    <link>http://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Union-Find</h1>

<div class="info">
  Posted on November  2, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;union-find&#39;." href="/tag/union-find.html" rel="tag">union-find</a>
  
</div>

<section>
<section id="union-find" class="level2">
<h2>Union-find</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure"><em>union-find</em> data
structure</a>
(also known as a <em>disjoint set</em> data structure) keeps track of a
<em>collection of disjoint sets</em>, typically with elements drawn from
<span class="math inline">\(\{0, \dots, n-1\}\)</span>. For example, we might have the sets</p>
<p><span class="math inline">\(\{1,3\}, \{0, 4, 2\}, \{5, 6, 7\}\)</span></p>
<p>A union-find structure must support three basic operations:</p>
<ul>
<li><p>We can <span class="math inline">\(\mathit{create}\)</span> a union-find structure with <span class="math inline">\(n\)</span> singleton sets
<span class="math inline">\(\{0\}\)</span> through <span class="math inline">\(\{n-1\}\)</span>. (Alternatively, we could support two
operations: creating an empty union-find structure, and adding a new
singleton set; occasionally this more fine-grained approach is
useful, but we will stick with the simpler <span class="math inline">\(\mathit{create}\)</span> API for now.)</p></li>
<li><p>We can <span class="math inline">\(\mathit{find}\)</span> a given <span class="math inline">\(x \in \{0, \dots, n-1\}\)</span>, returning some sort
of “name” for the set <span class="math inline">\(x\)</span> is in. It doesn’t matter what these names
are; the only thing that matters is that for any <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>,
<span class="math inline">\(\mathit{find}(x) = \mathit{find}(y)\)</span> if and only if <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are in the same
set. The most important application of <span class="math inline">\(\mathit{find}\)</span> is therefore to check
whether two given elements are in the same set or not.</p></li>
<li><p>We can <span class="math inline">\(\mathit{union}\)</span> two elements, so the sets that contain them become
one set. For example, if we <span class="math inline">\(\mathit{union}(2,5)\)</span> then we would have</p>
<p><span class="math inline">\(\{1,3\}, \{0, 4, 2, 5, 6, 7\}\)</span></p></li>
</ul>
<p>Note that <span class="math inline">\(\mathit{union}\)</span> is a one-way operation: once two sets have been
unioned together, there’s no way to split them apart again. (If both
merging and splitting are required, one can use a <a href="https://en.wikipedia.org/wiki/Link/cut_tree">link/cut
tree</a>, which is very cool—and possibly something I will write
about in the future—but much more complex.) However, these three
operations are enough for union-find structures to have a large number
of interesting applications!</p>
<p>In addition, we can annotate each set with a value taken from some
commutative semigroup. When creating a new union-find structure, we
must specify the starting value for each singleton set; when unioning
two sets, we combine their annotations via the semigroup operation.</p>
<ul>
<li>For example, we could annotate each set with its <em>size</em>; singleton
sets always start out with size 1, and every time we union two sets
we add their sizes.</li>
<li>We could also annotate each set with the sum, product, maximum, or
minumum of all its elements.</li>
<li>Of course there are many more exotic examples as well.</li>
</ul>
<p>We typically use a commutative semigroup, as in the examples above;
this guarantees that a given set always has a single well-defined
annotation value, regardless of the sequence of union-find operations
that were used to create it. However, we can actually use any binary
operation at all (<em>i.e.</em> any <em>magma</em>), in which case the annotations
on a set may reflect the precise tree of calls to <span class="math inline">\(\mathit{union}\)</span> that were
used to construct it; this can occasionally be useful.</p>
<ul>
<li><p>For example, we could annotate each set with a list of values, and
combine annotations using list concatenation; the order of elements
in the list associated to a given set will depend on the order of
arguments to <span class="math inline">\(\mathit{union}\)</span>.</p></li>
<li><p>We could also annotate each set with a binary tree storing values at
the leaves. Each singleton set is annotated with a single leaf; to
combine two trees we create a new branch node with the two trees as
its children. Then each set ends up annotated with the precise tree
of calls to <span class="math inline">\(\mathit{union}\)</span> that were used to create it.</p></li>
</ul>
</section>
<section id="implementing-union-find" class="level2">
<h2>Implementing union-find</h2>
<p>My implementation is based on <a href="https://kseo.github.io/posts/2014-01-30-implementing-union-find-in-haskell.html">one by Kwang Yul
Seo</a>,
but I have modified it quite a bit. The code is <a href="https://github.com/byorgey/comprog-hs/blob/master/UnionFind.hs">also available in my
<code>comprog-hs</code>
repository</a>. This
blog post is not intended to be a comprehensive union-find tutorial,
but I will explain some things as we go.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">UnionFind</span> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array.ST</span></span></code></pre></div>
<p>Let’s start with the definition of the <code>UnionFind</code> type itself.
<code>UnionFind</code> has two type parameters: <code>s</code> is a phantom type parameter
used to limit the scope to a given <code>ST</code> computation; <code>m</code> is the type
of the arbitrary annotations. Note that the elements are also
sometimes called “nodes”, since, as we will see, they are organized
into trees.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UnionFind</span> s m <span class="ot">=</span> <span class="dt">UnionFind</span> {</span></code></pre></div>
<p>The basic idea is to maintain three mappings:</p>
<ul>
<li>First, each element is mapped to a <em>parent</em> (another element).
There are no cycles, except that some elements can be their own
parent. This means that the elements form a <em>forest</em> of rooted
trees, with the self-parenting elements as roots. We
store the parent mapping as an <code>STUArray</code> (<a href="https://byorgey.github.io/blog/posts/2021/11/17/competitive-programming-in-haskell-bfs-part-4-implementation-via-stuarray.html">see here</a> for another post where we used <code>STUArray</code>) for
efficiency.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  parent ::</span> <span class="op">!</span>(<span class="dt">STUArray</span> s <span class="dt">Node</span> <span class="dt">Node</span>),</span></code></pre></div>
<ul>
<li><p>Each element is also mapped to a <em>size</em>. We maintain the
invariant that for any element which is a root (<em>i.e.</em> any element
which is its own parent), we store the size of the tree rooted at
that element. The size associated to other, non-root elements
does not matter.</p>
<p>(Many implementations store the <em>height</em> of each tree instead of
the size, but it does not make much practical difference, and the
size seems more generally useful.)</p></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  sz ::</span> <span class="op">!</span>(<span class="dt">STUArray</span> s <span class="dt">Node</span> <span class="dt">Int</span>),</span></code></pre></div>
<ul>
<li>Finally, we map each element to a custom annotation value; again,
we only care about the annotation values for root nodes.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  ann ::</span> <span class="op">!</span>(<span class="dt">STArray</span> s <span class="dt">Node</span> m) }</span></code></pre></div>
<p>To <span class="math inline">\(\mathit{create}\)</span> a new union-find structure, we need a size and a
function mapping each element to an initial annotation value. Every
element starts as its own parent, with a size of 1. For convenience,
we can also make a variant of <code>createWith</code> that gives every element
the same constant annotation value.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">createWith ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Node</span> <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s m)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>createWith n m <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnionFind</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> newListArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) [<span class="dv">0</span> <span class="op">..</span> n <span class="op">-</span> <span class="dv">1</span>]    <span class="co">-- Every node is its own parent</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> newArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) <span class="dv">1</span>                   <span class="co">-- Every node has size 1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> newListArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) (<span class="fu">map</span> m [<span class="dv">0</span> <span class="op">..</span> n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">create ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s m)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>create n m <span class="ot">=</span> createWith n (<span class="fu">const</span> m)</span></code></pre></div>
<p>To perform a <span class="math inline">\(\mathit{find}\)</span> operation, we keep following <em>parent</em>
references up the tree until reaching a root. We can also do a cool
optimization known as <em>path compression</em>: after finding a
root, we can directly update the parent of every node along the path
we just traversed to be the root. This means <span class="math inline">\(\mathit{find}\)</span> can be very
efficient, since it tends to create trees that are extremely wide and
shallow.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">find ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Node</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>find uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> readArray parent x</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> p <span class="op">/=</span> x</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>      r <span class="ot">&lt;-</span> find uf p</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      writeArray parent x r</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> r</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">pure</span> x</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ot">connected ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Bool</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>connected uf x y <span class="ot">=</span> (<span class="op">==</span>) <span class="op">&lt;$&gt;</span> find uf x <span class="op">&lt;*&gt;</span> find uf y</span></code></pre></div>
<p>Finally, to implement <span class="math inline">\(\mathit{union}\)</span>, we find the roots of the given nodes;
if they are not the same we make the root with the smaller tree the
child of the other root, combining sizes and annotations as
appropriate.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">union ::</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>union uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x y <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> find uf y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  when (x <span class="op">/=</span> y) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    sx <span class="ot">&lt;-</span> readArray sz x</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    sy <span class="ot">&lt;-</span> readArray sz y</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    mx <span class="ot">&lt;-</span> readArray ann x</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    my <span class="ot">&lt;-</span> readArray ann y</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> sx <span class="op">&lt;</span> sy</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        writeArray parent x y</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        writeArray sz y (sx <span class="op">+</span> sy)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        writeArray ann y (mx <span class="op">&lt;&gt;</span> my)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        writeArray parent y x</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        writeArray sz x (sx <span class="op">+</span> sy)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        writeArray ann x (mx <span class="op">&lt;&gt;</span> my)</span></code></pre></div>
<p>Note the trick of writing <code>x &lt;- find uf x</code>: this looks kind of like an
imperative statement that updates the value of a mutable variable <code>x</code>,
but really it just makes a new variable <code>x</code> which shadows the old
one.</p>
<p>Finally, a few utility functions. First, one to get the size of
the set containing a given node:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>size uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  readArray sz x</span></code></pre></div>
<p>Also, we can provide functions to update and fetch the custom
annotation value associated to the set containing a given node.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateAnn ::</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>updateAnn uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  old <span class="ot">&lt;-</span> readArray ann x</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  writeArray ann x (old <span class="op">&lt;&gt;</span> m)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We could use modifyArray above, but the version of the standard library</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- installed on Kattis doesn&#39;t have it</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">getAnn ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s m</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>getAnn uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  readArray ann x</span></code></pre></div>
</section>
<section id="challenge" class="level2">
<h2>Challenge</h2>
<p>Here are a couple of problems I challenge you to solve for next time:</p>
<ul>
<li><a href="https://open.kattis.com/problems/andvag">Duck Journey</a></li>
<li><a href="https://open.kattis.com/problems/inventing">Inventing Test Data</a></li>
</ul>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: Union-Find" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Sat, 02 Nov 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/11/02/UnionFind.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>MonadRandom: major or minor version bump?</title>
    <link>http://byorgey.github.io/blog/posts/2024/10/14/MonadRandom-version-bump.html</link>
    <description><![CDATA[
<h1>MonadRandom: major or minor version bump?</h1>

<div class="info">
  Posted on October 14, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Hackage&#39;." href="/tag/Hackage.html" rel="tag">Hackage</a>, <a title="All pages tagged &#39;MonadRandom&#39;." href="/tag/MonadRandom.html" rel="tag">MonadRandom</a>, <a title="All pages tagged &#39;random&#39;." href="/tag/random.html" rel="tag">random</a>, <a title="All pages tagged &#39;version&#39;." href="/tag/version.html" rel="tag">version</a>, <a title="All pages tagged &#39;PVP&#39;." href="/tag/PVP.html" rel="tag">PVP</a>
  
</div>

<section>
<p><strong>tl;dr</strong>: a fix to the <code>MonadRandom</code> package may cause <code>fromListMay</code>
and related functions to <em>extremely rarely</em> output different results than
they used to. This could only possibly affect anyone who is using
fixed seed(s) to generate random values and is depending on the
specific values being produced, <em>e.g.</em> a unit test where you use a
specific seed and test that you get a specific result. Do you think
this should be a major or minor version bump?</p>
<hr />
<section id="the-fix" class="level2">
<h2>The Fix</h2>
<p>Since 2013 I have been the maintainer of
<a href="https://hackage.haskell.org/package/MonadRandom"><code>MonadRandom</code></a>,
which defines a monad and monad transformer for generating random
values, along with a number of related utilities.</p>
<p>Recently, <a href="https://github.com/Flupp">Toni Dietze</a> pointed out <a href="https://github.com/byorgey/MonadRandom/issues/53">a rare
situation that could cause the <code>fromListMay</code> function to
crash</a> (as well as
the other functions which depend on it: <code>fromList</code>, <code>weighted</code>,
<code>weightedMay</code>, <code>uniform</code>, and <code>uniformMay</code>). This function is
supposed to draw a weighted random sample from a list of values
decorated with weights. I’m not going to explain the details of the
issue here; suffice it to say that it has to do with conversions
between <code>Rational</code> (the type of the weights) and <code>Double</code> (the type
that was being used internally for generating random numbers).</p>
<p>Even though this could only happen in rare and/or strange
circumstances, fixing it definitely seemed like the right thing to
do. After a bit of discussion, Toni came up with a good suggestion
for a fix: we should no longer use <code>Double</code> internally for generating
random numbers, but rather <code>Word64</code>, which avoids conversion and
rounding issues.</p>
<p>In fact, <code>Word64</code> is already used internally in the generation of
random <code>Double</code> values, so we can emulate the behavior of the <code>Double</code>
instance (which was <a href="https://github.com/byorgey/MonadRandom/issues/53#issuecomment-2294862625">slightly
tricky</a>
to figure out)
so that we make exactly the same random choices as before, but without
actually converting to <code>Double</code>.</p>
</section>
<section id="the-change" class="level2">
<h2>The Change</h2>
<p>…well, not <em>exactly</em> the same random choices as before, and therein
lies the rub! If <code>fromListMay</code> happens to pick a random value which
is extremely close to a boundary between choices, it’s possible that
the value will fall on one side of the boundary when using exact
calculations with <code>Word64</code> and <code>Rational</code>, whereas before it would
have fallen on the other side of the boundary after converting to
<code>Double</code> due to rounding. In other words, it will output the
same results <em>almost all the time</em>, but for a list of <span class="math inline">\(n\)</span> weighted
choices there is something like an <span class="math inline">\(n/2^{64}\)</span> chance (or less) that
any given random choice will be different from what it used to be. I
have never observed this happening in my tests, and indeed, I do not
expect to ever observe it! If we generated one billion random samples
per second continuously for a thousand years, we might expect to see
it happen once or twice. I am not even sure how to engineer a test
scenario to force it to happen, because we would have to pick an
initial PRNG seed that forces a certain <code>Word64</code> value to be
generated.</p>
</section>
<section id="to-pvp-or-not-to-pvp" class="level2">
<h2>To PVP or not to PVP?</h2>
<p>Technically, a function exported by <code>MonadRandom</code> has changed
behavior, so <a href="https://pvp.haskell.org/">according to the Haskell PVP
specification</a> this should be a major
version bump (<em>i.e.</em> <code>0.6</code> to <code>0.7</code>).<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Actually, I am not even
100% clear on this. <a href="https://pvp.haskell.org/#decision-tree">The decision
tree</a> on the PVP page says
that changing the <em>behavior</em> of an exported function necessitates a
major version bump; but the <a href="https://pvp.haskell.org/#version-numbers">actual
specification</a> does not
refer to <em>behavior</em> at all—as I read it, it is exclusively concerned
with API compatibility, <em>i.e.</em> whether things will still compile.<br />
<br />
</span></span> But
there seem to be some good arguments for doing just a minor version
bump (<em>i.e.</em> <code>0.6</code> to <code>0.6.1</code>).</p>
<ul>
<li><p>Arguments in favor of a minor version bump:</p>
<ul>
<li><p>A major version bump would cause a lot of (probably unnecessary)
breakage! <code>MonadRandom</code> has <a href="https://hackage.haskell.org/package/MonadRandom/reverse/verbose">149 direct reverse dependencies,
and about 3500 distinct transitive reverse
dependencies</a>. Forcing
all those packages to update their upper bound on <code>MonadRandom</code>
would be a lot of churn.</p></li>
<li><p>What exactly constitutes the “behavior” of a function to
generate random values? It depends on your point of view. If
we view the function as a pure mathematical function which
takes a PRNG state as input and produces some value as
output, then its behavior is defined precisely by which outputs
it returns for which input seeds, and its behavior has changed.
However, if we think of it in more effectful terms, we could say
its “behavior” is just to output random values according to a
certain distribution, in which case its behavior has <em>not</em>
changed.</p></li>
<li><p>It’s extremely unlikely that this change will cause any
breakage; moreover, <a href="https://mathstodon.xyz/@BoydStephenSmithJr@hachyderm.io/113250878388960212">as argued by Boyd Stephen Smith</a>, anyone who cares enough about
reproducibility to be relying on specific outputs for specific
seeds is probably already pinning all their package versions.</p></li>
</ul></li>
<li><p>Arguments in favor of a major version bump:</p>
<ul>
<li><p>It’s what the PVP specifies; what’s the point of having a
specification if we don’t follow it?</p></li>
<li><p>In the unlikely event that this change <em>does</em> cause any
breakage, it could be extremely difficult for package
maintainers to track down. If the behavior of a random
generation function completely changes, the source of the issue
is obvious. But if it only changes for very rare inputs, you
might reasonably think the problem is something else. A major
version bump will force maintainers to read the changelog for
<code>MonadRandom</code> and assess whether this is a change that could
possibly affect them.</p></li>
</ul></li>
</ul>
<p>So, do you have opinions on this? Would the release affect you one
way or the other? Feel free to leave a comment here, or send me an
email with your thoughts. Note there has already been <a href="https://mathstodon.xyz/@byorgey/113250843195905599">a bit of discussion on
Mastodon</a> as well.</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="MonadRandom: major or minor version bump?" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 14 Oct 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/10/14/MonadRandom-version-bump.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Retiring BlogLiterately</title>
    <link>http://byorgey.github.io/blog/posts/2024/10/01/BlogLiterately-unmaintained.html</link>
    <description><![CDATA[
<h1>Retiring BlogLiterately</h1>

<div class="info">
  Posted on October  1, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;blog&#39;." href="/tag/blog.html" rel="tag">blog</a>, <a title="All pages tagged &#39;Hackage&#39;." href="/tag/Hackage.html" rel="tag">Hackage</a>, <a title="All pages tagged &#39;Wordpress&#39;." href="/tag/Wordpress.html" rel="tag">Wordpress</a>, <a title="All pages tagged &#39;open-source&#39;." href="/tag/open-source.html" rel="tag">open-source</a>, <a title="All pages tagged &#39;BlogLiterately&#39;." href="/tag/BlogLiterately.html" rel="tag">BlogLiterately</a>, <a title="All pages tagged &#39;HaXml&#39;." href="/tag/HaXml.html" rel="tag">HaXml</a>, <a title="All pages tagged &#39;haxr&#39;." href="/tag/haxr.html" rel="tag">haxr</a>
  
</div>

<section>
<p>Way back in 2012 I took over maintainership of the <a href="https://hackage.haskell.org/package/BlogLiterately"><code>BlogLiterately</code>
tool</a> from Robert
Greayer, its initial author. I used it for many years to post to my
Wordpress blog, added a
<a href="https://byorgey.github.io/blog/posts/2012/07/07/blogliterately-0-5-release.html">bunch</a>
of
<a href="https://byorgey.github.io/blog/posts/2013/03/10/blogliterately-0-6-2.html">features</a>,
solved some <a href="https://byorgey.github.io/blog/posts/2012/07/07/new-haxr-release.html">fun
bugs</a>,
and created the accompanying <a href="https://hackage.haskell.org/package/BlogLiterately-diagrams"><code>BlogLiterately-diagrams</code>
plugin</a>
for embedding <a href="https://diagrams.github.io/">diagrams</a> code in blog
posts. However, now that I have fled Wordpress and rebuilt my blog
with <a href="https://jaspervdj.be/hakyll/">hakyll</a>, I don’t use
<code>BlogLiterately</code> any more (there is even a <code>diagrams-pandoc</code> package
which does the same thing <code>BlogLiterately-diagrams</code> used to do). So,
as of today I am officially declaring <code>BlogLiterately</code> unsupported.</p>
<p>The fact is, I haven’t actually updated <code>BlogLiterately</code> since March
of last year. It currently only builds on GHC 9.4 or older, and no one
has complained, which I take as strong evidence that no one else is
using it either! However, if anyone out there is actually using it,
and would like to take over as maintainer, I would be very happy to
pass it along to you.</p>
<p>I do plan to continue maintaining
<a href="https://hackage.haskell.org/package/HaXml"><code>HaXml</code></a> and
<a href="https://hackage.haskell.org/package/haxr"><code>haxr</code></a>, at least for now;
unlike <code>BlogLiterately</code>, I know they are still in use, especially
<code>HaXml</code>. However, <code>BlogLiterately</code> was really the only reason I cared
about these packages personally, so I would be happy to pass them
along as well; please get in touch if you would be willing to take
over maintaining one or both packages.</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Retiring BlogLiterately" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 01 Oct 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/10/01/BlogLiterately-unmaintained.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Decidable equality for indexed data types</title>
    <link>http://byorgey.github.io/blog/posts/2024/09/09/OneLevelTypesIndexed.lagda.html</link>
    <description><![CDATA[
<h1>Decidable equality for indexed data types</h1>

<div class="info">
  Posted on September  9, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;agda&#39;." href="/tag/agda.html" rel="tag">agda</a>, <a title="All pages tagged &#39;equality&#39;." href="/tag/equality.html" rel="tag">equality</a>, <a title="All pages tagged &#39;indexed&#39;." href="/tag/indexed.html" rel="tag">indexed</a>
  
</div>

<section>
<p>Recently, as part of a larger project, I wanted to define decidable
equality for an indexed data type in Agda. I struggled quite a bit to
figure out the right way to encode it to make Agda happy, and wasn’t
able to find much help online, so I’m recording the results here.</p>
<p>The <strong>tl;dr</strong> is to use mutual recursion to define the indexed data
type along with a sigma type that hides the index, and to use the
sigma type in any recursive positions where we don’t care about the
index! Read on for more motivation and details (and wrong turns I
took along the way).</p>
<p>This post is literate Agda; you can <a href="https://github.com/byorgey/blog/blob/main/posts/2024/09/09/OneLevelTypesIndexed.lagda.md">download it here</a> if you want to play along. I tested everything here with Agda version 2.6.4.3 and version 2.0 of the standard library.</p>
<section id="background" class="level2">
<h2>Background</h2>
<p>First, some imports and a module declaration. Note that the entire
development is parameterized by some abstract set <code>B</code> of base types,
which must have decidable equality.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Product <span class="kw">using</span> <span class="ot">(</span>Σ <span class="ot">;</span> <span class="ot">_</span>×<span class="ot">_</span> <span class="ot">;</span> <span class="ot">_</span>,<span class="ot">_</span> <span class="ot">;</span> -,<span class="ot">_</span> <span class="ot">;</span> proj₁ <span class="ot">;</span> proj₂<span class="ot">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Product<span class="ot">.</span>Properties <span class="kw">using</span> <span class="ot">(</span>≡-dec<span class="ot">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Function <span class="kw">using</span> <span class="ot">(_</span>∘<span class="ot">_)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary <span class="kw">using</span> <span class="ot">(</span>DecidableEquality<span class="ot">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary<span class="ot">.</span>PropositionalEquality <span class="kw">using</span> <span class="ot">(_</span>≡<span class="ot">_</span> <span class="ot">;</span> refl<span class="ot">)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Nullary<span class="ot">.</span>Decidable <span class="kw">using</span> <span class="ot">(</span>yes<span class="ot">;</span> no<span class="ot">;</span> Dec<span class="ot">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> OneLevelTypesIndexed <span class="ot">(</span>B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>≟B <span class="ot">:</span> DecidableEquality B<span class="ot">)</span> <span class="kw">where</span></span></code></pre></div>
<p>We’ll work with a simple type system containing base types, function
types, and some distinguished type constructor □. So far, this is
just to give some context; it is not the final version of the code we
will end up with, so we stick it in a local module so it won’t end up
in the top-level namespace.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Unindexed <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">:</span> B <span class="ot">→</span> Ty</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> Ty <span class="ot">→</span> Ty <span class="ot">→</span> Ty</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    □<span class="ot">_</span> <span class="ot">:</span> Ty <span class="ot">→</span> Ty</span></code></pre></div>
<p>For example, if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are base types, then we could write down a
type like <span class="math inline">\(\square ((\square \square X \to Y) \to \square Y)\)</span>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>⇒<span class="ot">_</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">infix</span> <span class="dv">30</span> □<span class="ot">_</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">postulate</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    BX BY <span class="ot">:</span> B</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">:</span> Ty</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">=</span> base BX</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  Y <span class="ot">:</span> Ty</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  Y <span class="ot">=</span> base BY</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  example <span class="ot">:</span> Ty</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  example <span class="ot">=</span> □ <span class="ot">((</span>□ □ X ⇒ Y<span class="ot">)</span> ⇒ □ Y<span class="ot">)</span></span></code></pre></div>
<p>However, for reasons that would take us too far afield in this blog
post, I <em>don’t</em> want to allow immediately nested boxes, like <span class="math inline">\(\square \square X\)</span>. We can still have multiple boxes in a type, and even
boxes nested inside of other boxes, as long as there is at least one
arrow in between. In other words, I only want to rule out boxes
immediately applied to another type with an outermost box. So we
don’t want to allow the example type given above (since it contains
<span class="math inline">\(\square \square X\)</span>), but, for example, <span class="math inline">\(\square ((\square X \to Y) \to \square Y)\)</span> would be OK.</p>
</section>
<section id="encoding-invariants" class="level2">
<h2>Encoding invariants</h2>
<p>How can we encode this invariant so it holds by construction? One way
would be to have two mutually recursive data types, like so:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Mutual <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> UTy <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    □<span class="ot">_</span> <span class="ot">:</span> UTy <span class="ot">→</span> Ty</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    ∙<span class="ot">_</span> <span class="ot">:</span> UTy <span class="ot">→</span> Ty</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> UTy <span class="kw">where</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">:</span> B <span class="ot">→</span> UTy</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> Ty <span class="ot">→</span> Ty <span class="ot">→</span> UTy</span></code></pre></div>
<p><code>UTy</code> consists of types which have no top-level box; the constructors
of <code>Ty</code> just inject <code>UTy</code> into <code>Ty</code> by adding either one or zero
boxes. This works, and defining decidable equality for <code>Ty</code> and <code>UTy</code>
is relatively straightforward (again by mutual recursion). However,
it seemed to me that having to deal with <code>Ty</code> and <code>UTy</code> everywhere
through the rest of the development was probably going to be super
annoying.</p>
<p>The other option would be to index <code>Ty</code> by values indicating whether a
type has zero or one top-level boxes; then we can use the indices to
enforce the appropriate rules. First, we define a data type <code>Boxity</code>
to act as the index for <code>Ty</code>, and show that it has decidable equality:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Boxity <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  [0] <span class="ot">:</span> Boxity</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  [1] <span class="ot">:</span> Boxity</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>Boxity-≟ <span class="ot">:</span> DecidableEquality Boxity</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [0] [0] <span class="ot">=</span> yes refl</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [0] [1] <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [1] [0] <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [1] [1] <span class="ot">=</span> yes refl</span></code></pre></div>
<p>My first attempt to write down a version of <code>Ty</code> indexed by <code>Boxity</code>
looked like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> IndexedTry1 <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="ot">:</span> Boxity <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">:</span> B <span class="ot">→</span> Ty [0]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>b₁ b₂ <span class="ot">:</span> Boxity<span class="ot">}</span> <span class="ot">→</span> Ty b₁ <span class="ot">→</span> Ty b₂ <span class="ot">→</span> Ty [0]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    □<span class="ot">_</span> <span class="ot">:</span> Ty [0] <span class="ot">→</span> Ty [1]</span></code></pre></div>
<p><code>base</code> always introduces a type with no top-level box; the <code>□</code>
constructor requires a type with no top-level box, and produces a type
with one (this is what ensures we cannot nest boxes); and the arrow
constructor does not care how many boxes its arguments have, but
constructs a type with no top-level box.</p>
<p>This is logically correct, but I found it very difficult to work with.
The sticking point for me was injectivity of the arrow constructor.
When defining decidable equality we need to prove lemmas that each of
the constructors are injective, but I was not even able to write down
the <em>type</em> of injectivity for <code>_⇒_</code>. We would want something like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>⇒<span class="op">-</span>inj <span class="op">:</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  {bσ₁ bσ₂ bτ₁ bτ₂ <span class="op">:</span> <span class="dt">Boxity</span>}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  {σ₁ <span class="op">:</span> <span class="dt">Ty</span> bσ₁} {σ₂ <span class="op">:</span> <span class="dt">Ty</span> bσ₂} {τ₁ <span class="op">:</span> <span class="dt">Ty</span> bτ₁} {τ₂ <span class="op">:</span> <span class="dt">Ty</span> bτ₂} →</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  (σ₁ ⇒ σ₂) ≡ (τ₁ ⇒ τ₂) →</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  (σ₁ ≡ τ₁) × (σ₂ ≡ τ₂)</span></code></pre></div>
<p>but this does not even typecheck! The problem is that, for example,
<code>σ₁</code> and <code>τ₁</code> have different types, so the equality proposition <code>σ₁ ≡ τ₁</code> is not well-typed.</p>
<p>At this point I tried turning to <a href="https://agda.github.io/agda-stdlib/experimental/Relation.Binary.HeterogeneousEquality.html">heterogeneous
equality</a>,
but it didn’t seem to help. I won’t record here all the things I
tried, but the same issues seemed to persist, just pushed around to
different places (for example, I was not able to pattern-match on
witnesses of heterogeneous equality because of types that didn’t
match).</p>
</section>
<section id="sigma-types-to-the-rescue" class="level2">
<h2>Sigma types to the rescue</h2>
<p>At ICFP last week I asked <a href="https://jesper.sikanda.be/">Jesper Cockx</a>
for advice,<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">which felt a bit like asking Rory McIlroy to give some
tips on your mini-golf game<br />
<br />
</span></span> and he suggested trying to prove
decidable equality for the sigma type pairing an index with a type
having that index, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  ΣTy <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  ΣTy <span class="ot">=</span> Σ Boxity Ty</span></code></pre></div>
<p>This turned out to be the key idea, but it still took me a long time
to figure out the right way to make it work. Given the above
definitions, if we go ahead and try to define decidable equality for
<code>ΣTy</code>, injectivity of the arrow constructor is still a problem.</p>
<p>After days of banging my head against this off and on, I finally
realized that the way to solve this is to define <code>Ty</code> and <code>ΣTy</code> by
mutual recursion: the arrow constructor should just take two <code>ΣTy</code>
arguments! This perfectly captures the idea that we <em>don’t care</em>
about the indices of the arrow constructor’s argument types, so we
hide them by bundling them up in a sigma type.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ΣTy <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Ty <span class="ot">:</span> Boxity <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>ΣTy <span class="ot">=</span> Σ Boxity Ty</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Ty <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  □<span class="ot">_</span> <span class="ot">:</span> Ty [0] <span class="ot">→</span> Ty [1]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  base <span class="ot">:</span> B <span class="ot">→</span> Ty [0]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> ΣTy <span class="ot">→</span> ΣTy <span class="ot">→</span> Ty [0]</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>⇒<span class="ot">_</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">30</span> □<span class="ot">_</span></span></code></pre></div>
<p>Now we’re cooking! We now make quick work of the required injectivity
lemmas, which all go through trivially by matching on <code>refl</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>□-inj <span class="ot">:</span> <span class="ot">{</span>τ₁ τ₂ <span class="ot">:</span> Ty [0]<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>□ τ₁ ≡ □ τ₂<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>τ₁ ≡ τ₂<span class="ot">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>□-inj refl <span class="ot">=</span> refl</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>base-inj <span class="ot">:</span> <span class="ot">{</span>b₁ b₂ <span class="ot">:</span> B<span class="ot">}</span> <span class="ot">→</span> base b₁ ≡ base b₂ <span class="ot">→</span> b₁ ≡ b₂</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>base-inj refl <span class="ot">=</span> refl</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>⇒-inj <span class="ot">:</span> <span class="ot">{</span>σ₁ σ₂ τ₁ τ₂ <span class="ot">:</span> ΣTy<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>σ₁ ⇒ σ₂<span class="ot">)</span> ≡ <span class="ot">(</span>τ₁ ⇒ τ₂<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>σ₁ ≡ τ₁<span class="ot">)</span> × <span class="ot">(</span>σ₂ ≡ τ₂<span class="ot">)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>⇒-inj refl <span class="ot">=</span> refl , refl</span></code></pre></div>
<p>Notice how the type of <code>⇒-inj</code> is now perfectly fine: we just have a
bunch of <code>ΣTy</code> values that hide their indices, so we can talk about
propositional equality between them with no trouble.</p>
<p>Finally, we can define decidable equality for <code>Ty</code> and <code>ΣTy</code> by mutual
recursion.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ΣTy-≟ <span class="ot">:</span> DecidableEquality ΣTy</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">{-# TERMINATING #-}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> DecidableEquality <span class="ot">(</span>Ty b<span class="ot">)</span></span></code></pre></div>
<p>Sadly, I had to reassure Agda that the definition of <code>Ty-≟</code> is terminating—more on this later.</p>
<p>To define <code>ΣTy-≟</code> we can just use a lemma from
<code>Data.Product.Properties</code> which derives decidable equality for a sigma
type from decidable equality for both components.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ΣTy-≟ <span class="ot">=</span> ≡-dec Boxity-≟ Ty-≟</span></code></pre></div>
<p>The only thing left is to define decidable equality for any two values
of type <code>Ty b</code> (given a specific boxity <code>b</code>), making use of our
injectivity lemmas; now that we have the right definitions, this falls
out straightforwardly.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>□ σ<span class="ot">)</span> <span class="ot">(</span>□ τ<span class="ot">)</span> <span class="kw">with</span> Ty-≟ σ τ</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> no σ≢τ <span class="ot">=</span> no <span class="ot">(</span>σ≢τ ∘ □-inj<span class="ot">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes refl <span class="ot">=</span> yes refl</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>base x<span class="ot">)</span> <span class="ot">(</span>base y<span class="ot">)</span> <span class="kw">with</span> ≟B x y</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> no x≢y <span class="ot">=</span> no <span class="ot">(</span>x≢y ∘ base-inj<span class="ot">)</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes refl <span class="ot">=</span> yes refl</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>σ₁ ⇒ σ₂<span class="ot">)</span> <span class="ot">(</span>τ₁ ⇒ τ₂<span class="ot">)</span> <span class="kw">with</span> ΣTy-≟ σ₁ τ₁ <span class="ot">|</span> ΣTy-≟ σ₂ τ₂</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> no σ₁≢τ₁ <span class="ot">|</span> <span class="ot">_</span> <span class="ot">=</span> no <span class="ot">(</span>σ₁≢τ₁ ∘ proj₁ ∘ ⇒-inj<span class="ot">)</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes <span class="ot">_</span> <span class="ot">|</span> no σ₂≢τ₂ <span class="ot">=</span> no <span class="ot">(</span>σ₂≢τ₂ ∘ proj₂ ∘ ⇒-inj<span class="ot">)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes refl <span class="ot">|</span> yes refl <span class="ot">=</span> yes refl</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>base <span class="ot">_)</span> <span class="ot">(_</span> ⇒ <span class="ot">_)</span> <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(_</span> ⇒ <span class="ot">_)</span> <span class="ot">(</span>base <span class="ot">_)</span> <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span></code></pre></div>
</section>
<section id="final-thoughts" class="level2">
<h2>Final thoughts</h2>
<p>First, the one remaining infelicity is that Agda could not tell that
<code>Ty-≟</code> is terminating. I am not entirely sure why, but I think it may
be that the way the recursion works is just too convoluted for it to
analyze properly: <code>Ty-≟</code> calls <code>ΣTy-≟</code> on structural subterms of its
inputs, but then <code>ΣTy-≟</code> works by providing <code>Ty-≟</code> <em>as a higher-order
parameter</em> to <code>≡-dec</code>. If you look at the definition of <code>≡-dec</code>, all
it does is call its function parameters on structural subterms of its
input, so everything should be nicely terminating, but I guess I am
not surprised that Agda is not able to figure this out. If anyone has
suggestions on how to make this pass the termination checker without
using a <code>TERMINATING</code> pragma, I would love to hear it!</p>
<p>As a final aside, I note that converting back and forth between <code>Ty</code>
(with <code>ΣTy</code> arguments to the arrow constructor) and <code>IndexedTry1.Ty</code>
(with expanded-out <code>Boxity</code> and <code>Ty</code> arguments to arrow) is trivial:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">:</span> <span class="ot">{</span>b <span class="ot">:</span> Boxity<span class="ot">}</span> <span class="ot">→</span> Ty b <span class="ot">→</span> IndexedTry1<span class="ot">.</span>Ty b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">(</span>□ σ<span class="ot">)</span> <span class="ot">=</span> IndexedTry1<span class="ot">.</span>□ <span class="ot">(</span>Ty→Ty1 σ<span class="ot">)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">(</span>base x<span class="ot">)</span> <span class="ot">=</span> IndexedTry1<span class="ot">.</span>base x</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">((</span>b₁ , σ₁<span class="ot">)</span> ⇒ <span class="ot">(</span>b₂ , σ₂<span class="ot">))</span> <span class="ot">=</span> <span class="ot">(</span>Ty→Ty1 σ₁<span class="ot">)</span> IndexedTry1<span class="ot">.</span>⇒ <span class="ot">(</span>Ty→Ty1 σ₂<span class="ot">)</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">:</span> <span class="ot">{</span>b <span class="ot">:</span> Boxity<span class="ot">}</span> <span class="ot">→</span> IndexedTry1<span class="ot">.</span>Ty b <span class="ot">→</span> Ty b</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">(</span>IndexedTry1<span class="ot">.</span>base x<span class="ot">)</span> <span class="ot">=</span> base x</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">(</span>σ₁ IndexedTry1<span class="ot">.</span>⇒ σ₂<span class="ot">)</span> <span class="ot">=</span> -, <span class="ot">(</span>Ty1→Ty σ₁<span class="ot">)</span> ⇒ -, <span class="ot">(</span>Ty1→Ty σ₂<span class="ot">)</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">(</span>IndexedTry1<span class="ot">.</span>□ σ<span class="ot">)</span> <span class="ot">=</span> □ <span class="ot">(</span>Ty1→Ty σ<span class="ot">)</span></span></code></pre></div>
<p>I expect it is also trivial to prove this is an isomorphism, though
I’m not particularly motivated to do it. The point is that, as anyone
who has spent any time proving things with proof assistants knows, two
types can be completely isomorphic, and yet one can be vastly easier
to work with than the other in certain contexts. Often when I’m
trying to prove something in Agda it feels like at least half the
battle is just coming up with the right representation that makes the
proofs go through easily.</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Decidable equality for indexed data types" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 09 Sep 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/09/09/OneLevelTypesIndexed.lagda.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: tree path decomposition, part II</title>
    <link>http://byorgey.github.io/blog/posts/2024/08/08/TreeDecomposition.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: tree path decomposition, part II</h1>

<div class="info">
  Posted on August  8, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;tree&#39;." href="/tag/tree.html" rel="tag">tree</a>, <a title="All pages tagged &#39;path&#39;." href="/tag/path.html" rel="tag">path</a>, <a title="All pages tagged &#39;decomposition&#39;." href="/tag/decomposition.html" rel="tag">decomposition</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">a previous
post</a>
I discussed the first half of my solution to <a href="https://open.kattis.com/problems/factorfulltree">Factor-Full
Tree</a>. In this post,
I will demonstrate how to <em>decompose a tree into disjoint paths</em>.
<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Technically, we should clarify that we are looking for <em>directed</em>
paths in a rooted tree, that is, paths that only proceed down the
tree. One could also ask about decomposing an unrooted tree into
disjoint undirected paths; I haven’t thought about how to do that in
general but intuitively I expect it is not too much more difficult.<br />
<br />
</span></span> For
this particular problem, we want to decompose a tree into
<em>maximum-length</em> paths (<em>i.e.</em> we start by taking the longest possible
path, then take the longest path from what remains, and so on); I will call
this the <em>max-chain decomposition</em> (I don’t know if there is a
standard term). However, there are other types of path
decomposition, such as heavy-light decomposition, so we will try to
keep the decomposition code somewhat generic.</p>
<section id="preliminaries" class="level2">
<h2>Preliminaries</h2>
<p>This post is literate Haskell; you can <a href="https://github.com/byorgey/blog/blob/main/posts/2024/08/08/TreeDecomposition.lhs">find the source code on GitHub</a>.
We begin with some language pragmas and imports.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">TreeDecomposition</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;), (***))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (second)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> (<span class="dt">ByteString</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">NE</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>, (!), (!?))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ord</span> (<span class="dt">Down</span>(..), comparing)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tree</span> (<span class="dt">Tree</span>(..), foldTree)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> (swap)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ScannerBS</span></span></code></pre></div>
<p><a href="https://github.com/byorgey/comprog-hs/blob/master/ScannerBS.hs">See here for the <code>ScannerBS</code> module</a>.</p>
</section>
<section id="generic-path-decomposition" class="level2">
<h2>Generic path decomposition</h2>
<p>Remember, our goal is to split up a tree into a collection of linear
paths; that is, in general, something like this:</p>
<figure>
<img src="/diagrams/0ff41d66358cc1f5.svg" />
</figure>
<p>What do we need in order to specify a decomposition of a
tree into disjoint paths this way? Really, all we need is to choose <em>at most
one linked child</em> for each node. In other words, at every node we can
choose to continue the current path into a single child node (in which
case all the other children will start their own new paths), or we
could choose to terminate the current path (in which case every child
will be the start of its own new path). We can represent such a
choice with a function of type</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SubtreeSelector</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, [<span class="dt">Tree</span> a])</span></code></pre></div>
<p>which takes as input the value at a node and the list of all the
subtrees, and possibly returns a selected subtree along with the list of remaining
subtrees.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">Of course, there is nothing in the
type that actually requires a <code>SubtreeSelector</code> to return one of the
trees from its input paired with the rest, but nothing we will do
depends on this being true. In fact, I expect there may be some
interesting algorithms obtainable by running a “path decomposition”
with a “selector” function that actually makes up new trees instead of just
selecting one, similar to <a href="https://hackage.haskell.org/package/split-0.2.5/docs/Data-List-Split.html#v:chop">the <code>chop</code> function</a>.<br />
<br />
</span></span></p>
<p>Given such a subtree selection function, a generic path decomposition
function will then take a tree and turn it into a list of non-empty
paths:<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote">We could also imagine wanting information about the parent of each
path, and a mapping from tree nodes to some kind of path ID, but we
will keep things simple for now.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pathDecomposition ::</span> <span class="dt">SubtreeSelector</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">NonEmpty</span> a]</span></code></pre></div>
<p>Implementing <code>pathDecomposition</code> is a nice exercise; you might like to
try it yourself! You can find my implementation at the end of this
blog post.</p>
</section>
<section id="max-chain-decomposition" class="level2">
<h2>Max-chain decomposition</h2>
<p>Now, let’s use our generic path decomposition to implement a max-chain
decomposition. At each node we want to select the <em>tallest</em> subtree;
in order to do this efficiently, we can first annotate each tree node with
its height, via a straightforward <a href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Tree.html#v:foldTree">tree fold</a>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Height</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">labelHeight ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Height</span>, a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>labelHeight <span class="ot">=</span> foldTree node</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  node a ts <span class="ot">=</span> <span class="kw">case</span> ts <span class="kw">of</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">0</span>, a) []</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">maximum</span> (<span class="fu">map</span> (<span class="fu">fst</span> <span class="op">.</span> rootLabel) ts), a) ts</span></code></pre></div>
<p>Our subtree selection function can now select the subtree with the
largest <code>Height</code> annotation. Instead of implementing this directly,
we might as well make a generic function for selecting the “best”
element from a list (we will reuse it later):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">selectMaxBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [a])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>selectMaxBy _ [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>selectMaxBy cmp (a <span class="op">:</span> as) <span class="ot">=</span> <span class="kw">case</span> selectMaxBy cmp as <span class="kw">of</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, [])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (b, bs) <span class="ot">-&gt;</span> <span class="kw">case</span> cmp a b <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (b, a <span class="op">:</span> bs)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, b <span class="op">:</span> bs)</span></code></pre></div>
<p>We can now put the pieces together to implement max-chain
decomposition. We first label the tree by height, then do a path
decomposition that selects the tallest subtree at each node. We leave
the height annotations in the final output since they might be
useful—for example, we can tell how long each path is just by
looking at the <code>Height</code> annotation on the first element. If we don’t
need them we can easily get rid of them later. We also sort by
descending <code>Height</code>, since getting the longest chains first was kind
of the whole point.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maxChainDecomposition ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">NonEmpty</span> (<span class="dt">Height</span>, a)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>maxChainDecomposition <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  labelHeight <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  pathDecomposition (<span class="fu">const</span> (selectMaxBy (comparing (<span class="fu">fst</span> <span class="op">.</span> rootLabel)))) <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  sortBy (comparing (<span class="dt">Down</span> <span class="op">.</span> <span class="fu">fst</span> <span class="op">.</span> NE.head))</span></code></pre></div>
</section>
<section id="factor-full-tree-solution" class="level2">
<h2>Factor-full tree solution</h2>
<p>To flesh this out into a full solution to <a href="https://open.kattis.com/problems/factorfulltree">Factor-Full
Tree</a>, after
computing the chain decomposition we need to assign prime factors to
the chains. From those, we can compute the value for each node if we
know which chain it is in and the value of its parent. To this end,
we will need one more function which computes a <code>Map</code> recording the
parent of each node in a tree. Note that if we already know all the
edges in a given edge list are oriented the same way, we can build
this much more simply as <em>e.g.</em> <code>map swap &gt;&gt;&gt; M.fromList</code>; but when
(as in general) we don’t know which way the edges should be oriented
first, we might as well first build a <code>Tree a</code> via DFS with
<code>edgesToTree</code> and then construct the <code>parentMap</code> like this afterwards.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parentMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>parentMap <span class="ot">=</span> foldTree node <span class="op">&gt;&gt;&gt;</span> <span class="fu">snd</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  node ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [(a, <span class="dt">Map</span> a a)] <span class="ot">-&gt;</span> (a, <span class="dt">Map</span> a a)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  node a b <span class="ot">=</span> (a, M.fromList (<span class="fu">map</span> (,a) as) <span class="op">&lt;&gt;</span> <span class="fu">mconcat</span> ms)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    (as, ms) <span class="ot">=</span> <span class="fu">unzip</span> b</span></code></pre></div>
<p>Finally, we can solve Factor-Full tree. Note that some code from my
<a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">previous blog
post</a>
is needed as well, and is included at the end of the post for
completeness. Once we compute the max chain decomposition and the
prime factor for each node, we use a <a href="https://byorgey.github.io/blog/posts/2023/04/11/competitive-programming-in-haskell-topsort-via-laziness.html">lazy recursive
<code>Map</code></a>
to compute the value assigned to each node.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">TC</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>solve <span class="dt">TC</span>{<span class="op">..</span>} <span class="ot">=</span> M.elems assignment</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Build the tree and compute its parent map</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    t <span class="ot">=</span> edgesToTree <span class="dt">Node</span> edges <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    parent <span class="ot">=</span> parentMap t</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Compute the max chain decomposition, and use it to assign a prime factor</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- to each non-root node</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    paths ::</span> [[<span class="dt">Node</span>]]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    paths <span class="ot">=</span> <span class="fu">map</span> (NE.toList <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">snd</span>) <span class="op">$</span> maxChainDecomposition t</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    factor ::</span> <span class="dt">Map</span> <span class="dt">Node</span> <span class="dt">Int</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    factor <span class="ot">=</span> M.fromList <span class="op">.</span> <span class="fu">concat</span> <span class="op">$</span> <span class="fu">zipWith</span> (\p <span class="ot">-&gt;</span> <span class="fu">map</span> (,p)) primes paths</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Compute an assignment of each node to a value, using a lazy map</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    assignment ::</span> <span class="dt">Map</span> <span class="dt">Node</span> <span class="dt">Int</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    assignment <span class="ot">=</span> M.fromList <span class="op">$</span> (<span class="dv">1</span>,<span class="dv">1</span>) <span class="op">:</span> [(v, factor<span class="op">!</span>v <span class="op">*</span> assignment<span class="op">!</span>(parent<span class="op">!</span>v)) <span class="op">|</span> v <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="op">..</span>n]]</span></code></pre></div>
<p>For an explanation of this code for <code>primes</code>, see <a href="https://byorgey.github.io/blog/posts/2020/02/07/competitive-programming-in-haskell-primes-and-factoring.html">this old blog post</a>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Int</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span></code></pre></div>
</section>
<section id="bonus-heavy-light-decomposition" class="level2">
<h2>Bonus: heavy-light decomposition</h2>
<p>We can easily use our generic path decomposition to compute a <a href="https://cp-algorithms.com/graph/hld.html">heavy-light
decomposition</a> as well:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Size</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">labelSize ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Size</span>, a)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>labelSize <span class="ot">=</span> foldTree <span class="op">$</span> \a ts <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">sum</span> (<span class="fu">map</span> (<span class="fu">fst</span> <span class="op">.</span> rootLabel) ts), a) ts</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">heavyLightDecomposition ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">NonEmpty</span> (<span class="dt">Size</span>, a)]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>heavyLightDecomposition <span class="ot">=</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  labelSize <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  pathDecomposition (<span class="fu">const</span> (selectMaxBy (comparing (<span class="fu">fst</span> <span class="op">.</span> rootLabel))))</span></code></pre></div>
<p>I plan to write about this in a future post.</p>
</section>
<section id="leftover-code" class="level2">
<h2>Leftover code</h2>
<p>Here’s my implementation of <code>pathDecomposition</code>; how did you do?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>pathDecomposition select <span class="ot">=</span> go</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  go <span class="ot">=</span> selectPath select <span class="op">&gt;&gt;&gt;</span> second (<span class="fu">concatMap</span> go) <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> (<span class="op">:</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">selectPath ::</span> <span class="dt">SubtreeSelector</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (<span class="dt">NonEmpty</span> a, [<span class="dt">Tree</span> a])</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>selectPath select <span class="ot">=</span> go</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  go (<span class="dt">Node</span> a ts) <span class="ot">=</span> <span class="kw">case</span> select a ts <span class="kw">of</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (NE.singleton a, ts)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> (t, ts&#39;) <span class="ot">-&gt;</span> ((a <span class="op">NE.&lt;|</span>) <span class="op">***</span> (ts&#39; <span class="op">++</span>)) (go t)</span></code></pre></div>
<p>We also include some input parsing and tree-building code from <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">last time</a>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner tc <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">show</span> <span class="op">&gt;&gt;&gt;</span> BS.pack) <span class="op">&gt;&gt;&gt;</span> BS.unwords</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot"> n ::</span> <span class="dt">Int</span>,<span class="ot"> edges ::</span> [(<span class="dt">Node</span>, <span class="dt">Node</span>)] }</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">&lt;-</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">&gt;&lt;</span> pair int int</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span>{<span class="op">..</span>}</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>edgesToMap <span class="ot">=</span> <span class="fu">concatMap</span> (\p <span class="ot">-&gt;</span> [p, swap p]) <span class="op">&gt;&gt;&gt;</span> dirEdgesToMap</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="ot">dirEdgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>dirEdgesToMap <span class="ot">=</span> <span class="fu">map</span> (second (<span class="op">:</span> [])) <span class="op">&gt;&gt;&gt;</span> M.fromListWith (<span class="op">++</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="ot">mapToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>mapToTree nd m root <span class="ot">=</span> dfs root root</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>  dfs parent root <span class="ot">=</span> nd root (<span class="fu">maybe</span> [] (<span class="fu">map</span> (dfs root) <span class="op">.</span> <span class="fu">filter</span> (<span class="op">/=</span> parent)) (m <span class="op">!?</span> root))</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [(a, a)] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>edgesToTree nd <span class="ot">=</span> mapToTree nd <span class="op">.</span> edgesToMap</span></code></pre></div>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: tree path decomposition, part II" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 08 Aug 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/08/08/TreeDecomposition.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Help me attend ICFP in Milan!</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/20/ko-fi-help-me-attend-icfp.html</link>
    <description><![CDATA[
<h1>Help me attend ICFP in Milan!</h1>

<div class="info">
  Posted on July 20, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;community&#39;." href="/tag/community.html" rel="tag">community</a>, <a title="All pages tagged &#39;contribution&#39;." href="/tag/contribution.html" rel="tag">contribution</a>, <a title="All pages tagged &#39;ICFP&#39;." href="/tag/ICFP.html" rel="tag">ICFP</a>, <a title="All pages tagged &#39;ko-fi&#39;." href="/tag/ko-fi.html" rel="tag">ko-fi</a>, <a title="All pages tagged &#39;open-source&#39;." href="/tag/open-source.html" rel="tag">open-source</a>, <a title="All pages tagged &#39;tips&#39;." href="/tag/tips.html" rel="tag">tips</a>
  
</div>

<section>
<p><strong>tl;dr</strong>: if you appreciate my past or ongoing contributions to the
Haskell community, please consider helping me get to ICFP this year by <a href="https://ko-fi.com/byorgey">donating
via my ko-fi page</a>!</p>
<p><a href="https://ko-fi.com/I3I5KYUQX"><img src="https://ko-fi.com/img/githubbutton_sm.svg" alt="ko-fi" /></a></p>
<p>Working at a <a href="https://www.hendrix.edu/">small liberal arts institution</a>
has some tremendous benefits (close interaction with motivated students,
freedom to pursue the projects I want rather than jump through a bunch
of hoops to get tenure, fantastic colleagues), and I love my job. But
there are also downsides; the biggest ones for me are the difficulty of
securing enough travel funding, and, relatedly, the difficulty of
cultivating and maintaining collaborations.</p>
<p><a href="https://byorgey.github.io/blog/posts/2023/05/22/new-ko-fi-page-help-me-attend-icfp.html">Last
year</a>
I was very grateful for people’s generosity in helping me get to
Seattle. I am planning to again attend <a href="https://icfp24.sigplan.org/">ICFP in Milan this
September</a>; this time I will even bring
some students along. I have once again secured some funding from my
institution, but it will not be enough to cover all the expenses.</p>
<p>So, if you have been positively impacted by my
contributions to the Haskell community (<em>e.g.</em> <a href="https://www.cis.upenn.edu/~cis1940/spring13/">CIS
194</a>, the
<a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>,
<a href="https://diagrams.github.io/">diagrams</a>,
<a href="https://hackage.haskell.org/package/split">split</a>,
<a href="https://hackage.haskell.org/package/MonadRandom">MonadRandom</a>, <a href="https://byorgey.github.io/blog/posts/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy.html">burrito
metaphors</a>…)
and/or would like to support my ongoing work (<a href="https://byorgey.github.io/blog/tag/Kattis.html">competitive programming
in
Haskell</a>,
<a href="https://github.com/swarm-game/swarm/#readme">swarm</a>,
<a href="https://github.com/disco-lang/disco/#readme">disco</a>, <a href="https://hackage.haskell.org/user/BrentYorgey">ongoing package
maintenance</a>…), and are
able to express that appreciation or support with a <a href="https://ko-fi.com/byorgey">donation of any
size</a> to help me get to ICFP, I would really appreciate it!</p>
<p>Thank you, friends — I hope to see many people in Milan! Next up:
I will soon publish another post about <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">tree path decomposition</a>!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Help me attend ICFP in Milan!" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Sat, 20 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/20/ko-fi-help-me-attend-icfp.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>

    </channel>
</rss>
