<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>blog :: Brent -> [String]</title>
        <link>http://byorgey.github.io/blog</link>
        <description><![CDATA[Brent Yorgey's academic blog]]></description>
        <atom:link href="http://byorgey.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 25 Jun 2024 00:00:00 UT</lastBuildDate>
        <item>
    <title>Products with unordered n-tuples</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/25/unordered-n-tuple-product.html</link>
    <description><![CDATA[
<h1>Products with unordered n-tuples</h1>

<div class="info">
  Posted on June 25, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;type-level programming&#39;." href="/tag/type-level%20programming.html" rel="tag">type-level programming</a>, <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;product&#39;." href="/tag/product.html" rel="tag">product</a>, <a title="All pages tagged &#39;unordered&#39;." href="/tag/unordered.html" rel="tag">unordered</a>, <a title="All pages tagged &#39;tuples&#39;." href="/tag/tuples.html" rel="tag">tuples</a>
  
</div>

<section>
<p>Recently, Dani Rybe wrote <a href="https://danryba253.github.io/danirybeblog/posts/unordered-n-tuples/">this really cool blog
post</a>
(in turn based on <a href="https://gelisam.blogspot.com/2013/07/the-commutative-monad.html">this old post by Samuel
Gélineau</a>)
about encoding truly <em>unordered</em> n-tuples in Haskell. This is
something I thought about a long time ago in my work on
combinatorial species, but I never came up with a way to represent
them. Samuel and Dani’s solution is wonderful and clever and totally
impractical, and I love it.</p>
<p>I won’t go into more detail than that; I’ll let you go read it if
you’re interested. This blog post exists solely to respond to Dani’s
statement towards the end of her post:</p>
<blockquote>
<p>I’m not sure how to, for example, write a function that multiplies
the inputs.</p>
</blockquote>
<p>Challenge accepted!</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Int</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>mul <span class="ot">=</span> unfuck mulU</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulU ::</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  mulU <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">&lt;</span> <span class="dv">0</span>) \(<span class="dt">US</span> neg nonNeg) <span class="ot">-&gt;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    mulNonNeg nonNeg <span class="op">*</span> mulPos primes (<span class="fu">abs</span> <span class="op">&lt;$&gt;</span> neg) <span class="op">*</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">^</span> ulen neg</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulNonNeg ::</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  mulNonNeg <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">==</span> <span class="dv">0</span>) \(<span class="dt">US</span> zero pos) <span class="ot">-&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> ulen zero <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> mulPos primes pos</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulPos ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  mulPos ps <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">==</span> <span class="dv">1</span>) \(<span class="dt">US</span> _ pos) <span class="ot">-&gt;</span> mulGTOne ps pos</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulGTOne ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  mulGTOne (p <span class="op">:</span> ps) <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> ((<span class="op">==</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) \(<span class="dt">US</span> divP nondivP) <span class="ot">-&gt;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    mulPos (p <span class="op">:</span> ps) ((<span class="ot">`div`</span> p) <span class="op">&lt;$&gt;</span> divP) <span class="op">*</span> (p <span class="op">^</span> ulen divP) <span class="op">*</span> mulGTOne ps nondivP</span></code></pre></div>
<p>Since every integer has a unique prime factorization, at each step we
split the remaining numbers into those divisible by <span class="math inline">\(p\)</span> and those not
divisible by <span class="math inline">\(p\)</span>. For the ones that are, we divide out <span class="math inline">\(p\)</span> from all
of them, multiply by the appropriate power of <span class="math inline">\(p\)</span>, and recurse on
what’s left; for those that are not, we move on to trying the next
prime.</p>
<p>Dani also speculates about <code>ubind :: U n (U m a) -&gt; U (n :*: m) a</code>. I
believe in my heart this should be possible to implement, but after
playing with it a bit, I concluded it would require an astounding feat
of type-fu.</p>
<p>PS I’m working on getting comments set up here on my new
blog… hopefully coming soon!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 25 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/25/unordered-n-tuple-product.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: sieving with mutable arrays</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/21/cpih-product-divisors.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: sieving with mutable arrays</h1>

<div class="info">
  Posted on June 21, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;sieve&#39;." href="/tag/sieve.html" rel="tag">sieve</a>, <a title="All pages tagged &#39;mutable array&#39;." href="/tag/mutable%20array.html" rel="tag">mutable array</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">a previous
post</a>
I challenged you to solve <a href="https://open.kattis.com/problems/productdivisors">Product
Divisors</a>. In this
problem, we are given a sequence of positive integers <span class="math inline">\(a_1, \dots, a_n\)</span>, and we are asked to compute the total number of divisors of
their product. For example, if we are given the numbers <span class="math inline">\(4, 2, 3\)</span>,
then the answer should be <span class="math inline">\(8\)</span>, since <span class="math inline">\(4 \times 2 \times 3 = 24\)</span> has
the <span class="math inline">\(8\)</span> distinct divisors <span class="math inline">\(1, 2, 3, 4, 6, 8, 12, 24\)</span>.</p>
<section id="counting-divisors" class="level2">
<h2>Counting divisors</h2>
<p>In general, if <span class="math inline">\(a\)</span> has the prime factorization <span class="math inline">\(a = p_1^{\alpha_1} p_2^{\alpha_2} \cdots p_k^{\alpha_k}\)</span> (where the <span class="math inline">\(p_i\)</span> are all distinct primes), then
the number of divisors of <span class="math inline">\(a\)</span> is</p>
<p><span class="math display">\[(\alpha_1 + 1)(\alpha_2 + 1) \cdots (\alpha_k + 1),\]</span></p>
<p>since we can independently choose how many powers of each prime to
include. There are <span class="math inline">\(\alpha_i + 1\)</span> choices for <span class="math inline">\(p_i\)</span> since we can
choose anything from <span class="math inline">\(p_i^0\)</span> up to <span class="math inline">\(p_i^{\alpha_i}\)</span>, inclusive.</p>
<p>So at a fundamental level, the solution is clear: factor each <span class="math inline">\(a_i\)</span>,
count up the number of copies of each prime in their product, then do
something like <code>map (+1) &gt;&gt;&gt; product</code>. We are also told the answer
should be given mod <span class="math inline">\(10^9 + 7\)</span>, so we can use a<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Using <code>Int</code>
instead of <code>Integer</code> here is OK as long as we are sure to be running
on a 64-bit system; multiplying two <code>Int</code> values up to <span class="math inline">\(10^9 + 7\)</span>
yields a result that still fits within a 64-bit signed <code>Int</code>.
Otherwise (<em>e.g.</em> <a href="https://byorgey.github.io/blog/posts/2021/09/21/competitive-programming-in-haskell-codeforces-educational-round-114.html">on Codeforces</a>) we would have to use <code>Integer</code>.<br />
<br />
</span></span> <a href="https://byorgey.github.io/blog/posts/2020/02/15/competitive-programming-in-haskell-modular-arithmetic-part-1.html"><code>newtype</code> with a
custom <code>Num</code> instance</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="dv">10</span><span class="op">^</span><span class="dv">9</span> <span class="op">+</span> <span class="dv">7</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> {<span class="ot"> unM ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">M</span> <span class="kw">where</span> <span class="fu">show</span> <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> unM</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">M</span> <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">M</span> <span class="op">.</span> (<span class="ot">`mod`</span> p) <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">+</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">+</span> y) <span class="ot">`mod`</span> p)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">-</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">-</span> y) <span class="ot">`mod`</span> p)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">*</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">*</span> y) <span class="ot">`mod`</span> p)</span></code></pre></div>
</section>
<section id="a-naïve-solution-tle" class="level2">
<h2>A naïve solution (TLE)</h2>
<p>Of course, I would not be writing about this problem if it were that
easy! If we try implementing the above solution idea in a
straightforward way—for example, if we <a href="https://byorgey.wordpress.com/2020/02/07/competitive-programming-in-haskell-primes-and-factoring/">take the simple factoring code from this blog
post</a>
and then do something like <code>map factor &gt;&gt;&gt; M.unionsWith (+) &gt;&gt;&gt; M.elems &gt;&gt;&gt; map (+1) &gt;&gt;&gt; product</code>, we get the dreaded Time Limit Exceeded.</p>
<p>Why doesn’t this work? I haven’t mentioned how many integers might be
in the input: in fact, we might be given as many as one million (<span class="math inline">\(10^6\)</span>)! We need
to be able to factor each number very quickly if we’re going to finish
within the one second time limit. Factoring each number from scratch
by trial division is simply too slow.</p>
</section>
<section id="factoring-via-sieve" class="level2">
<h2>Factoring via sieve</h2>
<p>While <a href="https://cp-algorithms.com/algebra/factorization.html">more sophisticated methods</a> are needed to factor a <em>single</em>
number more quickly than trial division, there is a standard technique
we can use to speed things up when we need to factor <em>many</em> numbers.
We can use a <em>sieve</em> to precompute a lookup table, which we can then
use to factor numbers very quickly.</p>
<p>In particular, we will compute a table <span class="math inline">\(\mathit{smallest}\)</span> such that
<span class="math inline">\(\mathit{smallest}[i]\)</span> will store the <em>smallest prime factor</em> of <span class="math inline">\(i\)</span>.
Given this table, to factor a positive integer <span class="math inline">\(i\)</span>, we simply look up
<span class="math inline">\(\mathit{smallest}[i] = p\)</span>, add it to the prime factorization, then
recurse on <span class="math inline">\(i/p\)</span>; the base case is when <span class="math inline">\(i = 1\)</span>.</p>
<p>How do we compute <span class="math inline">\(\mathit{smallest}\)</span>? The basic idea is to create an
array of size <span class="math inline">\(n\)</span>, initializing it with <span class="math inline">\(\mathit{smallest}[k] = k\)</span>. For each <span class="math inline">\(k\)</span> from <span class="math inline">\(2\)</span> up to <span class="math inline">\(n\)</span>,<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">We could optimize this even
further via the <a href="https://codeforces.com/blog/entry/54090">approach in this blog
post</a>, which takes <span class="math inline">\(O(n)\)</span>
rather than <span class="math inline">\(O(n \lg n)\)</span> time, but it would complicate our Haskell
quite a bit and it’s not needed for solving this problem.<br />
<br />
</span></span> if
<span class="math inline">\(\mathit{smallest}[k]\)</span> is still equal to <span class="math inline">\(k\)</span>, then <span class="math inline">\(k\)</span> must be prime;
iterate through multiples of <span class="math inline">\(k\)</span> (starting with <span class="math inline">\(k^2\)</span>, since any
smaller multiple of <span class="math inline">\(k\)</span> is already divisible by a smaller prime) and
set each <span class="math inline">\(\mathit{smallest}[ki]\)</span> to the minimum of <span class="math inline">\(k\)</span> and whatever
value it had before.</p>
</section>
<section id="sieving-in-haskell" class="level2">
<h2>Sieving in Haskell</h2>
<p>This is one of those cases where for efficiency’s sake, we actually
want to use an honest-to-goodness mutable array. Immutable arrays are
not a good fit for sieving, and using something like a <code>Map</code> would
introduce a lot of overhead that we would rather avoid. However, we
only need the table to be mutable while we are computing it; after
that, it should just be an immutable lookup table. This is a great fit
for an <code>STUArray</code>:<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote">Note that as of this writing, the version of the
<code>array</code> library installed in the Kattis environment does not have
<code>modifyArray'</code>, so we actually have to do <code>readArray</code> followed by
<code>writeArray</code>.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>maxN <span class="ot">=</span> <span class="dv">1000000</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">smallest ::</span> <span class="dt">UArray</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>smallest <span class="ot">=</span> runSTUArray <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newListArray (<span class="dv">2</span>,maxN) [<span class="dv">2</span> <span class="op">..</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  forM_ [<span class="dv">2</span> <span class="op">..</span> maxN] <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    k&#39; <span class="ot">&lt;-</span> readArray a k</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    when (k <span class="op">==</span> k&#39;) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      forM_ [k<span class="op">*</span>k, k<span class="op">*</span>(k<span class="op">+</span><span class="dv">1</span>) <span class="op">..</span> maxN] <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        modifyArray&#39; a n (<span class="fu">min</span> k)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a</span></code></pre></div>
<p>Haskell, the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">world’s finest imperative programming language</a>!</p>
</section>
<section id="combining-factorizations" class="level2">
<h2>Combining factorizations</h2>
<p>We can now write a new <code>factor</code> function that works by repeatedly
looking up the smallest prime factor:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span> <span class="ot">-&gt;</span> M.empty</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) p <span class="dv">1</span> (factor (n <span class="ot">`div`</span> p))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    p <span class="ot">=</span> smallest<span class="op">!</span>n</span></code></pre></div>
<p>And now we can just do <code>map factor &gt;&gt;&gt; M.unionsWith (+) &gt;&gt;&gt; M.elems &gt;&gt;&gt; map (+1) &gt;&gt;&gt; product</code>
as before, but since our <code>factor</code> is so much faster this time, it
should…</p>
<p>What’s that? Still TLE? Sigh.</p>
</section>
<section id="counting-primes-via-a-second-mutable-array" class="level2">
<h2>Counting primes via a (second) mutable array</h2>
<p>Unfortunately, creating a bunch of <code>Map</code> values and then doing
<code>unionsWith</code> one million times still introduces way too much overhead.
For many problems working with <code>Map</code> (which is impressively fast) is
good enough, but not in this case. Instead of returning a <code>Map</code> from
each call to <code>factor</code> and then later combining them, we can write a version of
<code>factor</code> that directly increments counters for each prime in a
mutable array:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">STUArray</span> s <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>factor counts n <span class="ot">=</span> go n</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    go <span class="dv">1</span> <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    go n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> p <span class="ot">=</span> smallest<span class="op">!</span>n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      modifyArray&#39; counts p (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      go (n <span class="ot">`div`</span> p)</span></code></pre></div>
<p>Then we have the following top-level solution, which is finally fast
enough:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> C.interact <span class="op">$</span> runScanner (numberOf int) <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> showB</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">M</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>solve <span class="ot">=</span> counts <span class="op">&gt;&gt;&gt;</span> elems <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> ((<span class="op">+</span><span class="dv">1</span>) <span class="op">&gt;&gt;&gt;</span> <span class="dt">M</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">product</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">counts ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">UArray</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>counts ns <span class="ot">=</span> runSTUArray <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  cs <span class="ot">&lt;-</span> newArray (<span class="dv">2</span>,maxN) <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  forM_ ns (factor cs)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> cs</span></code></pre></div>
<p>This solution runs in just over 0.4s for me. Considering that this is
only about 4x slower than the fastest solution (0.09s, in C++), I’m
pretty happy with it! We did have to sacrifice a bit of elegance for
speed, especially with the <code>factor</code> and <code>counts</code> functions instead of
<code>M.unionsWith</code>, but in the end it’s not too bad.</p>
<p>I thought we might be able to make this even faster by using a strict
fold over the <code>counts</code> array instead of converting to a list with
<code>elems</code> and then doing a <code>map</code> and a <code>product</code>, but (1) there is no
generic fold operation on <code>UArray</code>, and (2) I trust that GHC is
already doing a pretty good job optimizing this via list fusion.</p>
</section>
<section id="next-time" class="level2">
<h2>Next time</h2>
<p>Next time I’ll write about my solution to the <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">other challenge
problem</a>,
<a href="https://open.kattis.com/problems/factorfulltree">Factor-Full Tree</a>.
Until then, give it a try!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Fri, 21 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/21/cpih-product-divisors.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Swarm swarm III (virtual hackathon)</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/12/swarm-swarm-3.html</link>
    <description><![CDATA[
<h1>Swarm swarm III (virtual hackathon)</h1>

<div class="info">
  Posted on June 12, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;hackathon&#39;." href="/tag/hackathon.html" rel="tag">hackathon</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>This Saturday, June 15, we will have the third Swarm swarm, <em>i.e.</em>
collaborative virtual hackathon. Details can be found <a href="https://github.com/swarm-game/swarm/wiki/Swarm-swarm">here on the
Swarm wiki</a>.</p>
<ul>
<li>Time: <a href="https://www.timeanddate.com/worldclock/fixedtime.html?msg=Swarm+swarm+III&amp;iso=20240615T16&amp;p1=1440&amp;ah=6">11am-5pm CDT / 4pm-10pm UTC / 9:30pm-3:30am
IST</a>
(feel free to drop in and out any time)</li>
<li>Place: <a href="https://app.gather.town/app/SpqG1ic5pNKM7YqS/The%20Swarm%20Hive">The Swarm Hive on
gather.town</a></li>
<li>Who: you! Anyone interested in hacking on Swarm is welcome, from
experienced to first-time contributors. If you’ve been thinking of
getting involved but haven’t yet, this could be a perfect
opportunity.</li>
</ul>
<p>As a reminder, <a href="https://swarm-game.github.io/">Swarm</a> is a 2D,
open-world programming and resource gathering game, implemented in
Haskell, with a strongly-typed, functional programming language and a
unique upgrade system. Unlocking language features is tied to
collecting resources, making it an interesting challenge to bootstrap
your way into the use of the full language.</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Wed, 12 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/12/swarm-swarm-3.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Two Hard Problems</title>
    <link>http://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Two Hard Problems</h1>

<div class="info">
  Posted on May 28, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>
  
</div>

<section>
<p>I haven’t written here in a while—partly due to being busy, but also
partly due to getting sick of Wordpress and deciding it was finally
time to rebuild my blog from scratch using
<a href="https://jaspervdj.be/hakyll/">Hakyll</a>. I still haven’t quite worked
out what I’m doing about comments (I looked into
<a href="https://isso-comments.de/">Isso</a> but haven’t gotten it to work
yet—if you have used it successfully, let me know!).</p>
<p>For today I have two hard competitive programming challenge problems
for you. Both involve some number theory, and both are fairly
challenging, but that’s about all they have in common!</p>
<ul>
<li><a href="https://open.kattis.com/problems/productdivisors">Product Divisors</a></li>
<li><a href="https://open.kattis.com/problems/factorfulltree">Factor-Full Tree</a></li>
</ul>
<p>Since there are no comments (for now), feel free to email me with your
thoughts. I’ll post my solutions (with commentary) in a later post or
two!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 28 May 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Swarm 0.4 release</title>
    <link>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</link>
    <description><![CDATA[
<h1>Swarm 0.4 release</h1>

<div class="info">
  Posted on August 22, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;resource&#39;." href="/tag/resource.html" rel="tag">resource</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>
The <a href="https://github.com/swarm-game/swarm/">Swarm</a> development team is very proud to announce the latest release of the game. This should still be considered a development/preview release—you still can’t <a href="https://github.com/swarm-game/swarm/issues/50">save your games</a>—but it’s made some remarkable progress and there are lots of fun things to try.
</p>
<h2 id="what-is-it">
What is it?
</h2>
<p>
As a reminder, Swarm is a 2D, open-world programming and resource gathering game with a strongly-typed, functional programming language and a unique upgrade system. Unlocking language features is tied to collecting resources, making it an interesting challenge to bootstrap your way into the use of the full language. It has also become a flexible and powerful platform for constructing programming challenges.
</p>
<p>
A few of the most significant new features are highlighted below; for full details, see the <a href="https://github.com/swarm-game/swarm/releases/tag/0.4.0.0">release notes</a>. If you just want to try it out, see the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>.
</p>
<h2 id="expanded-design-possibilities">
Expanded design possibilities
</h2>
<p>
The default play mode is the open-world, resource-gathering scenario—but Swarm also supports “challenge scenarios”, where you have to complete one or more specific objectives with given resources on a custom map. There are currently 58 scenarios and counting—some are silly proofs of concept, but many are quite fun and challenging! I especially recommend checking out the <code>Ranching</code> and <code>Sokoban</code> scenarios, as well as <code>A Frivolous Excursion</code> (pictured below). And creating new scenarios is a great way you can contribute to Swarm even if you don’t know Haskell, or aren’t comfortable hacking on the codebase.
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/excursion.png" />
</p>
</div>
<p>
Recently, a large amount of work has gone into expanding the possibilities for scenario design:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1332">Structure templates</a> allow you to design map tiles and then reuse them multiple times within a scenario.
</li>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1356">Waypoints and portals</a> provide a mechanism for automatically navigating and teleporting around the world.
</li>
<li>
Scenarios can have multiple <a href="https://github.com/swarm-game/swarm/pull/1353">subworlds</a> besides the main “overworld”, connected by portals. For example you could go “into a building” and have a separate map for the building interior.
</li>
<li>
There are a slew of new robot commands, many to do with different sensing modalities: <code>stride</code>, <code>detect</code>, <code>sniff</code>, <code>chirp,</code> <code>resonate</code>, <code>watch</code>, <code>surveil</code>, <code>scout</code>, <code>instant</code>, <code>push</code>, <code>density</code>, <code>use</code>, <code>halt</code>, and <code>backup</code>.
</li>
<li>
A <a href="https://github.com/swarm-game/swarm/pull/1376">new domain-specific language</a> for describing procedurally generated worlds. The default procedurally generated world used to be hardcoded, but now it is described externally via the new DSL, and you can design your own procedurally generated worlds without editing the Swarm source code.
</li>
<li>
The <a href="https://github.com/swarm-game/swarm/pull/1214">key input handler</a> feature allows you to program robots to respond to keyboard input, so you can <em>e.g.</em> drive them around manually, or interactively trigger more complex behaviors. This makes it possible to design “arcade-style” challenges, where the player needs to guide a robot and react to obstacles in real time—but they get to program the robot to respond to their commands first!
</li>
<li>
A new prototype <a href="https://github.com/swarm-game/swarm/pull/873">integrated world editor</a> lets you design worlds interactively.
</li>
</ul>
<h2 id="ui-improvements">
UI improvements
</h2>
<p>
In the past, entity and goal descriptions were simply plain text; recently, we switched to actually parsing Markdown. Partly, this is just to make things look nice, since we can highlight code snippets, entity names, etc.:
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/crafting.png" />
</p>
</div>
<p>
But it also means that we can now validate all code examples and entity names, and even test that the tutorial is pedagogically sound: any command used in a tutorial solution must be mentioned in a previous tutorial, or else our CI fails!
</p>
<p>
There are also a number of other small UI enhancements, such as improved type error messages, inventory search, and a collapsible REPL panel, among others.
</p>
<h2 id="scoring-metrics">
Scoring metrics
</h2>
<p>
We now keep track of a number of metrics related to challenge scenario solutions, such as total time, total game ticks, and code size. These metrics are tracked and saved across runs, so you can compete with yourself, and with others. For now, see these wiki pages:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Speedrunning">Swarm speedrunning</a>
</li>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Code-golf">Swarm code golf</a>
</li>
</ul>
<p>
In the future, perhaps there will eventually be some kind of <a href="https://github.com/swarm-game/swarm/issues/1259">social website</a> with leaderboards and user-uploaded scenarios.
</p>
<h2 id="debugging">
Debugging
</h2>
<p>
Last but not least, we now have an <a href="https://github.com/swarm-game/swarm/pull/1081">integrated single-stepping and debugging mode</a> (enabled by the <code>tweezers</code> device).
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/debugger.png" />
</p>
</div>
<h2 id="give-it-a-try">
Give it a try!
</h2>
<p>
To install, check out the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>: you can download a <a href="https://github.com/swarm-game/swarm/releases">binary release</a> (for now, Linux only, but MacOS binaries should be on the horizon), or <a href="https://hackage.haskell.org/package/swarm">install from Hackage</a>. Give it a try and send us your feedback, either <a href="https://github.com/swarm-game/swarm/issues/new/choose">via a github issue</a> or <a href="https://web.libera.chat/?channels=#swarm">IRC</a>!
</p>
<h2 id="future-plans-getting-involved">
Future plans &amp; getting involved
</h2>
<p>
We’re still hard at work on the game. Fun upcoming things include:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/issues/50">Saving and loading games</a>
</li>
<li>
New world features like aliens and <a href="https://github.com/swarm-game/swarm/issues/112">cities</a>
</li>
<li>
New language features like <a href="https://github.com/swarm-game/swarm/issues/154">recursive types</a>, <a href="https://github.com/swarm-game/swarm/issues/98">arrays</a>, <a href="https://github.com/swarm-game/swarm/issues/94">inter-robot communication</a>, and <a href="https://github.com/swarm-game/swarm/issues/495">a proper <code>import</code> construct</a>
</li>
</ul>
<p>
Of course, there are also <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">tons of small things that need fixing and polishing</a> too! If you’re interested in getting involved, check out our <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">contribution guide</a>, come <a href="https://web.libera.chat/?channels=#swarm">join us on IRC</a> (<code>#swarm</code> on Libera.Chat), or take a look at the list of <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">issues marked “low-hanging fruit”</a>.
</p>
<p>
Brought to you by the Swarm development team:
</p>
<ul>
<li>
Brent Yorgey
</li>
<li>
Karl Ostmo
</li>
<li>
Ondřej Šebek
</li>
</ul>
<p>
With contributions from:
</p>
<ul>
<li>
Alexander Block
</li>
<li>
Brian Wignall
</li>
<li>
Chris Casinghino
</li>
<li>
Daniel Díaz Carrete
</li>
<li>
Huw Campbell
</li>
<li>
Ishan Bhanuka
</li>
<li>
Jacob
</li>
<li>
Jens Petersen
</li>
<li>
José Rafael Vieira
</li>
<li>
Joshua Price
</li>
<li>
lsmor
</li>
<li>
Noah Yorgey
</li>
<li>
Norbert Dzikowski
</li>
<li>
Paul Brauner
</li>
<li>
Ryan Yates
</li>
<li>
Sam Tay
</li>
<li>
Steven Garcia
</li>
<li>
Tamas Zsar
</li>
<li>
Tristan de Cacqueray
</li>
<li>
Valentin Golev
</li>
</ul>
<p>
…not to mention many others who gave valuable suggestions and feedback. Want to see your name listed here in the next release? <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">See how you can contribute!</a>
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-08-22T17:37:34Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Compiling to Intrinsically Typed Combinators</title>
    <link>http://byorgey.github.io/blog/posts/2023/07/13/compiling-to-intrinsically-typed-combinators.html</link>
    <description><![CDATA[
<h1>Compiling to Intrinsically Typed Combinators</h1>

<div class="info">
  Posted on July 13, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;bracket&#39;." href="/tag/bracket.html" rel="tag">bracket</a>, <a title="All pages tagged &#39;combinators&#39;." href="/tag/combinators.html" rel="tag">combinators</a>, <a title="All pages tagged &#39;compile&#39;." href="/tag/compile.html" rel="tag">compile</a>, <a title="All pages tagged &#39;DSL&#39;." href="/tag/DSL.html" rel="tag">DSL</a>, <a title="All pages tagged &#39;indexed&#39;." href="/tag/indexed.html" rel="tag">indexed</a>, <a title="All pages tagged &#39;typed&#39;." href="/tag/typed.html" rel="tag">typed</a>
  
</div>

<section>
<p>
<strong>tl;dr</strong>: <em>How to compile a functional language via combinators (and evaluate via the Haskell runtime) while keeping the entire process type-indexed, with a bibliography and lots of references for further reading</em>
</p>
<p>
There is a long history, starting with Schönfinkel and Curry, of abstracting away variable names from lambda calculus terms by converting to combinators, aka <em>bracket abstraction</em>. This was popular in the 80’s as a compilation technique for functional languages <span class="citation">(Turner, 1979; Augustsson, 1986; Jones, 1987; Diller, 1988)</span>, then apparently abandoned. More recently, however, it has been making a bit of a comeback. For example, see <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=f801c21b2630df3094c9c800c18ebc1e969865da">Naylor</a> <span class="citation">(2008)</span>, <a href="https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html">Gratzer</a> <span class="citation">(2015)</span>, <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">Lynn</a> <span class="citation">(2017)</span>, and <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">Mahler</a> <span class="citation">(2021)</span>. Bracket abstraction is intimately related to compiling to cartesian closed categories <span class="citation">(Elliott, 2017; Mahler, 2021)</span>, and also enables cool tricks like doing evaluation via the Haskell runtime system <span class="citation">(Naylor, 2008; Seo, 2016; Mahler, 2022)</span>.
</p>
<p>
However, it always bothered me that the conversion to combinators was invariably described in an untyped way. Partly to gain some assurance that we are doing things correctly, but mostly for fun, I wondered if it would be possible to do the whole pipeline in an explicitly type-indexed way. I eventually found <a href="http://okmij.org/ftp/tagless-final/ski.pdf">a nice paper by Oleg Kiselyov</a> <span class="citation">(2018)</span> which explains exactly how to do it (it even came with <a href="http://okmij.org/ftp/tagless-final/skconv.ml">OCaml code</a> that I was easily able to port to Haskell!).
</p>
<p>
In this blog post, I:
</p>
<ul>
<li>
Show an example of typechecking and elaboration for a functional language into explicitly type-indexed terms, such that it is impossible to write down ill-typed terms
</li>
<li>
Demonstrate a Haskell port of Oleg Kiselyov’s typed bracket abstraction algorithm
</li>
<li>
Demonstrate type-indexed evaluation of terms via the Haskell runtime
</li>
<li>
Put together an extensive bibliography with references for further reading
</li>
</ul>
<p>
This blog post is rendered automatically from a literate Haskell file; you can <a href="https://github.com/byorgey/typed-combinators">find the complete working source code and blog post on GitHub</a>. I’m always happy to receive comments, fixes, or suggestions for improvement.
</p>
<h2 id="but-first-a-message-from-our-sponsors">
But First, A Message From Our Sponsors
</h2>
<p>
So many yummy language extensions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE ConstraintKinds #-}</span>
<span style="color: green">{-# LANGUAGE DataKinds #-}</span>
<span style="color: green">{-# LANGUAGE ExplicitForAll #-}</span>
<span style="color: green">{-# LANGUAGE FlexibleContexts #-}</span>
<span style="color: green">{-# LANGUAGE GADTs #-}</span>
<span style="color: green">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span style="color: green">{-# LANGUAGE InstanceSigs #-}</span>
<span style="color: green">{-# LANGUAGE KindSignatures #-}</span>
<span style="color: green">{-# LANGUAGE LambdaCase #-}</span>
<span style="color: green">{-# LANGUAGE OverloadedStrings #-}</span>
<span style="color: green">{-# LANGUAGE PatternSynonyms #-}</span>
<span style="color: green">{-# LANGUAGE RankNTypes #-}</span>
<span style="color: green">{-# LANGUAGE StandaloneDeriving #-}</span>
<span style="color: green">{-# LANGUAGE TypeApplications #-}</span>
<span style="color: green">{-# LANGUAGE TypeFamilies #-}</span>
<span style="color: green">{-# LANGUAGE TypeOperators #-}</span>
<span style="color: green">{-# LANGUAGE UnicodeSyntax #-}</span>
<span style="color: green">{-# LANGUAGE ViewPatterns #-}</span>

<span style="color: blue;font-weight: bold">module</span> <span>TypedCombinators</span> <span style="color: blue;font-weight: bold">where</span>

<span style="color: blue;font-weight: bold">import</span> <span>Control.Monad.Combinators.Expr</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Functor.Const</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>F</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Void</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Text</span> <span style="color: red">(</span> <span>Text</span> <span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Text</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>T</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Kind</span> <span style="color: red">(</span><span>Type</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Type.Equality</span> <span style="color: red">(</span> <span style="color: blue;font-weight: bold">type</span> <span style="color: red">(</span><span>:~:</span><span style="color: red">)</span><span style="color: red">(</span><span>Refl</span><span style="color: red">)</span><span style="color: red">,</span> <span>TestEquality</span><span style="color: red">(</span><span style="color: red">..</span><span style="color: red">)</span> <span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec.Char</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec.Char.Lexer</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>L</span>
<span style="color: blue;font-weight: bold">import</span> <span>Witch</span> <span style="color: red">(</span><span>into</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Prelude</span> <span>hiding</span> <span style="color: red">(</span><span>lookup</span><span style="color: red">)</span></code></pre>
<h2 id="raw-terms-and-types">
Raw terms and types
</h2>
<p>
Here’s an algebraic data type to represent raw terms of our DSL, something which might come directly out of a parser. The exact language we use here isn’t all that important; I’ve put in just enough features to make it nontrivial, but not much beyond that. We have integer literals, variables, lambdas, application, <code>let</code> and <code>if</code> expressions, addition, and comparison with <code>&gt;</code>. Of course, it would be easy to add more types, constants, and language features.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Term</span> <span style="color: blue;font-weight: bold">where</span>
  <span>Lit</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Var</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Lam</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>App</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Let</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>If</span>  <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Add</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Gt</span>  <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span></code></pre>
<p>
A few things to note:
</p>
<ul>
<li>
<p>
In order to keep things simple, notice that lambdas must be annotated with the type of the argument. There are other choices we could make, but this is the simplest for now. I’ll have more to say about other choices later.
</p>
</li>
<li>
<p>
I included <code>if</code> not only because it gives us something to do with Booleans, but also because it is <em>polymorphic</em>, which adds an interesting twist to our typechecking.
</p>
</li>
<li>
<p>
I included <code>&gt;</code>, not only because it gives us a way to produce Boolean values, but also because it uses <em>ad-hoc</em> polymorphism, that is, we can compare at any type which is an instance of <code>Ord</code>. This is an even more interesting twist.
</p>
</li>
</ul>
<p>
Here are our types: integers, booleans, and functions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Ty</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TyInt</span>  <span style="color: red">::</span> <span>Ty</span>
  <span>TyBool</span> <span style="color: red">::</span> <span>Ty</span>
  <span>TyFun</span>  <span style="color: red">::</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Ty</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span></code></pre>
<p>
Finally, here’s an example term that uses all the features of our language (I’ve included a simple parser in an appendix at the end of this post):
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>example</span> <span style="color: red">::</span> <span>Term</span>
<span>example</span> <span style="color: red">=</span> <span>readTerm</span> <span>$</span> <span>T.unlines</span>
  <span style="color: red">[</span> <span style="color: teal">"let twice = \\f:Int -&gt; Int. \\x:Int. f (f x) in"</span>
  <span style="color: red">,</span> <span style="color: teal">"let z = 1 in"</span>
  <span style="color: red">,</span> <span style="color: teal">"if 7 &gt; twice (\\x:Int. x + 3) z then z else z + 1"</span>
  <span style="color: red">]</span></code></pre>
<p>
Since 7 is not, in fact, strictly greater than 1 + 3 + 3, this should evaluate to 2.
</p>
<h2 id="type-indexed-constants">
Type-indexed constants
</h2>
<p>
That was the end of our raw, untyped representations—from now on, everything is going to be type-indexed! First of all, we’ll declare an enumeration of constants, with each constant indexed by its corresponding host language type. These will include both any special language built-ins (like <code>if</code>, <code>+</code>, and <code>&gt;</code>) as well as a set of <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinators</a> which we’ll be using as a compilation target—more on these later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Const</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CInt</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>Int</span>
  <span>CIf</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>CAdd</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>Int</span> <span style="color: red">-&gt;</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Int</span><span style="color: red">)</span>
  <span>CGt</span> <span style="color: red">::</span> <span>Ord</span> <span>α</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Bool</span><span style="color: red">)</span>
  <span>I</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>K</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>S</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
  <span>B</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span>     <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
  <span>C</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span>       <span>b</span>  <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>Const</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
The polymorphism of <code>if</code> (and the combinators <code>I</code>, <code>K</code>, <em>etc.</em>, for that matter) poses no real problems. If we really wanted the type of <code>CIf</code> to be indexed by the exact type of <code>if</code>, it would be something like
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>CIf</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
but this would require <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/impredicative_types.html">impredicative types</a> which can be something of a minefield. However, what we actually get is
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>CIf</span> <span style="color: red">::</span> <span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>Const</span> <span style="color: red">(</span><span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
which is unproblematic and works just as well for our purposes.
</p>
<p>
The type of <code>CGt</code> is more interesting: it includes an <code>Ord α</code> constraint. That means that at the time we construct a <code>CGt</code> value, we must have in scope an <code>Ord</code> instance for whatever type <code>α</code> is; conversely, when we pattern-match on <code>CGt</code>, we will bring that instance into scope. We will see how to deal with this later.
</p>
<p>
For convenience, we make a type class <code>HasConst</code> for type-indexed things that can contain embedded constants (we will end up with several instances of this class).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">class</span> <span>HasConst</span> <span>t</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span></code></pre>
<p>
Also for convenience, here’s a type class for type-indexed things that support some kind of application operation. (Note that we don’t necessarily want to require <code>t</code> to support a <code>pure :: a -&gt; t a</code> operation, or even be a <code>Functor</code>, so using <code>Applicative</code> would not be appropriate, even though <code>$$</code> has the same type as <code>&lt;*&gt;</code>.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>&#36;&#36;</span>
<span style="color: blue;font-weight: bold">class</span> <span>Applicable</span> <span>t</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span>t</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span></code></pre>
<p>
Note that, unlike the standard <code>$</code> operator, <code>$$</code> is <em>left</em>-associative, so, for example, <code>f $$ x $$ y</code> should be read just like <code>f x y</code>, that is, <code>f $$ x $$ y = (f $$ x) $$ y</code>.
</p>
<p>
Finally, we’ll spend a bunch of time applying constants to things, or applying things to constants, so here are a few convenience operators for combining <code>$$</code> and <code>embed</code>:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>.&#36;&#36;</span>
<span style="color: red">(</span><span>.&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>c</span> <span>.&#36;&#36;</span> <span>t</span> <span style="color: red">=</span> <span>embed</span> <span>c</span> <span>&#36;&#36;</span> <span>t</span>

<span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>&#36;&#36;.</span>
<span style="color: red">(</span><span>&#36;&#36;.</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>t</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>t</span> <span>&#36;&#36;.</span> <span>c</span> <span style="color: red">=</span> <span>t</span> <span>&#36;&#36;</span> <span>embed</span> <span>c</span>

<span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>.&#36;&#36;.</span>
<span style="color: red">(</span><span>.&#36;&#36;.</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>c1</span> <span>.&#36;&#36;.</span> <span>c2</span> <span style="color: red">=</span> <span>embed</span> <span>c1</span> <span>&#36;&#36;</span> <span>embed</span> <span>c2</span></code></pre>
<h2 id="type-indexed-types-and-terms">
Type-indexed types and terms
</h2>
<p>
Now let’s build up our type-indexed core language. First, we’ll need a data type for type-indexed de Bruijn indices. A value of type <code>Idx γ α</code> is a variable with type <code>α</code> in the context <code>γ</code> (represented as a type-level list of types). For example, <code>Idx [Int,Bool,Int] Int</code> would represent a variable of type <code>Int</code> (and hence must either be variable 0 or 2).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Idx</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>VZ</span> <span style="color: red">::</span> <span>Idx</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>
  <span>VS</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Idx</span> <span style="color: red">(</span><span>β</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
Now we can build our type-indexed terms. Just like variables, terms are indexed by a typing context and a type; <code>t : TTerm γ α</code> can be read as “<code>t</code> is a term with type <code>α</code>, possibly containing variables whose types are described by the context <code>γ</code>”. Our core language has only variables, constants, lambdas, and application. Note we’re not just making a type-indexed version of our original term language; for simplicity, we’re going to simultaneously typecheck and elaborate down to this much simpler core language. (Of course, it would also be entirely possible to introduce another intermediate data type for type-indexed terms, and separate the typechecking and elaboration phases.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>TTerm</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TVar</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span>
  <span>TConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span>
  <span>TLam</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>
  <span>TApp</span> <span style="color: red">::</span> <span>TTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>β</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">=</span> <span>TApp</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>TConst</span></code></pre>
<p>
Now for some type-indexed types!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>TTy</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TTyInt</span> <span style="color: red">::</span> <span>TTy</span> <span>Int</span>
  <span>TTyBool</span> <span style="color: red">::</span> <span>TTy</span> <span>Bool</span>
  <span style="color: red">(</span><span>:-&gt;:</span><span style="color: red">)</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>β</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>TTy</span> <span>ty</span><span style="color: red">)</span></code></pre>
<p>
<code>TTy</code> is a term-level representation of our DSL’s types, indexed by corresponding host language types. In other words, <code>TTy</code> is a <em>singleton</em>: for a given type <code>α</code> there is a single value of type <code>TTy α</code>. Put another way, pattern-matching on a value of type <code>TTy α</code> lets us learn what the type <code>α</code> is. (See <span class="citation">(Le, 2017)</span> for a <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">nice introduction to the idea of singleton types</a>.)
</p>
<p>
We will need to be able to test two value-level type representations for equality and have that reflected at the level of type indices; the <code>TestEquality</code> class from <code>Data.Type.Equality</code> is perfect for this. The <code>testEquality</code> function takes two type-indexed things and returns a type equality proof wrapped in <code>Maybe</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">instance</span> <span>TestEquality</span> <span>TTy</span> <span style="color: blue;font-weight: bold">where</span>
  <span>testEquality</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>β</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>α</span> <span>:~:</span> <span>β</span><span style="color: red">)</span>
  <span>testEquality</span> <span>TTyInt</span> <span>TTyInt</span> <span style="color: red">=</span> <span>Just</span> <span>Refl</span>
  <span>testEquality</span> <span>TTyBool</span> <span>TTyBool</span> <span style="color: red">=</span> <span>Just</span> <span>Refl</span>
  <span>testEquality</span> <span style="color: red">(</span><span>α₁</span> <span>:-&gt;:</span> <span>β₁</span><span style="color: red">)</span> <span style="color: red">(</span><span>α₂</span> <span>:-&gt;:</span> <span>β₂</span><span style="color: red">)</span> <span style="color: red">=</span>
    <span style="color: blue;font-weight: bold">case</span> <span style="color: red">(</span><span>testEquality</span> <span>α₁</span> <span>α₂</span><span style="color: red">,</span> <span>testEquality</span> <span>β₁</span> <span>β₂</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
      <span style="color: red">(</span><span>Just</span> <span>Refl</span><span style="color: red">,</span> <span>Just</span> <span>Refl</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Just</span> <span>Refl</span>
      <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
  <span>testEquality</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>Nothing</span></code></pre>
<p>
Recall that the <code>CGt</code> constant requires an <code>Ord</code> instance; the <code>checkOrd</code> function pattern-matches on a <code>TTy</code> and witnesses the fact that the corresponding host-language type has an <code>Ord</code> instance (if, in fact, it does).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>checkOrd</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>Ord</span> <span>α</span> <span style="color: red">=&gt;</span> <span>r</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>r</span>
<span>checkOrd</span> <span>TTyInt</span> <span>r</span> <span style="color: red">=</span> <span>Just</span> <span>r</span>
<span>checkOrd</span> <span>TTyBool</span> <span>r</span> <span style="color: red">=</span> <span>Just</span> <span>r</span>
<span>checkOrd</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>Nothing</span></code></pre>
<p>
As a quick aside, for simplicity’s sake, I am going to use <code>Maybe</code> throughout the rest of this post to indicate possible failure. In a real implementation, one would of course want to return more information about any error(s) that occur.
</p>
<h2 id="existential-wrappers">
Existential wrappers
</h2>
<p>
Sometimes we will need to wrap type-indexed things inside an existential wrapper to hide the type index. For example, when converting from a <code>Ty</code> to a <code>TTy</code>, or when running type inference, we can’t know in advance which type we’re going to get. So we create the <code>Some</code> data type which wraps up a type-indexed thing along with a corresponding <code>TTy</code>. Pattern-matching on the singleton <code>TTy</code> will allow us to recover the type information later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Some</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>Some</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>t</span>

<span>mapSome</span> <span style="color: red">::</span> <span style="color: red">(</span><span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>s</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>s</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>t</span>
<span>mapSome</span> <span>f</span> <span style="color: red">(</span><span>Some</span> <span>α</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>f</span> <span>t</span><span style="color: red">)</span></code></pre>
<p>
The first instantiation we’ll create is an existentially wrapped type, where the <code>TTy</code> itself is the only thing we care about, and the corresponding <code>t</code> will just be the constant unit type functor. It would be annoying to keep writing <code>F.Const ()</code> everywhere so we create some type and pattern synonyms for convenience.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>SomeTy</span> <span style="color: red">=</span> <span>Some</span> <span style="color: red">(</span><span>F.Const</span> <span>()</span><span style="color: red">)</span>

<span>pattern</span> <span>SomeTy</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>SomeTy</span>
<span>pattern</span> <span>SomeTy</span> <span>α</span> <span style="color: red">=</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>F.Const</span> <span>()</span><span style="color: red">)</span>
<span style="color: green">{-# COMPLETE SomeTy #-}</span></code></pre>
<p>
The <code>someType</code> function converts from a raw <code>Ty</code> to a type-indexed <code>TTy</code>, wrapped up in an existential wrapper.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>someType</span> <span style="color: red">::</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>SomeTy</span>
<span>someType</span> <span>TyInt</span> <span style="color: red">=</span> <span>SomeTy</span> <span>TTyInt</span>
<span>someType</span> <span>TyBool</span> <span style="color: red">=</span> <span>SomeTy</span> <span>TTyBool</span>
<span>someType</span> <span style="color: red">(</span><span>TyFun</span> <span>a</span> <span>b</span><span style="color: red">)</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span style="color: red">(</span><span>someType</span> <span>a</span><span style="color: red">,</span> <span>someType</span> <span>b</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
  <span style="color: red">(</span><span>SomeTy</span> <span>α</span><span style="color: red">,</span> <span>SomeTy</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>SomeTy</span> <span style="color: red">(</span><span>α</span> <span>:-&gt;:</span> <span>β</span><span style="color: red">)</span></code></pre>
<h2 id="type-inference-and-elaboration">
Type inference and elaboration
</h2>
<p>
Now that we have our type-indexed core language all set, it’s time to do type inference, that is, translate from untyped terms to type-indexed ones! First, let’s define type contexts, <em>i.e.</em> mappings from variables to their types. We store contexts simply as a (fancy, type-indexed) list of variable names paired with their types. This is inefficient—it takes linear time to do a lookup—but we don’t care, because this is an intermediate representation used only during typechecking. By the time we actually get around to running terms, variables won’t even exist any more.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Ctx</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>

  <span style="color: green">-- CNil represents an empty context.</span>
  <span>CNil</span> <span style="color: red">::</span> <span>Ctx</span> <span style="color: teal">'</span><span>[]</span>

  <span style="color: green">-- A cons stores a variable name and its type,</span>
  <span style="color: green">-- and then the rest of the context.</span>
  <span style="color: red">(</span><span>:::</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Text</span><span style="color: red">,</span> <span>TTy</span> <span>α</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span></code></pre>
<p>
Now we can define the <code>lookup</code> function, which takes a variable name and a context and tries to return a corresponding de Bruijn index into the context. When looking up a variable name in the context, we can’t know in advance what index we will get and what type it will have, so we wrap the returned <code>Idx</code> in <code>Some</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>lookup</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Some</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span><span style="color: red">)</span><span style="color: red">)</span>
<span>lookup</span> <span style="color: blue;font-weight: bold">_</span> <span>CNil</span> <span style="color: red">=</span> <span>Nothing</span>
<span>lookup</span> <span>x</span> <span style="color: red">(</span><span style="color: red">(</span><span>y</span><span style="color: red">,</span> <span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span>
  <span style="color: red">|</span> <span>x</span> <span>==</span> <span>y</span> <span style="color: red">=</span> <span>Just</span> <span style="color: red">(</span><span>Some</span> <span>α</span> <span>VZ</span><span style="color: red">)</span>
  <span style="color: red">|</span> <span>otherwise</span> <span style="color: red">=</span> <span>mapSome</span> <span>VS</span> <span>&lt;$&gt;</span> <span>lookup</span> <span>x</span> <span>ctx</span></code></pre>
<p>
Now we’re finally ready to define the <code>infer</code> function! It takes a type context and a raw term, and tries to compute a corresponding type-indexed term. Note that there’s no particular guarantee that the term we return corresponds to the input term—we will just have to be careful—but at least the Haskell type system guarantees that we can’t return a type-incorrect term, which is especially important when we have some nontrivial elaboration to do. Of course, just as with variable lookups, when inferring the type of a term we can’t know in advance what type it will have, so we will need to return an existential wrapper around a type-indexed term.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>infer</span> <span style="color: red">::</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Some</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span><span style="color: red">)</span>
<span>infer</span> <span>ctx</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span></code></pre>
<p>
To infer the type of a literal integer value, just return <code>TTyInt</code> with a literal integer constant.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Lit</span> <span>i</span> <span style="color: red">-&gt;</span> <span>return</span> <span>$</span> <span>Some</span> <span>TTyInt</span> <span style="color: red">(</span><span>embed</span> <span style="color: red">(</span><span>CInt</span> <span>i</span><span style="color: red">)</span><span style="color: red">)</span></code></pre>
<p>
To infer the type of a variable, look it up in the context and wrap the result in <code>TVar</code>. Notice how we are allowed to pattern-match on the <code>Some</code> returned from <code>lookup</code> (revealing the existentially quantified type inside) since we immediately wrap it back up in another <code>Some</code> when returning the <code>TVar</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Var</span> <span>x</span> <span style="color: red">-&gt;</span> <span>mapSome</span> <span>TVar</span> <span>&lt;$&gt;</span> <span>lookup</span> <span>x</span> <span>ctx</span></code></pre>
<p>
To infer the type of a lambda, we convert the argument type annotation to a type-indexed type, infer the type of the body under an extended context, and then return a lambda with an appropriate function type. (If lambdas weren’t required to have type annotations, then we would either have to move the lambda case to the <code>check</code> function, or else use unification variables and solve type equality constraints. The former would be straightforward, but I don’t know how to do the latter in a type-indexed way—sounds like a fun problem for later.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Lam</span> <span>x</span> <span>a</span> <span>t</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span style="color: blue;font-weight: bold">case</span> <span>someType</span> <span>a</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Some</span> <span>α</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
        <span>Some</span> <span>β</span> <span>t'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span style="color: red">(</span><span style="color: red">(</span><span>x</span><span style="color: red">,</span><span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span> <span>t</span>
        <span>return</span> <span>$</span> <span>Some</span> <span style="color: red">(</span><span>α</span> <span>:-&gt;:</span> <span>β</span><span style="color: red">)</span> <span style="color: red">(</span><span>TLam</span> <span>t'</span><span style="color: red">)</span></code></pre>
<p>
To infer the type of an application, we infer the type of the left-hand side, ensure it is a function type, and <code>check</code> that the right-hand side has the correct type. We will see the <code>check</code> function later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>App</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>τ</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span style="color: blue;font-weight: bold">case</span> <span>τ</span> <span style="color: blue;font-weight: bold">of</span>
      <span>α</span> <span>:-&gt;:</span> <span>β</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
        <span>t2'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>α</span> <span>t2</span>
        <span>return</span> <span>$</span> <span>Some</span> <span>β</span> <span style="color: red">(</span><span>TApp</span> <span>t1'</span> <span>t2'</span><span style="color: red">)</span>
      <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>Nothing</span></code></pre>
<p>
To infer the type of a <code>let</code>-expression, we infer the type of the definition, infer the type of the body under an extended context, and then desugar it into an application of a lambda. That is, <code>let x = t1 in t2</code> desugars to <code>(\x.t2) t1</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Let</span> <span>x</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>α</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span>Some</span> <span>β</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span style="color: red">(</span><span style="color: red">(</span><span>x</span><span style="color: red">,</span> <span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span> <span>t2</span>
    <span>return</span> <span>$</span> <span>Some</span> <span>β</span> <span style="color: red">(</span><span>TApp</span> <span style="color: red">(</span><span>TLam</span> <span>t2'</span><span style="color: red">)</span> <span>t1'</span><span style="color: red">)</span></code></pre>
<p>
Note again that we can’t accidentally get mixed up here—for example, if we incorrectly desugar to <code>(\x.t1) t2</code> we get a Haskell type error, like this:
</p>
<pre><code>    • Couldn't match type ‘γ’ with ‘α : γ’
      Expected: TTerm γ α1
        Actual: TTerm (α : γ) α1</code></pre>
<p>
To infer an <code>if</code>-expression, we can check that the test has type <code>Bool</code>, infer the types of the two branches, and ensure that they are the same. If so, we return the <code>CIf</code> constant applied to the three arguments. The reason this typechecks is that pattern-matching on the <code>Refl</code> from the <code>testEquality</code> call brings into scope the fact that the types of <code>t2</code> and <code>t3</code> are equal, so we can apply <code>CIf</code> which requires them to be so.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>If</span> <span>t1</span> <span>t2</span> <span>t3</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>t1'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyBool</span> <span>t1</span>
    <span>Some</span> <span>α</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t2</span>
    <span>Some</span> <span>β</span> <span>t3'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t3</span>
    <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
      <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span>return</span> <span>$</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>CIf</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span> <span>&#36;&#36;</span> <span>t3'</span><span style="color: red">)</span></code></pre>
<p>
Addition is simple; we just check that both arguments have type <code>Int</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Add</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>t1'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyInt</span> <span>t1</span>
    <span>t2'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyInt</span> <span>t2</span>
    <span>return</span> <span>$</span> <span>Some</span> <span>TTyInt</span> <span style="color: red">(</span><span>CAdd</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span><span style="color: red">)</span></code></pre>
<p>
“Greater than” is a bit interesting because we allow it to be used at both <code>Int</code> and <code>Bool</code>. So, just as with <code>if</code>, we must infer the types of the arguments and check that they match. But then we must also use the <code>checkOrd</code> function to ensure that the argument types are an instance of <code>Ord</code>. In particular, we wrap <code>CGt</code> (which requires an <code>Ord</code> constraint) in a call to <code>checkOrd α</code> (which provides one).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Gt</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>α</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span>Some</span> <span>β</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t2</span>
    <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
      <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span style="color: red">\</span><span>c</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>TTyBool</span> <span style="color: red">(</span><span>c</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span><span style="color: red">)</span><span style="color: red">)</span> <span>&lt;$&gt;</span> <span>checkOrd</span> <span>α</span> <span>CGt</span></code></pre>
<p>
Finally, here’s the <code>check</code> function: to check that an expression has an expected type, just infer its type and make sure it’s the one we expected. (With more interesting languages we might also have more cases here for terms which can be checked but not inferred.) Notice how this also allows us to return the type-indexed term without using an existential wrapper, since the expected type is an input.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>check</span> <span style="color: red">::</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span>
<span>check</span> <span>ctx</span> <span>α</span> <span>t</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">do</span>
  <span>Some</span> <span>β</span> <span>t'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t</span>
  <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
    <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
    <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span>Just</span> <span>t'</span></code></pre>
<p>
Putting this all together so far, we can check that the <code>example</code> term has type <code>Int</code> and see what it elaborates to (I’ve included a simple pretty-printer for <code>TTerm</code> in an appendix):
</p>
<pre><code>λ&gt; putStrLn . pretty . fromJust . check CNil TTyInt $ example
(λ. (λ. if (gt 7 (x1 (λ. plus x0 3) x0)) x0 (plus x0 1)) 1) (λ. λ. x1 (x1 x0))</code></pre>
<h2 id="an-aside-a-typed-interpreter">
An aside: a typed interpreter
</h2>
<p>
We can now easily write an interpreter. However, this is pretty inefficient (it has to carry around an environment and do linear-time variable lookups), and later we’re going to compile our terms directly to host language terms. So this interpreter is just a nice aside, for fun and testing.
</p>
<p>
With that said, given a closed term, we can interpret it directly to a value of its corresponding host language type. We need typed environments and a indexing function (note that for some reason GHC can’t see that the last case of the indexing function is impossible; if we tried implementing it in, say, Agda, we wouldn’t have to write that case).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Env</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>ENil</span> <span style="color: red">::</span> <span>Env</span> <span style="color: teal">'</span><span>[]</span>
  <span>ECons</span> <span style="color: red">::</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Env</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span>

<span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span style="color: red">::</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span style="color: red">(</span><span>ECons</span> <span>x</span> <span style="color: blue;font-weight: bold">_</span><span style="color: red">)</span> <span>!</span> <span>VZ</span> <span style="color: red">=</span> <span>x</span>
<span style="color: red">(</span><span>ECons</span> <span style="color: blue;font-weight: bold">_</span> <span>e</span><span style="color: red">)</span> <span>!</span> <span style="color: red">(</span><span>VS</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span>e</span> <span>!</span> <span>x</span>
<span>ENil</span> <span>!</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>error</span> <span style="color: teal">"GHC can't tell this is impossible"</span></code></pre>
<p>
Now the interpreter is straightforward. Look how beautifully everything works out with the type indexing.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>interpTTerm</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: teal">'</span><span>[]</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>interpTTerm</span> <span style="color: red">=</span> <span>go</span> <span>ENil</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>go</span> <span style="color: red">::</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
    <span>go</span> <span>e</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
      <span>TVar</span> <span>x</span> <span style="color: red">-&gt;</span> <span>e</span> <span>!</span> <span>x</span>
      <span>TLam</span> <span>body</span> <span style="color: red">-&gt;</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>go</span> <span style="color: red">(</span><span>ECons</span> <span>x</span> <span>e</span><span style="color: red">)</span> <span>body</span>
      <span>TApp</span> <span>f</span> <span>x</span> <span style="color: red">-&gt;</span> <span>go</span> <span>e</span> <span>f</span> <span style="color: red">(</span><span>go</span> <span>e</span> <span>x</span><span style="color: red">)</span>
      <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>interpConst</span> <span>c</span>

<span>interpConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>interpConst</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span>CInt</span> <span>i</span> <span style="color: red">-&gt;</span> <span>i</span>
  <span>CIf</span> <span style="color: red">-&gt;</span> <span style="color: red">\</span><span>b</span> <span>t</span> <span>e</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">if</span> <span>b</span> <span style="color: blue;font-weight: bold">then</span> <span>t</span> <span style="color: blue;font-weight: bold">else</span> <span>e</span>
  <span>CAdd</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>+</span><span style="color: red">)</span>
  <span>CGt</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>&gt;</span><span style="color: red">)</span>
  <span>K</span> <span style="color: red">-&gt;</span> <span>const</span>
  <span>S</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>&lt;*&gt;</span><span style="color: red">)</span>
  <span>I</span> <span style="color: red">-&gt;</span> <span>id</span>
  <span>B</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>.</span><span style="color: red">)</span>
  <span>C</span> <span style="color: red">-&gt;</span> <span>flip</span></code></pre>
<pre><code>λ&gt; interpTTerm . fromJust . check CNil TTyInt $ example
2</code></pre>
<h2 id="compiling-to-combinators-type-indexed-bracket-abstraction">
Compiling to combinators: type-indexed bracket abstraction
</h2>
<p>
Now, on with the main attraction! It’s well-known that certain sets of <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinators</a> are Turing-complete: for example, <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">SKI is the most well-known complete set</a> (or just SK if you’re trying to be minimal). There are well-known algorithms for compiling lambda calculus terms into combinators, known generally as <em>bracket abstraction</em> (for further reading about bracket abstraction in general, see <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">Diller</a> <span class="citation">(2014)</span>; for some in-depth history along with illustrative Haskell code, see <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">Ben Lynn’s page on Combinatory Logic</a> <span class="citation">(2022)</span>; for nice example implementations in Haskell, see blog posts by <a href="gratzer2015bracket">Gratzer</a> <span class="citation">(2015)</span>, <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Seo</a> <span class="citation">(2016)</span>, and <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">Mahler</a> <span class="citation">(2021)</span>.)
</p>
<p>
So the idea is to compile our typed core language down to combinators. The resulting terms will have <em>no</em> lambdas or variables—only constants and application! The point is that by making environments implicit, with a few more tricks we can make use of the host language runtime’s ability to do beta reduction, which will be <em>much</em> more efficient than our interpreter.
</p>
<p>
The <code>BTerm</code> type below will be the compilation target. Again for illustration and/or debugging we can easily write a direct interpreter for <code>BTerm</code>—but this still isn’t the intended code path. There will still be one more step to convert <code>BTerm</code>s directly into host language terms.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>BTerm</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>BApp</span> <span style="color: red">::</span> <span>BTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>β</span>
  <span>BConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>BTerm</span> <span>ty</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span>BTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">=</span> <span>BApp</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span>BTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>BConst</span>

<span>interpBTerm</span> <span style="color: red">::</span> <span>BTerm</span> <span>ty</span> <span style="color: red">-&gt;</span> <span>ty</span>
<span>interpBTerm</span> <span style="color: red">(</span><span>BApp</span> <span>f</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span>interpBTerm</span> <span>f</span> <span style="color: red">(</span><span>interpBTerm</span> <span>x</span><span style="color: red">)</span>
<span>interpBTerm</span> <span style="color: red">(</span><span>BConst</span> <span>c</span><span style="color: red">)</span> <span style="color: red">=</span> <span>interpConst</span> <span>c</span></code></pre>
<p>
We will use the usual SKI combinators as well as <code>B</code> and <code>C</code>, which are like special-case variants of <code>S</code>:
</p>
<ul>
<li>
<code>S x y z = x z (y z)</code>
</li>
<li>
<code>B x y z = x (y z)</code>
</li>
<li>
<code>C x y z = x z (y )</code>
</li>
</ul>
<p>
<code>S</code> handles the application of <code>x</code> to <code>y</code> in the case where they both need access to a shared parameter <code>z</code>; <code>B</code> and <code>C</code> are similar, but <code>B</code> is used when only <code>y</code>, and not <code>x</code>, needs access to <code>z</code>, and <code>C</code> is for when only <code>x</code> needs access to <code>z</code>. Using <code>B</code> and <code>C</code> will allow for more efficient encodings than would be possible with <code>S</code> alone. If you want to compile a language with recursion you can also easily add the usual <code>Y</code> combinator (“<code>SICKBY</code>”), although the example language in this post has no recursion so we won’t use it.
</p>
<p>
Bracket abstraction is often presented in an untyped way, but I found this <a href="http://okmij.org/ftp/tagless-final/ski.pdf">really cool paper by Oleg Kiselyov</a> <span class="citation">(2018)</span> where he shows how to do bracket abstraction in a completely compositional, type-indexed way. I found the paper a bit hard to understand, but fortunately it came with <a href="http://okmij.org/ftp/tagless-final/skconv.ml">working OCaml code</a>! Translating it to Haskell was straightforward. Much later, after writing most of this blog post, I found a <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">a nice explanation of Kiselyov’s paper</a> by <span class="citation">Lynn (2022)</span> which helped me make more sense of the paper.
</p>
<p>
First, a data type for open terms, which represent an intermediate stage in the bracket abstraction algorithm, where some parts have been converted to closed combinator terms (the <code>E</code> constructor embeds <code>BTerm</code> values), and some parts still have not. This corresponds to Kiselyov’s eta-optimized version (section 4.1 of the paper). A simplified version that does not include <code>V</code> is possible, but results in longer combinator expressions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>OTerm</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>

  <span style="color: green">-- E contains embedded closed (i.e. already abstracted) terms.</span>
  <span>E</span> <span style="color: red">::</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span>

  <span style="color: green">-- V represents a reference to the innermost/top environment</span>
  <span style="color: green">-- variable, i.e. Z</span>
  <span>V</span> <span style="color: red">::</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>

  <span style="color: green">-- N represents internalizing the innermost bound variable as a</span>
  <span style="color: green">-- function argument. In other words, we can represent an open</span>
  <span style="color: green">-- term referring to a certain variable as a function which</span>
  <span style="color: green">-- takes that variable as an argument.</span>
  <span>N</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span>

  <span style="color: green">-- For efficiency, there is also a special variant of N for the</span>
  <span style="color: green">-- case where the term does not refer to the topmost variable at</span>
  <span style="color: green">-- all.</span>
  <span>W</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span>β</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span style="color: red">(</span><span>OTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>E</span> <span>.</span> <span>embed</span></code></pre>
<p>
Now for the bracket abstraction algorithm. First, a function to do type- and environment-preserving conversion from <code>TTerm</code> to <code>OTerm</code>. The <code>conv</code> function handles the variable, lambda, and constant cases. The application case is handled by the <code>Applicable</code> instance.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>conv</span> <span style="color: red">::</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span>
<span>conv</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span>TVar</span> <span>VZ</span> <span style="color: red">-&gt;</span> <span>V</span>
  <span>TVar</span> <span style="color: red">(</span><span>VS</span> <span>x</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>W</span> <span style="color: red">(</span><span>conv</span> <span style="color: red">(</span><span>TVar</span> <span>x</span><span style="color: red">)</span><span style="color: red">)</span>
  <span>TLam</span> <span>t</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">case</span> <span>conv</span> <span>t</span> <span style="color: blue;font-weight: bold">of</span>
    <span>V</span> <span style="color: red">-&gt;</span> <span>E</span> <span style="color: red">(</span><span>embed</span> <span>I</span><span style="color: red">)</span>
    <span>E</span> <span>d</span> <span style="color: red">-&gt;</span> <span>E</span> <span style="color: red">(</span><span>K</span> <span>.&#36;&#36;</span> <span>d</span><span style="color: red">)</span>
    <span>N</span> <span>e</span> <span style="color: red">-&gt;</span> <span>e</span>
    <span>W</span> <span>e</span> <span style="color: red">-&gt;</span> <span>K</span> <span>.&#36;&#36;</span> <span>e</span>
  <span>TApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>conv</span> <span>t1</span> <span>&#36;&#36;</span> <span>conv</span> <span>t2</span>
  <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>embed</span> <span>c</span></code></pre>
<p>
The <code>Applicable</code> instance for <code>OTerm</code> has 15 cases—one for each combination of <code>OTerm</code> constructors. Why not 16, you ask? Because the <code>V $$ V</code> case is impossible (exercise for the reader: why?). The cool thing is that GHC can tell that case would be ill-typed, and agrees that this definition is total—that is, it does not give a non-exhaustive pattern match warning. This is a lot of code, but understanding each individual case is not too hard if you understand the meaning of the constructors <code>E</code>, <code>V</code>, <code>N</code>, and <code>W</code>. For example, if we have one term that ignores the innermost bound variable being applied to another term that also ignores the innermost bound variable (<code>W e1 $$ W e2</code>), we can apply one term to the other and wrap the result in <code>W</code> again (<code>W (e1 $$ e2)</code>). Other cases use the combinators <code>B</code>, <code>C</code>, <code>S</code> to route the input to the proper places in an application.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span style="color: red">(</span><span>OTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>β</span>
  <span>W</span> <span>e1</span> <span>&#36;&#36;</span> <span>W</span> <span>e2</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>W</span> <span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>W</span> <span>e</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>W</span> <span>e</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span>e</span>
  <span>V</span> <span>&#36;&#36;</span> <span>W</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>I</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>W</span> <span>e1</span> <span>&#36;&#36;</span> <span>N</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>B</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e1</span> <span>&#36;&#36;</span> <span>W</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e1</span> <span>&#36;&#36;</span> <span>N</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;</span> <span>e</span> <span>&#36;&#36;.</span> <span>I</span><span style="color: red">)</span>
  <span>V</span> <span>&#36;&#36;</span> <span>N</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;.</span> <span>I</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>N</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>B</span> <span>.&#36;&#36;</span> <span>d</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span>d</span><span style="color: red">)</span>
  <span>V</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>I</span> <span>&#36;&#36;</span> <span>d</span><span style="color: red">)</span><span style="color: red">)</span>
  <span>N</span> <span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>C</span> <span>&#36;&#36;</span> <span>d</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d1</span> <span>&#36;&#36;</span> <span>E</span> <span>d2</span> <span style="color: red">=</span> <span>E</span> <span style="color: red">(</span><span>d1</span> <span>&#36;&#36;</span> <span>d2</span><span style="color: red">)</span></code></pre>
<p>
The final bracket abstraction algorithm consists of calling <code>conv</code> on a closed <code>TTerm</code>—this must result in a term of type <code>OTerm ’[] α</code>, and the only constructor which could possibly produce such a type is <code>E</code>, containing an embedded <code>BTerm</code>. So we can just extract that <code>BTerm</code>, and GHC can see that this is total.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>bracket</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: teal">'</span><span>[]</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span>
<span>bracket</span> <span>t</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span>conv</span> <span>t</span> <span style="color: blue;font-weight: bold">of</span> <span style="color: red">{</span> <span>E</span> <span>t'</span> <span style="color: red">-&gt;</span> <span>t'</span> <span style="color: red">}</span></code></pre>
<p>
Let’s apply this to our <code>example</code> term and see what we get:
</p>
<pre><code>λ&gt; putStrLn . pretty . bracket . fromJust . check CNil TTyInt $ example
C C 1 (C C (C C 1 plus) (B S (C C I (B S (B (B if) (B (B (gt 7)) (C I (C C 3 plus)))))))) (S B I)
λ&gt; interpBTerm . bracket . fromJust . check CNil TTyInt $ example
2</code></pre>
<p>
Neat! This is not too much longer than the original term, which is the point of using the optimized version. Interestingly, this example happens to not use <code>K</code> at all, but a more complex term certainly would.
</p>
<p>
Kiselyov also presents an even better algorithm using <span class="math inline">\(n\)</span>-ary combinators which uses guaranteed linear time and space. For simplicity, he presents it in an untyped way and claims in passing that it “can be backported to the typed case”, though I am not aware of anyone who has actually done this yet (perhaps I will, later). <span class="citation">Lynn (2022)</span> has <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">a nice explanation of Kiselyov’s paper</a>, including a section that explores several alternatives to Kiselyov’s linear-time algorithm.
</p>
<h2 id="compiling-type-indexed-combinators-to-haskell">
Compiling type-indexed combinators to Haskell
</h2>
<p>
So at this point we can take a <code>Term</code>, typecheck it to produce a <code>TTerm</code>, then use bracket abstraction to convert that to a <code>BTerm</code>. We have an interpreter for <code>BTerm</code>s, but we’re instead going to do one more compilation step, to turn <code>BTerm</code>s directly into native Haskell values. This idea originates with <span class="citation">Naylor (2008)</span> and is well-explained in blog posts by <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Seo</a> <span class="citation">(2016)</span> and <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">Mahler</a> <span class="citation">(2022)</span>. This still feels a little like black magic to me, and I am actually unclear on whether it is really faster than calling <code>interpBTerm</code>; some benchmarking would be needed. In any case I include it here for completeness.
</p>
<p>
Our target for this final compilation step is the following <code>CTerm</code> type, which has only functions, represented by <code>CFun</code>, and constants. Note, however, that <code>CConst</code> is intended to be used only for non-function types, <em>i.e.</em> base types, although there’s no nice way (that I know of, at least) to use the Haskell type system to enforce this.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>CTerm</span> <span>α</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CFun</span> <span style="color: red">::</span> <span style="color: red">(</span><span>CTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>
  <span>CConst</span> <span style="color: red">::</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span> <span style="color: green">-- CConst invariant: α is not a function type</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span>CTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CFun</span> <span>f</span> <span>&#36;&#36;</span> <span>x</span> <span style="color: red">=</span> <span>f</span> <span>x</span>
  <span>CConst</span> <span style="color: blue;font-weight: bold">_</span> <span>&#36;&#36;</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>error</span> <span style="color: teal">"CConst should never contain a function!"</span>

<span>compile</span> <span style="color: red">::</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span>
<span>compile</span> <span style="color: red">(</span><span>BApp</span> <span>b1</span> <span>b2</span><span style="color: red">)</span> <span style="color: red">=</span> <span>compile</span> <span>b1</span> <span>&#36;&#36;</span> <span>compile</span> <span>b2</span>
<span>compile</span> <span style="color: red">(</span><span>BConst</span> <span>c</span><span style="color: red">)</span> <span style="color: red">=</span> <span>compileConst</span> <span>c</span>

<span>compileConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span>
<span>compileConst</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span style="color: red">(</span><span>CInt</span> <span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CConst</span> <span>i</span>
  <span>CIf</span>      <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>t</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>e</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">if</span> <span>b</span> <span style="color: blue;font-weight: bold">then</span> <span>t</span> <span style="color: blue;font-weight: bold">else</span> <span>e</span>
  <span>CAdd</span>     <span style="color: red">-&gt;</span> <span>binary</span> <span style="color: red">(</span><span>+</span><span style="color: red">)</span>
  <span>CGt</span>      <span style="color: red">-&gt;</span> <span>binary</span> <span style="color: red">(</span><span>&gt;</span><span style="color: red">)</span>
  <span>K</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>x</span>
  <span>S</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>g</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span>x</span> <span>&#36;&#36;</span> <span style="color: red">(</span><span>g</span> <span>&#36;&#36;</span> <span>x</span><span style="color: red">)</span>
  <span>I</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>id</span>
  <span>B</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>g</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span style="color: red">(</span><span>g</span> <span>&#36;&#36;</span> <span>x</span><span style="color: red">)</span>
  <span>C</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>y</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span>y</span> <span>&#36;&#36;</span> <span>x</span>

<span>binary</span> <span style="color: red">::</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
<span>binary</span> <span>op</span> <span style="color: red">=</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>x</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>y</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CConst</span> <span style="color: red">(</span><span>op</span> <span>x</span> <span>y</span><span style="color: red">)</span></code></pre>
<p>
Finally, we can “run” a <code>CTerm α</code> to extract a value of type <code>α</code>. Typically, if <code>α</code> is some kind of base type like <code>Int</code>, <code>runCTerm</code> doesn’t actually do any work—all the work is done by the Haskell runtime itself. However, for completeness, I include a case for <code>CFun</code> as well.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>runCTerm</span> <span style="color: red">::</span> <span>CTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>runCTerm</span> <span style="color: red">(</span><span>CConst</span> <span>a</span><span style="color: red">)</span> <span style="color: red">=</span> <span>a</span>
<span>runCTerm</span> <span style="color: red">(</span><span>CFun</span> <span>f</span><span style="color: red">)</span> <span style="color: red">=</span> <span>runCTerm</span> <span>.</span> <span>f</span> <span>.</span> <span>CConst</span></code></pre>
<p>
We can put this all together into our final pipeline:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>evalInt</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>Int</span>
<span>evalInt</span> <span style="color: red">=</span> <span>fmap</span> <span style="color: red">(</span><span>runCTerm</span> <span>.</span> <span>compile</span> <span>.</span> <span>bracket</span><span style="color: red">)</span> <span>.</span> <span>check</span> <span>CNil</span> <span>TTyInt</span></code></pre>
<pre><code>λ&gt; evalInt example
Just 2</code></pre>
<h1 id="appendices">
Appendices
</h1>
<p>
There’s nothing interesting to see here—unless you’ve never written a parser or pretty-printer before, in which case perhaps it is very interesting! If you want to learn how to write parsers, see <a href="https://markkarpov.com/tutorial/megaparsec.html">this very nice Megaparsec tutorial</a>. And <a href="https://hendrix-cs.github.io/csci360/modules/05-pretty-parse.html">see here for some help writing a basic pretty-printer</a>.
</p>
<h2 id="parsing">
Parsing
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>Parser</span> <span style="color: red">=</span> <span>Parsec</span> <span>Void</span> <span>Text</span>
<span style="color: blue;font-weight: bold">type</span> <span>ParserError</span> <span style="color: red">=</span> <span>ParseErrorBundle</span> <span>Text</span> <span>Void</span>

<span>reservedWords</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Text</span><span style="color: red">]</span>
<span>reservedWords</span> <span style="color: red">=</span> <span style="color: red">[</span><span style="color: teal">"let"</span><span style="color: red">,</span> <span style="color: teal">"in"</span><span style="color: red">,</span> <span style="color: teal">"if"</span><span style="color: red">,</span> <span style="color: teal">"then"</span><span style="color: red">,</span> <span style="color: teal">"else"</span><span style="color: red">,</span> <span style="color: teal">"Int"</span><span style="color: red">,</span> <span style="color: teal">"Bool"</span><span style="color: red">]</span>

<span>sc</span> <span style="color: red">::</span> <span>Parser</span> <span>()</span>
<span>sc</span> <span style="color: red">=</span> <span>L.space</span> <span>space1</span> <span style="color: red">(</span><span>L.skipLineComment</span> <span style="color: teal">"--"</span><span style="color: red">)</span> <span>empty</span>

<span>lexeme</span> <span style="color: red">::</span> <span>Parser</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>a</span>
<span>lexeme</span> <span style="color: red">=</span> <span>L.lexeme</span> <span>sc</span>

<span>symbol</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>Text</span>
<span>symbol</span> <span style="color: red">=</span> <span>L.symbol</span> <span>sc</span>

<span>reserved</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>()</span>
<span>reserved</span> <span>w</span> <span style="color: red">=</span> <span style="color: red">(</span><span>lexeme</span> <span>.</span> <span>try</span><span style="color: red">)</span> <span>$</span> <span>string'</span> <span>w</span> <span>*&gt;</span> <span>notFollowedBy</span> <span>alphaNumChar</span>

<span>identifier</span> <span style="color: red">::</span> <span>Parser</span> <span>Text</span>
<span>identifier</span> <span style="color: red">=</span> <span style="color: red">(</span><span>lexeme</span> <span>.</span> <span>try</span><span style="color: red">)</span> <span style="color: red">(</span><span>p</span> <span>&gt;&gt;=</span> <span>nonReserved</span><span style="color: red">)</span> <span>&lt;?&gt;</span> <span style="color: teal">"variable name"</span>
 <span style="color: blue;font-weight: bold">where</span>
  <span>p</span> <span style="color: red">=</span> <span style="color: red">(</span><span>:</span><span style="color: red">)</span> <span>&lt;$&gt;</span> <span>letterChar</span> <span>&lt;*&gt;</span> <span>many</span> <span>alphaNumChar</span>
  <span>nonReserved</span> <span style="color: red">(</span><span>into</span> <span style="color: red">@</span><span>Text</span> <span style="color: red">-&gt;</span> <span>t</span><span style="color: red">)</span>
    <span style="color: red">|</span> <span>t</span> <span>`elem`</span> <span>reservedWords</span> <span style="color: red">=</span>
        <span>fail</span> <span>.</span> <span>into</span> <span style="color: red">@</span><span>String</span> <span>$</span>
          <span>T.concat</span> <span style="color: red">[</span><span style="color: teal">"reserved word '"</span><span style="color: red">,</span> <span>t</span><span style="color: red">,</span> <span style="color: teal">"' cannot be used as variable name"</span><span style="color: red">]</span>
    <span style="color: red">|</span> <span>otherwise</span> <span style="color: red">=</span> <span>return</span> <span>t</span>

<span>integer</span> <span style="color: red">::</span> <span>Parser</span> <span>Int</span>
<span>integer</span> <span style="color: red">=</span> <span>lexeme</span> <span>L.decimal</span>

<span>parens</span> <span style="color: red">::</span> <span>Parser</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>a</span>
<span>parens</span> <span style="color: red">=</span> <span>between</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"("</span><span style="color: red">)</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">")"</span><span style="color: red">)</span>

<span>parseTermAtom</span> <span style="color: red">::</span> <span>Parser</span> <span>Term</span>
<span>parseTermAtom</span> <span style="color: red">=</span>
      <span>Lit</span> <span>&lt;$&gt;</span> <span>integer</span>
  <span>&lt;|&gt;</span> <span>Var</span> <span>&lt;$&gt;</span> <span>identifier</span>
  <span>&lt;|&gt;</span> <span>Lam</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"\\"</span> <span>*&gt;</span> <span>identifier</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">":"</span> <span>*&gt;</span> <span>parseType</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"."</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>Let</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"let"</span> <span>*&gt;</span> <span>identifier</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"="</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"in"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>If</span>  <span>&lt;$&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"if"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"then"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"else"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>parens</span> <span>parseTerm</span>

<span>parseTerm</span> <span style="color: red">::</span> <span>Parser</span> <span>Term</span>
<span>parseTerm</span> <span style="color: red">=</span> <span>makeExprParser</span> <span>parseTermAtom</span>
  <span style="color: red">[</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>App</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">""</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">,</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>Add</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"+"</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">,</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>Gt</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"&gt;"</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">]</span>

<span>parseTypeAtom</span> <span style="color: red">::</span> <span>Parser</span> <span>Ty</span>
<span>parseTypeAtom</span> <span style="color: red">=</span>
  <span>TyInt</span> <span>&lt;$</span> <span>reserved</span> <span style="color: teal">"Int"</span>
  <span>&lt;|&gt;</span> <span>TyBool</span> <span>&lt;$</span> <span>reserved</span> <span style="color: teal">"Bool"</span>
  <span>&lt;|&gt;</span> <span>parens</span> <span>parseType</span>

<span>parseType</span> <span style="color: red">::</span> <span>Parser</span> <span>Ty</span>
<span>parseType</span> <span style="color: red">=</span> <span>makeExprParser</span> <span>parseTypeAtom</span>
  <span style="color: red">[</span> <span style="color: red">[</span><span>InfixR</span> <span style="color: red">(</span><span>TyFun</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"-&gt;"</span><span style="color: red">)</span><span style="color: red">]</span> <span style="color: red">]</span>

<span>readTerm</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span>
<span>readTerm</span> <span style="color: red">=</span> <span>either</span> <span>undefined</span> <span>id</span> <span>.</span> <span>runParser</span> <span>parseTerm</span> <span style="color: teal">""</span></code></pre>
<h2 id="pretty-printing">
Pretty-printing
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>Prec</span> <span style="color: red">=</span> <span>Int</span>

<span style="color: blue;font-weight: bold">class</span> <span>Pretty</span> <span>p</span> <span style="color: blue;font-weight: bold">where</span>
  <span>pretty</span> <span style="color: red">::</span> <span>p</span> <span style="color: red">-&gt;</span> <span>String</span>
  <span>pretty</span> <span style="color: red">=</span> <span>prettyPrec</span> <span class="hs-num">0</span>

  <span>prettyPrec</span> <span style="color: red">::</span> <span>Prec</span> <span style="color: red">-&gt;</span> <span>p</span> <span style="color: red">-&gt;</span> <span>String</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>pretty</span>

<span>mparens</span> <span style="color: red">::</span> <span>Bool</span> <span style="color: red">-&gt;</span> <span>String</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>mparens</span> <span>True</span>  <span style="color: red">=</span> <span style="color: red">(</span><span style="color: teal">"("</span><span>++</span><span style="color: red">)</span> <span>.</span> <span style="color: red">(</span><span>++</span><span style="color: teal">")"</span><span style="color: red">)</span>
<span>mparens</span> <span>False</span> <span style="color: red">=</span> <span>id</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>Const</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>CInt</span> <span>i</span> <span style="color: red">-&gt;</span> <span>show</span> <span>i</span>
    <span>CIf</span> <span style="color: red">-&gt;</span> <span style="color: teal">"if"</span>
    <span>CAdd</span> <span style="color: red">-&gt;</span> <span style="color: teal">"plus"</span>
    <span>CGt</span>  <span style="color: red">-&gt;</span> <span style="color: teal">"gt"</span>
    <span>c</span> <span style="color: red">-&gt;</span> <span>show</span> <span>c</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span style="color: red">(</span><span style="color: teal">"x"</span> <span>++</span><span style="color: red">)</span> <span>.</span> <span>show</span> <span>.</span> <span>toNat</span>
    <span style="color: blue;font-weight: bold">where</span>
      <span>toNat</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Int</span>
      <span>toNat</span> <span>VZ</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span>toNat</span> <span style="color: red">(</span><span>VS</span> <span>i</span><span style="color: red">)</span> <span style="color: red">=</span> <span class="hs-num">1</span> <span>+</span> <span>toNat</span> <span>i</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span>p</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>TVar</span> <span>x</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>x</span>
    <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>c</span>
    <span>TLam</span> <span>t</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">0</span><span style="color: red">)</span> <span>$</span> <span style="color: teal">"λ. "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">0</span> <span>t</span>
    <span>TApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">1</span><span style="color: red">)</span> <span>$</span>
      <span>prettyPrec</span> <span class="hs-num">1</span> <span>t1</span> <span>++</span> <span style="color: teal">" "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">2</span> <span>t2</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>BTerm</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span>p</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>BConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>c</span>
    <span>BApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">0</span><span style="color: red">)</span> <span>$</span>
      <span>prettyPrec</span> <span class="hs-num">0</span> <span>t1</span> <span>++</span> <span style="color: teal">" "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">1</span> <span>t2</span></code></pre>
<h1 class="unnumbered" id="references">
References
</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-augustsson1986small" class="csl-entry" role="doc-biblioentry">
Augustsson, L. (1986) <em>SMALL: A small interactive functional system</em>. Chalmers Tekniska H<span>ö</span>gskola/G<span>ö</span>teborgs Universitet. Programming Methodology Group.
</div>
<div id="ref-diller1988compiling" class="csl-entry" role="doc-biblioentry">
Diller, A. (1988) <em>Compiling functional languages</em>. John Wiley &amp; Sons, Inc.
</div>
<div id="ref-diller2014bracket" class="csl-entry" role="doc-biblioentry">
Diller, A. (2014) <em><span class="nocase">Bracket abstraction algorithms</span></em>. Available at: <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">https://www.cantab.net/users/antoni.diller/brackets/intro.html</a>.
</div>
<div id="ref-elliott2017compiling" class="csl-entry" role="doc-biblioentry">
Elliott, C. (2017) <span>‘Compiling to categories’</span>, <em>Proceedings of the ACM on Programming Languages</em>, 1(ICFP), pp. 1–27.
</div>
<div id="ref-gratzer2015bracket" class="csl-entry" role="doc-biblioentry">
Gratzer, D. (2015) <em><span class="nocase">Bracket Abstraction: The Smallest PL You’ve Ever Seen</span></em>. Available at: <a href="https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html">https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html</a>.
</div>
<div id="ref-spj1987implementation" class="csl-entry" role="doc-biblioentry">
Jones, S.L.P. (1987) <em><span class="nocase">The Implementation of Functional Programming Languages</span></em>. Prentice-Hall, Inc.
</div>
<div id="ref-kiselyov2018lambda" class="csl-entry" role="doc-biblioentry">
Kiselyov, O. (2018) <span>‘<span class="math inline"><em>λ</em></span> to ski, semantically: Declarative pearl’</span>, in <em>International symposium on functional and logic programming</em>. Springer, pp. 33–50.
</div>
<div id="ref-le2017singletons" class="csl-entry" role="doc-biblioentry">
Le, J. (2017) <em><span class="nocase">Introduction to Singletons (Part 1)</span></em>. Available at: <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">https://blog.jle.im/entry/introduction-to-singletons-1.html</a>.
</div>
<div id="ref-lynncompiler" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2017) <em><span>A Combinatory Compiler</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">https://crypto.stanford.edu/~blynn/lambda/sk.html</a>.
</div>
<div id="ref-lynncl" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2022) <em><span>Combinatory Logic</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">https://crypto.stanford.edu/~blynn/lambda/cl.html</a>.
</div>
<div id="ref-lynnkiselyov" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2022) <em><span>Kiselyov Combinator Translation</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">https://crypto.stanford.edu/~blynn/lambda/kiselyov.html</a>.
</div>
<div id="ref-mahler2021graph" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2021) <em><span class="nocase">Implementing a Functional Language with Graph Reduction</span></em>. Available at: <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html</a>.
</div>
<div id="ref-mahler2021ccc" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2021) <em><span class="nocase">λ-Calculus, Combinatory Logic and Cartesian Closed Categories</span></em>. Available at: <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html</a>.
</div>
<div id="ref-mahler2022evaluating" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2022) <em><span class="nocase">Evaluating SKI combinators as native Haskell functions</span></em>. Available at: <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html</a>.
</div>
<div id="ref-naylor2008evaluating" class="csl-entry" role="doc-biblioentry">
Naylor, M. (2008) <span>‘<span class="nocase">Evaluating Haskell in Haskell</span>’</span>, <em>The Monad.Reader</em>. Edited by W. Swierstra, Issue 10.
</div>
<div id="ref-seo2016interpreter" class="csl-entry" role="doc-biblioentry">
Seo, K.Y. (2016) <em><span class="nocase">Write you an interpreter</span></em>. Available at: <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html</a>.
</div>
<div id="ref-turner1979new" class="csl-entry" role="doc-biblioentry">
Turner, D.A. (1979) <span>‘A new implementation technique for applicative languages’</span>, <em>Software: Practice and Experience</em>, 9(1), pp. 31–49.
</div>
</div>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-07-13T20:55:18Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/07/13/compiling-to-intrinsically-typed-combinators.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: two more DP challenges</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: two more DP challenges</h1>

<div class="info">
  Posted on June 20, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
Continuing the <a href="https://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html">series on dynamic programming</a>, I just have a couple challenge problems for you today. I have indeed solved both of these problems in Haskell, but I don’t yet know how to write <strong>elegant</strong> solutions! There is a reason that the techniques covered in my <a href="https://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html">previous posts</a> aren’t quite good enough.
</p>
<ul>
<li>
<a href="https://open.kattis.com/problems/honi">Honi</a>
</li>
<li>
<a href="https://open.kattis.com/problems/assassins">Assassins</a>
</li>
</ul>
<p>
Feel free to discuss in the comments! I’m hoping that I can learn some new approaches from some of my readers. I will probably post some hints in the comments towards the right recurrences, so don’t look at the comments if you don’t want any spoilers.
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-06-20T20:42:24Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Nested folds</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/17/nested-folds.html</link>
    <description><![CDATA[
<h1>Nested folds</h1>

<div class="info">
  Posted on June 17, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;ADH&#39;." href="/tag/ADH.html" rel="tag">ADH</a>, <a title="All pages tagged &#39;fold&#39;." href="/tag/fold.html" rel="tag">fold</a>, <a title="All pages tagged &#39;fusion&#39;." href="/tag/fusion.html" rel="tag">fusion</a>, <a title="All pages tagged &#39;nested&#39;." href="/tag/nested.html" rel="tag">nested</a>
  
</div>

<section>
<p>
I’m finally getting around to reading <a href="https://www.cs.ox.ac.uk/publications/books/adwh/">Algorithm Design with Haskell</a> (hereafter abbreviated as ADH), by Jeremy Gibbons and Richard Bird. I’ve had it for a while, and I have no excuse for waiting this long to read it, but anyway. I’m enjoying it so far, and wanted to share something I (indirectly) learned. I’m sure there are some who already know this, but I didn’t. I’ll share both the fun takeaway and then also the interesting, roundabout path I took to get there.
</p>
<h2 id="composed-folds-are-nested-folds">
Composed folds are nested folds
</h2>
<p>
Here’s the punchline:
</p>
<ul>
<li>
<code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>
</li>
<li>
<code>foldl . foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [[a]] -&gt; b</code>
</li>
<li>
<code>foldl . foldl . foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [[[a]]] -&gt; b</code>
</li>
</ul>
<p>
Actually, it’s a bit more general than this, since <code>foldl</code> works over any <code>Foldable</code>, not just lists: in fact, <code>foldl . foldl . foldl</code> can be used to fold any <code>t1 (t2 (t3 a))</code> as long as <code>t1</code>, <code>t2</code>, and <code>t3</code> are all instances of <code>Foldable</code>. For example, here is how we can add up all the integers contained in a <code>Maybe (Tree [Int])</code>:
</p>
<pre><code>λ&gt; (foldl . foldl . foldl) (+) 0 (Just (Node [1,2,3] [Node [5,6] [], Node [7] [], Node [9,12] [Node [6] []]]))
51</code></pre>
<p>
We can make sense of this if we look at the type of <code>foldl</code>. Its type is
</p>
<pre><code>Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</code></pre>
<p>
and we usually think of it as taking three arguments: a combining function of type <code>b -&gt; a -&gt; b</code>, an initial value of type <code>b</code>, and a structure to fold. But we can also think of it as a one-argument function. That is, it takes a function of type <code>b -&gt; a -&gt; b</code> and transforms it into a function of type <code>b -&gt; t a -&gt; b</code>:
</p>
<pre><code>foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; (b -&gt; t a -&gt; b)</code></pre>
<p>
Due to the magic of currying this is equivalent, and the second set of parentheses above is redundant. However, with this change of perspective it is easy to see what’s going on: the result of <code>foldl</code> is a function of type <code>b -&gt; t a -&gt; b</code>, which has the right shape to be the argument of <code>foldl</code> again, but this time with <code>t a</code> in place of <code>a</code>, yielding
</p>
<pre><code>(b -&gt; t a -&gt; b) -&gt; (b -&gt; t2 (t a) -&gt; b)</code></pre>
<p>
and so on.
</p>
<p>
What about <code>foldr</code>?
</p>
<pre><code>foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; (b -&gt; t a -&gt; b)</code></pre>
<p>
The shapes of the input and output to <code>foldr</code> don’t quite match, but they will if we throw in an extra <code>flip</code>, which switches the arguments of a two-argument function. So we can either do
</p>
<pre><code>foldr . flip :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; (b -&gt; t a -&gt; b)</code></pre>
<p>
if we want to match the type of <code>foldl</code>, or
</p>
<pre><code>flip . foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; (t a -&gt; b -&gt; b)</code></pre>
<p>
In any case, we can now iterate just as with <code>foldl</code>; for example
</p>
<pre><code>foldr . flip . foldr . flip . foldr :: (a -&gt; b -&gt; b) -&gt; (b -&gt; t1 (t2 (t3 a)) -&gt; b)</code></pre>
<p>
(with some appropriate <code>Foldable</code> constraints thrown in as well).
</p>
<h2 id="my-roundabout-journey">
My roundabout journey
</h2>
<p>
So how did I come to realize this? Sometimes the journey is more interesting than the destination. The first chapter of ADH talks about the <em>foldr fusion rule</em>, which says that
</p>
<pre><code>h . foldr f e == foldr g (h e)</code></pre>
<p>
as long as <code>h (f x y) == g x (h y)</code> for all <code>x</code> and <code>y</code>. In other words, if we have a <code>foldr</code> followed by a function <code>h</code>, we can turn this into a single <code>foldr</code> (<em>i.e.</em> “fuse away” the <code>h</code>) as long as we can find an appropriate function <code>g</code> that satisfies the given criterion.
</p>
<p>
One of the exercises asks us to use <code>foldr</code> fusion to simplify
</p>
<pre><code>foldr f e . concat</code></pre>
<p>
which performs a fold over a nested list by first flattening the list and then doing a fold. You may wish to go try it yourself before reading on!
</p>
<h2 id="the-solution">
The solution
</h2>
<p>
We can compute as follows, where <code>g</code> is some function we will need to define appropriately:
</p>
<pre><code>  foldr f e . concat
=                              { definition of concat }
  foldr f e . foldr (++) []
=                              { foldr fusion law, with h = foldr f e }
  foldr g (foldr f e [])
=                              { definition of foldr }
  foldr g e</code></pre>
<p>
According to the fusion condition, we need <code>g</code> to satisfy <code>foldr f e (x ++ y) == g x (foldr f e y)</code>. This was already given as a previous exercise; I actually solved it by thinking about how <code>foldr</code> works and intuiting the right answer, but we can also calculate it using a second round of <code>foldr</code> fusion:
</p>
<pre><code>  g x (foldr f e y)
=
  foldr f e (x ++ y)
=                              { definition of (++) }
  foldr f e (foldr (:) y x)
=                              { foldr fusion }
  foldr f (foldr f e y) x</code></pre>
<p>
The last equation follows since <code>foldr f e (a : b) = f a (foldr f e b)</code> by definition of <code>foldr</code>. Hence, using <code>z</code> in place of <code>foldr f e y</code>, we have <code>g x z = foldr f z x = flip (foldr f) x z</code>, and so <code>g = flip (foldr f)</code>, and we have
</p>
<pre><code>foldr f e . concat = foldr (flip (foldr f)) e</code></pre>
<p>
We can simplify even further: if we define <code>nestedFold f e = foldr f e . concat = foldr (flip (foldr f)) e</code> then we can eta-reduce to get <code>nestedFold = foldr . flip . foldr</code>.
</p>
<p>
When I derived this, my eyes bugged out and I started playing around with it, which is how I ended up figuring out the thing with <code>foldl</code>. Presumably, one could use the similar <code>foldl</code> fusion law to fuse <code>foldl f e . concat</code> and end up deriving the <code>foldl . foldl</code> result; I’ll leave that as an exercise for interested readers.
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-06-17T21:54:56Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/17/nested-folds.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Dynamic programming in Haskell: automatic memoization</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html</link>
    <description><![CDATA[
<h1>Dynamic programming in Haskell: automatic memoization</h1>

<div class="info">
  Posted on June  6, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
This is part 2 of a <a href="https://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html">promised multi-part series</a> on dynamic programming in Haskell. As a reminder, we’re using <a href="https://open.kattis.com/problems/zapis">Zapis</a> as a sample problem. In this problem, we are given a sequence of opening and closing brackets (parens, square brackets, and curly braces) with question marks, and have to compute the number of different ways in which the question marks could be replaced by brackets to create valid, properly nested bracket sequences.
</p>
<p>
<a href="https://byorgey.github.io/blog/posts/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays.html">Last time</a>, we developed some code to efficiently solve this problem using a mutually recursive pair of a function and a lookup table represented by a lazy, immutable array. This solution is pretty good, but it leaves a few things to be desired:
</p>
<ul>
<li>
It requires defining <em>both</em> a function and a lazy, immutable array, and coming up with names for them.
</li>
<li>
When defining the function, we have to remember to index into the array instead of calling the function recursively, and there is nothing that will warn us if we forget.
</li>
</ul>
<h2 id="an-impossible-dream">
An impossible dream
</h2>
<p>
Wouldn’t it be cool if we could <em>just</em> write the recursive function, and then have some generic machinery make it fast for us by automatically generating a memo table?
</p>
<p>
In other words, we’d like a magic memoization function, with a type something like this:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>memo</span> <span style="color: red">::</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span></code></pre>
<p>
Then we could just define our slow, recursive function normally, wave our magic <code>memo</code> wand over it, and get a fast version for free!
</p>
<p>
This sounds lovely, of course, but there are a few problems:
</p>
<ul>
<li>
<p>
Surely this magic <code>memo</code> function won’t be able to work for <em>any</em> type <code>i</code>. Well, OK, we can add something like an <code>Ix i</code> constraint and/or extra arguments to make sure that values of type <code>i</code> can be used as (or <a href="https://byorgey.github.io/blog/posts/2021/11/17/competitive-programming-in-haskell-bfs-part-4-implementation-via-stuarray.html">converted to</a>) array indices.
</p>
</li>
<li>
<p>
How can <code>memo</code> possibly know how big of a table to allocate? One simple way to solve this would be to provide the table size as an extra explicit argument to <code>memo</code>. (In my next post we’ll also explore some clever things we can do when we don’t know in advance how big of a table we will need.)
</p>
</li>
<li>
<p>
More fundamentally, though, our dream seems impossible: given a function <code>i -&gt; a</code>, the only thing the <code>memo</code> function can do is call it on some input of type <code>i</code>; if the <code>i -&gt; a</code> function is recursive then it will go off and do its recursive thing without ever consulting a memo table, defeating the entire purpose.
</p>
</li>
</ul>
<h2 id="or-is-it">
… or is it?
</h2>
<p>
For now let’s ignore the fact that our dream seems impossible and think about how we could write <code>memo</code>. The idea is to take the given <code>(i -&gt; a)</code> function and first turn it into a lookup table storing a value of type <code>a</code> for each <code>i</code>; then return a new <code>i -&gt; a</code> function which works by just doing a table lookup.
</p>
<p>
From my <a href="https://byorgey.github.io/blog/posts/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays.html">previous post</a> we already have a function to create a table for a given function:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span></code></pre>
<p>
The inverse function, which turns an array back into a function, is just the array indexing operator, with extra parentheses around the <code>i -&gt; a</code> to emphasize the shift in perspective:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span>Array</span> <span>i</span> <span>a</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span></code></pre>
<p>
So we can define <code>memo</code> simply as the composition
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>memo</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span>
<span>memo</span> <span>rng</span> <span style="color: red">=</span> <span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span>.</span> <span>tabulate</span> <span>rng</span></code></pre>
<p>
This is nifty… but as we already saw, it doesn’t help very much… right? For example, let’s define a recursive (slow!) Fibonacci function, and apply <code>memo</code> to it:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE LambdaCase #-}</span>

<span>fib</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>fib</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span class="hs-num">0</span> <span style="color: red">-&gt;</span> <span class="hs-num">0</span>
  <span class="hs-num">1</span> <span style="color: red">-&gt;</span> <span class="hs-num">1</span>
  <span>n</span> <span style="color: red">-&gt;</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>+</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">2</span><span style="color: red">)</span>

<span>fib'</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>fib'</span> <span style="color: red">=</span> <span>memo</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">1000</span><span style="color: red">)</span> <span>fib</span></code></pre>
<p>
As you can see from the following <code>ghci</code> session, calling, say, <code>fib’ 35</code> is still very slow the first time, since it simply calls <code>fib 35</code> which does its usual exponential recursion. However, if we call <code>fib’ 35</code> a second time, we get the answer instantly:
</p>
<pre><code>λ&gt; :set +s
λ&gt; fib' 35
9227465
(4.18 secs, 3,822,432,984 bytes)
λ&gt; fib' 35
9227465
(0.00 secs, 94,104 bytes)</code></pre>
<p>
This is better than nothing, but it’s not really the point. We want it to be fast the <em>first</em> time by looking up <em>intermediate</em> results in the memo table. And trying to call <code>fib’</code> on bigger inputs is still going to be completely hopeless.
</p>
<h2 id="the-punchline">
The punchline
</h2>
<p>
All might seem hopeless at this point, but we actually have everything we need—all we have to do is just <strong>stick the call to <code>memo</code> in the definition of <code>fib</code> itself</strong>!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>fib</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>fib</span> <span style="color: red">=</span> <span>memo</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">1000</span><span style="color: red">)</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span class="hs-num">0</span> <span style="color: red">-&gt;</span> <span class="hs-num">0</span>
  <span class="hs-num">1</span> <span style="color: red">-&gt;</span> <span class="hs-num">1</span>
  <span>n</span> <span style="color: red">-&gt;</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>+</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">2</span><span style="color: red">)</span></code></pre>
<p>
Magically, <code>fib</code> is now fast:
</p>
<pre><code>λ&gt; fib 35
9227465
(0.00 secs, 94,096 bytes)
λ&gt; fib 1000
43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
(0.01 secs, 807,560 bytes)</code></pre>
<p>
This solves all our problems. We only have to write a single definition, which is a directly recursive function, so it’s hard to mess it up. The only thing we have to change is to stick a call to <code>memo</code> (with an appropriate index range) on the front; the whole thing is elegant and short.
</p>
<p>
How does this even work, though? At first glance, it might seem like it will generate a new table with every recursive call to <code>fib</code>, which would obviously be a disaster. However, that’s not what happens: there is only a single, top-level definition of <code>fib</code>, and it is defined as the function which looks up its input in a certain table. Every time we call <code>fib</code> we are calling that same, unique top-level function which is defined in terms of its (unique, top-level) table. So this ends up being equivalent to our previous solution—there is a mutually recursive pair of a function and a lookup table—but written in a much nicer, more compact way that doesn’t require us to explicitly name the table.
</p>
<p>
So here’s our final solution for Zapis. As you can see, the extra code we have to write in order to memoize our recurrence boils down to about five lines (two of which are type signatures and could be omitted). This is definitely a technique worth knowing!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE LambdaCase #-}</span>

<span style="color: blue;font-weight: bold">import</span> <span>Control.Arrow</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Array</span>

<span>main</span> <span style="color: red">=</span> <span>interact</span> <span>$</span> <span>lines</span> <span>&gt;&gt;&gt;</span> <span>last</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>format</span>

<span>format</span> <span style="color: red">::</span> <span>Integer</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>format</span> <span style="color: red">=</span> <span>show</span> <span>&gt;&gt;&gt;</span> <span>reverse</span> <span>&gt;&gt;&gt;</span> <span>take</span> <span class="hs-num">5</span> <span>&gt;&gt;&gt;</span> <span>reverse</span>

<span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span>

<span>memo</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span>
<span>memo</span> <span>rng</span> <span style="color: red">=</span> <span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span>.</span> <span>tabulate</span> <span>rng</span>

<span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>c</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">=</span> <span>memo</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span> <span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
      <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">-&gt;</span> <span class="hs-num">1</span>
        <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">-&gt;</span> <span class="hs-num">0</span>
        <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">-&gt;</span> <span>sum</span>
          <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>j</span><span style="color: red">)</span>
          <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
          <span style="color: red">]</span>

<span>m</span> <span style="color: teal">'('</span> <span style="color: teal">')'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'['</span> <span style="color: teal">']'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'{'</span> <span style="color: teal">'}'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span style="color: teal">'?'</span>                <span style="color: red">=</span> <span class="hs-num">3</span>
<span>m</span> <span>b</span> <span style="color: teal">'?'</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">"([{"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span>b</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">")]}"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span>                    <span style="color: red">=</span> <span class="hs-num">0</span></code></pre>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-06-06T14:21:04Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Dynamic programming in Haskell: lazy immutable arrays</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays.html</link>
    <description><![CDATA[
<h1>Dynamic programming in Haskell: lazy immutable arrays</h1>

<div class="info">
  Posted on June  2, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
This is part 1 of a <a href="https://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html">promised multi-part series</a> on dynamic programming in Haskell. As a reminder, we’re using <a href="https://open.kattis.com/problems/zapis">Zapis</a> as a sample problem. In this problem, we are given a sequence of opening and closing brackets (parens, square brackets, and curly braces) with question marks, and have to compute the number of different ways in which the question marks could be replaced by brackets to create valid, properly nested bracket sequences.
</p>
<p>
<a href="https://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html">Last time</a>, we developed a recurrence for this problem and saw some naive, directly recursive Haskell code for computing it. Although this naive version is technically correct, it is much too slow, so our goal is to implement it more efficiently.
</p>
<h2 id="mutable-arrays">
Mutable arrays?
</h2>
<p>
Someone coming from an imperative background might immediately reach for some kind of mutable array, <em>e.g.</em> <code>STUArray</code>. Every time we call the function, we check whether the corresponding array index has already been filled in. If so, we simply return the stored value; if not, we compute the value recursively, and then fill in the array before returning it.
</p>
<p>
This would work, but there is a better way!
</p>
<h2 id="immutable-arrays">
Immutable arrays
</h2>
<p>
While mutable arrays <a href="https://byorgey.github.io/blog/posts/2021/11/17/competitive-programming-in-haskell-bfs-part-4-implementation-via-stuarray.html">occasionally have their place</a>, we can surprisingly often get away with <em>immutable</em> arrays, where we completely define the array up front and then only use it for fast lookups afterwards.
</p>
<ul>
<li>
If the type of the array elements is suitable, and we can initialize the array elements all at once from a list using some kind of formula, map, scan, <em>etc.</em>, we should use <code>UArray</code> <a href="https://byorgey.github.io/blog/posts/2023/02/24/competitive-programming-in-haskell-infinite-2d-array-level-4.html">since it is much faster</a> than <code>Array</code>.
</li>
<li>
However, <code>UArray</code> is strict in the elements, and the elements must be of a type that can be stored unboxed. If we need a more complex element type, or we need to compute the array recursively (where some elements depend on other elements), we can use <code>Array</code>.
</li>
</ul>
<p>
What about the <a href="http://hackage.haskell.org/package/vector"><code>vector</code> library</a>, you ask? Well, it’s a very nice library, and quite fast, but unfortunately it is not available on many judging platforms, so I tend to stick to <code>array</code> to be safe. However, if you’re doing something like <a href="https://adventofcode.com/">Advent of Code</a> or <a href="https://projecteuler.net/">Project Euler</a> where you get to run the code on your own machine, then you should definitely reach for <code>vector</code>.
</p>
<h2 id="lazy-recursive-immutable-arrays">
Lazy, recursive, immutable arrays
</h2>
<p>
In <a href="https://byorgey.github.io/blog/posts/2023/04/11/competitive-programming-in-haskell-topsort-via-laziness.html">my previous post on topsort</a> we already saw the basic idea: since <code>Array</code>s are lazy in their elements, we can define them recursively; the Haskell runtime then takes care of computing the elements in a suitable order. Previously, we saw this applied to automatically compute a topological sort, but more generally, we can use it to fill out a table of values for any recurrence.
</p>
<p>
So, as a first attempt, let’s just replace our recursive <code>c</code> function from <a href="https://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html">last time</a> with an array. I’ll only show the <code>solve</code> function for now; the rest of the code remains the same. (Spoiler alert: this solution works, but it’s ugly. We’ll develop much better solutions later.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>c</span><span>!</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>c</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
    <span>c</span> <span style="color: red">=</span> <span>array</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span><span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>$</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span><span style="color: red">,</span> <span class="hs-num">1</span><span style="color: red">)</span> <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span> <span style="color: red">]</span>
      <span>++</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span> <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>j</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">]</span>
      <span>++</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">,</span><span>v</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>j</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>i</span> <span>/=</span> <span>j</span><span style="color: red">,</span> <span>even</span> <span>i</span> <span>==</span> <span>even</span> <span>j</span>
      <span style="color: red">,</span> <span style="color: blue;font-weight: bold">let</span> <span>v</span> <span style="color: red">=</span> <span>sum</span> <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span><span>!</span><span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span><span>!</span><span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span> <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span><span style="color: red">]</span>
      <span style="color: red">]</span></code></pre>
<p>
We use the <code>array</code> function to create an array, which takes first a pair of indices specifying the index range, and then a list of (index, value) pairs. (The <code>listArray</code> function can also be particularly useful, when we have a list of values which are already in index order, as in the definition of <code>s</code>.)
</p>
<p>
This solution is accepted, and it’s quite fast (0.04s for me). However, it’s really ugly, and although it’s <em>conceptually</em> close to our directly recursive function from before, the code is almost unrecognizably different. It’s ugly that we have to repeat conditions like <code>i /= j</code> and <code>even i == even j</code>, and binders like <code>i &lt;- [0..n]</code>; the multiple list comprehensions and nested pairs like <code>((i,j),v)</code> are kind of ugly, and the fact that this is implementing a recurrence is completely obscured.
</p>
<p>
However, I included this solution as a first step because for a long time, after I learned about using lazy immutable arrays to implement dynamic programming in Haskell, this was the kind of solution I wrote! Indeed, if you just think about the idea of creating a recursively defined array, this might be the kind of thing you come up with: we define an array <code>c</code> using the <code>array</code> function, then we have to list all its elements, and we get to refer to <code>c</code> along the way.
</p>
<h2 id="mutual-recursion-to-the-rescue">
Mutual recursion to the rescue
</h2>
<p>
Most of the ugliness comes from losing sight of the fact that there is a <em>function</em> mapping indices to values: we simply listed out all the function’s input/output pairs without getting to use any of Haskell’s very nice facilities for defining functions! So we can clean up the code considerably if we make a <em>mutually recursive</em> pair of an array and a function: the array values are defined using the function, and the function definition can look up values in the array.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>cA</span><span>!</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>cA</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
    <span>cA</span> <span style="color: red">=</span> <span>array</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span><span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>$</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">,</span> <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">)</span> <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span> <span style="color: red">..</span> <span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>j</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span> <span style="color: red">..</span> <span>n</span><span style="color: red">]</span> <span style="color: red">]</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">=</span> <span class="hs-num">1</span>
      <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">=</span> <span>sum</span>
        <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
        <span style="color: red">]</span></code></pre>
<p>
Much better! The <code>c</code> function looks much the same as our naive version from before, with the one difference that instead of calling itself recursively, it looks up values in the array <code>cA</code>. The array, in turn, is simply defined as a lookup table for the outputs of the function.
</p>
<h2 id="generalized-tabulation">
Generalized tabulation
</h2>
<p>
One nice trick we can use to simplify the code a bit more is to use the <code>range</code> function to generate the list of all valid array indices, and then just <code>map</code> the <code>c</code> function over this. This also allows us to use the <code>listArray</code> function, since we know that the <code>range</code> will generate the indices in the right order.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>cA</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
<span>cA</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span>$</span> <span>map</span> <span>c</span> <span style="color: red">(</span><span>range</span> <span>rng</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>rng</span> <span style="color: red">=</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span> <span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span></code></pre>
<p>
In fact, we can abstract this into a useful little function to create a lookup table for a function:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span></code></pre>
<p>
(We can generalize this even more to make it work for <code>UArray</code> as well as <code>Array</code>, but I’ll stop here for now. And yes, I intentionally named this to echo the <a href="https://hackage.haskell.org/package/adjunctions-4.4.2/docs/Data-Functor-Rep.html#v:tabulate"><code>tabulate</code> function from the <code>adjunctions</code> package</a>; <code>Array i</code> is indeed a representable functor, though it’s not really possible to express without dependent types.)
</p>
<h2 id="the-solution-so-far">
The solution so far
</h2>
<p>
Putting it all together, here’s our complete solution so far. It’s pretty good, and in fact it’s organized in a very similar way to <a href="https://gist.github.com/meooow25/8d5441fa54e645c8f2a48f91a750d360">Soumik Sarkar’s dynamic programming solution</a> to <a href="https://byorgey.github.io/blog/posts/2023/05/24/competitive-programming-in-haskell-parsing-with-an-nfa.html">Chemist’s Vows</a>. (However, there’s an even better solution coming in my next post!)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">import</span> <span>Control.Arrow</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Array</span>

<span>main</span> <span style="color: red">=</span> <span>interact</span> <span>$</span> <span>lines</span> <span>&gt;&gt;&gt;</span> <span>last</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>format</span>

<span>format</span> <span style="color: red">::</span> <span>Integer</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>format</span> <span style="color: red">=</span> <span>show</span> <span>&gt;&gt;&gt;</span> <span>reverse</span> <span>&gt;&gt;&gt;</span> <span>take</span> <span class="hs-num">5</span> <span>&gt;&gt;&gt;</span> <span>reverse</span>

<span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span>

<span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>cA</span><span>!</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>cA</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
    <span>cA</span> <span style="color: red">=</span> <span>tabulate</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span><span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>c</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">=</span> <span class="hs-num">1</span>
      <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">=</span> <span>sum</span>
        <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
        <span style="color: red">]</span>

<span>m</span> <span style="color: teal">'('</span> <span style="color: teal">')'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'['</span> <span style="color: teal">']'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'{'</span> <span style="color: teal">'}'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span style="color: teal">'?'</span>                <span style="color: red">=</span> <span class="hs-num">3</span>
<span>m</span> <span>b</span> <span style="color: teal">'?'</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">"([{"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span>b</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">")]}"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span>                    <span style="color: red">=</span> <span class="hs-num">0</span></code></pre>
<h2 id="coming-up-next-automatic-memoization">
Coming up next: automatic memoization!
</h2>
<p>
So what’s not to like about this solution? Well, I still don’t like the fact that we have to define a mutually recursive array and function. Conceptually, I want to name them both <code>c</code> (or whatever) since they are really isomorphic representations of the exact same mathematical function. It’s annoying that I have to make up a name like <code>cA</code> or <code>c’</code> or whatever for one of them. I also don’t like that we have to remember to do array lookups instead of recursive calls in the function—and if we forget, Haskell will not complain! It will just be really slow.
</p>
<p>
Next time, we’ll see how to use some clever ideas from Conal Elliot’s <a href="https://hackage.haskell.org/package/MemoTrie"><code>MemoTrie</code> package</a> (which themselves ultimately came from <a href="https://citeseerx.ist.psu.edu/doc/10.1.1.43.3272">a paper by Ralf Hinze</a>) to solve these remaining issues and end up with some really beautiful code!
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-06-02T16:09:44Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>

    </channel>
</rss>
