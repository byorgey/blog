<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>blog :: Brent -> [String]</title>
        <link>http://byorgey.github.io/blog</link>
        <description><![CDATA[Brent Yorgey's academic blog]]></description>
        <atom:link href="http://byorgey.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 09 Sep 2024 00:00:00 UT</lastBuildDate>
        <item>
    <title>Decidable equality for indexed data types</title>
    <link>http://byorgey.github.io/blog/posts/2024/09/09/OneLevelTypesIndexed.lagda.html</link>
    <description><![CDATA[
<h1>Decidable equality for indexed data types</h1>

<div class="info">
  Posted on September  9, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;agda&#39;." href="/tag/agda.html" rel="tag">agda</a>, <a title="All pages tagged &#39;equality&#39;." href="/tag/equality.html" rel="tag">equality</a>, <a title="All pages tagged &#39;indexed&#39;." href="/tag/indexed.html" rel="tag">indexed</a>
  
</div>

<section>
<p>Recently, as part of a larger project, I wanted to define decidable
equality for an indexed data type in Agda. I struggled quite a bit to
figure out the right way to encode it to make Agda happy, and wasn’t
able to find much help online, so I’m recording the results here.</p>
<p>The <strong>tl;dr</strong> is to use mutual recursion to define the indexed data
type along with a sigma type that hides the index, and to use the
sigma type in any recursive positions where we don’t care about the
index! Read on for more motivation and details (and wrong turns I
took along the way).</p>
<p>This post is literate Agda; you can <a href="https://github.com/byorgey/blog/blob/main/posts/2024/09/09/OneLevelTypesIndexed.lagda.md">download it here</a> if you want to play along. I tested everything here with Agda version 2.6.4.3 and version 2.0 of the standard library.</p>
<section id="background" class="level2">
<h2>Background</h2>
<p>First, some imports and a module declaration. Note that the entire
development is parameterized by some abstract set <code>B</code> of base types,
which must have decidable equality.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Product <span class="kw">using</span> <span class="ot">(</span>Σ <span class="ot">;</span> <span class="ot">_</span>×<span class="ot">_</span> <span class="ot">;</span> <span class="ot">_</span>,<span class="ot">_</span> <span class="ot">;</span> -,<span class="ot">_</span> <span class="ot">;</span> proj₁ <span class="ot">;</span> proj₂<span class="ot">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Product<span class="ot">.</span>Properties <span class="kw">using</span> <span class="ot">(</span>≡-dec<span class="ot">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Function <span class="kw">using</span> <span class="ot">(_</span>∘<span class="ot">_)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary <span class="kw">using</span> <span class="ot">(</span>DecidableEquality<span class="ot">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Binary<span class="ot">.</span>PropositionalEquality <span class="kw">using</span> <span class="ot">(_</span>≡<span class="ot">_</span> <span class="ot">;</span> refl<span class="ot">)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Relation<span class="ot">.</span>Nullary<span class="ot">.</span>Decidable <span class="kw">using</span> <span class="ot">(</span>yes<span class="ot">;</span> no<span class="ot">;</span> Dec<span class="ot">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> OneLevelTypesIndexed <span class="ot">(</span>B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>≟B <span class="ot">:</span> DecidableEquality B<span class="ot">)</span> <span class="kw">where</span></span></code></pre></div>
<p>We’ll work with a simple type system containing base types, function
types, and some distinguished type constructor □. So far, this is
just to give some context; it is not the final version of the code we
will end up with, so we stick it in a local module so it won’t end up
in the top-level namespace.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Unindexed <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">:</span> B <span class="ot">→</span> Ty</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> Ty <span class="ot">→</span> Ty <span class="ot">→</span> Ty</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    □<span class="ot">_</span> <span class="ot">:</span> Ty <span class="ot">→</span> Ty</span></code></pre></div>
<p>For example, if <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are base types, then we could write down a
type like <span class="math inline">\(\square ((\square \square X \to Y) \to \square Y)\)</span>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>⇒<span class="ot">_</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">infix</span> <span class="dv">30</span> □<span class="ot">_</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">postulate</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    BX BY <span class="ot">:</span> B</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">:</span> Ty</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">=</span> base BX</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  Y <span class="ot">:</span> Ty</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  Y <span class="ot">=</span> base BY</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  example <span class="ot">:</span> Ty</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  example <span class="ot">=</span> □ <span class="ot">((</span>□ □ X ⇒ Y<span class="ot">)</span> ⇒ □ Y<span class="ot">)</span></span></code></pre></div>
<p>However, for reasons that would take us too far afield in this blog
post, I <em>don’t</em> want to allow immediately nested boxes, like <span class="math inline">\(\square \square X\)</span>. We can still have multiple boxes in a type, and even
boxes nested inside of other boxes, as long as there is at least one
arrow in between. In other words, I only want to rule out boxes
immediately applied to another type with an outermost box. So we
don’t want to allow the example type given above (since it contains
<span class="math inline">\(\square \square X\)</span>), but, for example, <span class="math inline">\(\square ((\square X \to Y) \to \square Y)\)</span> would be OK.</p>
</section>
<section id="encoding-invariants" class="level2">
<h2>Encoding invariants</h2>
<p>How can we encode this invariant so it holds by construction? One way
would be to have two mutually recursive data types, like so:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Mutual <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> UTy <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    □<span class="ot">_</span> <span class="ot">:</span> UTy <span class="ot">→</span> Ty</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    ∙<span class="ot">_</span> <span class="ot">:</span> UTy <span class="ot">→</span> Ty</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> UTy <span class="kw">where</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">:</span> B <span class="ot">→</span> UTy</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> Ty <span class="ot">→</span> Ty <span class="ot">→</span> UTy</span></code></pre></div>
<p><code>UTy</code> consists of types which have no top-level box; the constructors
of <code>Ty</code> just inject <code>UTy</code> into <code>Ty</code> by adding either one or zero
boxes. This works, and defining decidable equality for <code>Ty</code> and <code>UTy</code>
is relatively straightforward (again by mutual recursion). However,
it seemed to me that having to deal with <code>Ty</code> and <code>UTy</code> everywhere
through the rest of the development was probably going to be super
annoying.</p>
<p>The other option would be to index <code>Ty</code> by values indicating whether a
type has zero or one top-level boxes; then we can use the indices to
enforce the appropriate rules. First, we define a data type <code>Boxity</code>
to act as the index for <code>Ty</code>, and show that it has decidable equality:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Boxity <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  [0] <span class="ot">:</span> Boxity</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  [1] <span class="ot">:</span> Boxity</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>Boxity-≟ <span class="ot">:</span> DecidableEquality Boxity</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [0] [0] <span class="ot">=</span> yes refl</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [0] [1] <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [1] [0] <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>Boxity-≟ [1] [1] <span class="ot">=</span> yes refl</span></code></pre></div>
<p>My first attempt to write down a version of <code>Ty</code> indexed by <code>Boxity</code>
looked like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> IndexedTry1 <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> Ty <span class="ot">:</span> Boxity <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">:</span> B <span class="ot">→</span> Ty [0]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>b₁ b₂ <span class="ot">:</span> Boxity<span class="ot">}</span> <span class="ot">→</span> Ty b₁ <span class="ot">→</span> Ty b₂ <span class="ot">→</span> Ty [0]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    □<span class="ot">_</span> <span class="ot">:</span> Ty [0] <span class="ot">→</span> Ty [1]</span></code></pre></div>
<p><code>base</code> always introduces a type with no top-level box; the <code>□</code>
constructor requires a type with no top-level box, and produces a type
with one (this is what ensures we cannot nest boxes); and the arrow
constructor does not care how many boxes its arguments have, but
constructs a type with no top-level box.</p>
<p>This is logically correct, but I found it very difficult to work with.
The sticking point for me was injectivity of the arrow constructor.
When defining decidable equality we need to prove lemmas that each of
the constructors are injective, but I was not even able to write down
the <em>type</em> of injectivity for <code>_⇒_</code>. We would want something like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>⇒<span class="op">-</span>inj <span class="op">:</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  {bσ₁ bσ₂ bτ₁ bτ₂ <span class="op">:</span> <span class="dt">Boxity</span>}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  {σ₁ <span class="op">:</span> <span class="dt">Ty</span> bσ₁} {σ₂ <span class="op">:</span> <span class="dt">Ty</span> bσ₂} {τ₁ <span class="op">:</span> <span class="dt">Ty</span> bτ₁} {τ₂ <span class="op">:</span> <span class="dt">Ty</span> bτ₂} →</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  (σ₁ ⇒ σ₂) ≡ (τ₁ ⇒ τ₂) →</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  (σ₁ ≡ τ₁) × (σ₂ ≡ τ₂)</span></code></pre></div>
<p>but this does not even typecheck! The problem is that, for example,
<code>σ₁</code> and <code>τ₁</code> have different types, so the equality proposition <code>σ₁ ≡ τ₁</code> is not well-typed.</p>
<p>At this point I tried turning to <a href="https://agda.github.io/agda-stdlib/experimental/Relation.Binary.HeterogeneousEquality.html">heterogeneous
equality</a>,
but it didn’t seem to help. I won’t record here all the things I
tried, but the same issues seemed to persist, just pushed around to
different places (for example, I was not able to pattern-match on
witnesses of heterogeneous equality because of types that didn’t
match).</p>
</section>
<section id="sigma-types-to-the-rescue" class="level2">
<h2>Sigma types to the rescue</h2>
<p>At ICFP last week I asked <a href="https://jesper.sikanda.be/">Jesper Cockx</a>
for advice,<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">which felt a bit like asking Rory McIlroy to give some
tips on your mini-golf game<br />
<br />
</span></span> and he suggested trying to prove
decidable equality for the sigma type pairing an index with a type
having that index, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  ΣTy <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  ΣTy <span class="ot">=</span> Σ Boxity Ty</span></code></pre></div>
<p>This turned out to be the key idea, but it still took me a long time
to figure out the right way to make it work. Given the above
definitions, if we go ahead and try to define decidable equality for
<code>ΣTy</code>, injectivity of the arrow constructor is still a problem.</p>
<p>After days of banging my head against this off and on, I finally
realized that the way to solve this is to define <code>Ty</code> and <code>ΣTy</code> by
mutual recursion: the arrow constructor should just take two <code>ΣTy</code>
arguments! This perfectly captures the idea that we <em>don’t care</em>
about the indices of the arrow constructor’s argument types, so we
hide them by bundling them up in a sigma type.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ΣTy <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Ty <span class="ot">:</span> Boxity <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>ΣTy <span class="ot">=</span> Σ Boxity Ty</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Ty <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  □<span class="ot">_</span> <span class="ot">:</span> Ty [0] <span class="ot">→</span> Ty [1]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  base <span class="ot">:</span> B <span class="ot">→</span> Ty [0]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> ΣTy <span class="ot">→</span> ΣTy <span class="ot">→</span> Ty [0]</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>⇒<span class="ot">_</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">30</span> □<span class="ot">_</span></span></code></pre></div>
<p>Now we’re cooking! We now make quick work of the required injectivity
lemmas, which all go through trivially by matching on <code>refl</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>□-inj <span class="ot">:</span> <span class="ot">{</span>τ₁ τ₂ <span class="ot">:</span> Ty [0]<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>□ τ₁ ≡ □ τ₂<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>τ₁ ≡ τ₂<span class="ot">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>□-inj refl <span class="ot">=</span> refl</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>base-inj <span class="ot">:</span> <span class="ot">{</span>b₁ b₂ <span class="ot">:</span> B<span class="ot">}</span> <span class="ot">→</span> base b₁ ≡ base b₂ <span class="ot">→</span> b₁ ≡ b₂</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>base-inj refl <span class="ot">=</span> refl</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>⇒-inj <span class="ot">:</span> <span class="ot">{</span>σ₁ σ₂ τ₁ τ₂ <span class="ot">:</span> ΣTy<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>σ₁ ⇒ σ₂<span class="ot">)</span> ≡ <span class="ot">(</span>τ₁ ⇒ τ₂<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>σ₁ ≡ τ₁<span class="ot">)</span> × <span class="ot">(</span>σ₂ ≡ τ₂<span class="ot">)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>⇒-inj refl <span class="ot">=</span> refl , refl</span></code></pre></div>
<p>Notice how the type of <code>⇒-inj</code> is now perfectly fine: we just have a
bunch of <code>ΣTy</code> values that hide their indices, so we can talk about
propositional equality between them with no trouble.</p>
<p>Finally, we can define decidable equality for <code>Ty</code> and <code>ΣTy</code> by mutual
recursion.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ΣTy-≟ <span class="ot">:</span> DecidableEquality ΣTy</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">{-# TERMINATING #-}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> DecidableEquality <span class="ot">(</span>Ty b<span class="ot">)</span></span></code></pre></div>
<p>Sadly, I had to reassure Agda that the definition of <code>Ty-≟</code> is terminating—more on this later.</p>
<p>To define <code>ΣTy-≟</code> we can just use a lemma from
<code>Data.Product.Properties</code> which derives decidable equality for a sigma
type from decidable equality for both components.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ΣTy-≟ <span class="ot">=</span> ≡-dec Boxity-≟ Ty-≟</span></code></pre></div>
<p>The only thing left is to define decidable equality for any two values
of type <code>Ty b</code> (given a specific boxity <code>b</code>), making use of our
injectivity lemmas; now that we have the right definitions, this falls
out straightforwardly.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>□ σ<span class="ot">)</span> <span class="ot">(</span>□ τ<span class="ot">)</span> <span class="kw">with</span> Ty-≟ σ τ</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> no σ≢τ <span class="ot">=</span> no <span class="ot">(</span>σ≢τ ∘ □-inj<span class="ot">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes refl <span class="ot">=</span> yes refl</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>base x<span class="ot">)</span> <span class="ot">(</span>base y<span class="ot">)</span> <span class="kw">with</span> ≟B x y</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> no x≢y <span class="ot">=</span> no <span class="ot">(</span>x≢y ∘ base-inj<span class="ot">)</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes refl <span class="ot">=</span> yes refl</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>σ₁ ⇒ σ₂<span class="ot">)</span> <span class="ot">(</span>τ₁ ⇒ τ₂<span class="ot">)</span> <span class="kw">with</span> ΣTy-≟ σ₁ τ₁ <span class="ot">|</span> ΣTy-≟ σ₂ τ₂</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> no σ₁≢τ₁ <span class="ot">|</span> <span class="ot">_</span> <span class="ot">=</span> no <span class="ot">(</span>σ₁≢τ₁ ∘ proj₁ ∘ ⇒-inj<span class="ot">)</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes <span class="ot">_</span> <span class="ot">|</span> no σ₂≢τ₂ <span class="ot">=</span> no <span class="ot">(</span>σ₂≢τ₂ ∘ proj₂ ∘ ⇒-inj<span class="ot">)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="ot">...</span> <span class="ot">|</span> yes refl <span class="ot">|</span> yes refl <span class="ot">=</span> yes refl</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(</span>base <span class="ot">_)</span> <span class="ot">(_</span> ⇒ <span class="ot">_)</span> <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>Ty-≟ <span class="ot">(_</span> ⇒ <span class="ot">_)</span> <span class="ot">(</span>base <span class="ot">_)</span> <span class="ot">=</span> no <span class="ot">λ</span> <span class="ot">()</span></span></code></pre></div>
</section>
<section id="final-thoughts" class="level2">
<h2>Final thoughts</h2>
<p>First, the one remaining infelicity is that Agda could not tell that
<code>Ty-≟</code> is terminating. I am not entirely sure why, but I think it may
be that the way the recursion works is just too convoluted for it to
analyze properly: <code>Ty-≟</code> calls <code>ΣTy-≟</code> on structural subterms of its
inputs, but then <code>ΣTy-≟</code> works by providing <code>Ty-≟</code> <em>as a higher-order
parameter</em> to <code>≡-dec</code>. If you look at the definition of <code>≡-dec</code>, all
it does is call its function parameters on structural subterms of its
input, so everything should be nicely terminating, but I guess I am
not surprised that Agda is not able to figure this out. If anyone has
suggestions on how to make this pass the termination checker without
using a <code>TERMINATING</code> pragma, I would love to hear it!</p>
<p>As a final aside, I note that converting back and forth between <code>Ty</code>
(with <code>ΣTy</code> arguments to the arrow constructor) and <code>IndexedTry1.Ty</code>
(with expanded-out <code>Boxity</code> and <code>Ty</code> arguments to arrow) is trivial:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">:</span> <span class="ot">{</span>b <span class="ot">:</span> Boxity<span class="ot">}</span> <span class="ot">→</span> Ty b <span class="ot">→</span> IndexedTry1<span class="ot">.</span>Ty b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">(</span>□ σ<span class="ot">)</span> <span class="ot">=</span> IndexedTry1<span class="ot">.</span>□ <span class="ot">(</span>Ty→Ty1 σ<span class="ot">)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">(</span>base x<span class="ot">)</span> <span class="ot">=</span> IndexedTry1<span class="ot">.</span>base x</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>Ty→Ty1 <span class="ot">((</span>b₁ , σ₁<span class="ot">)</span> ⇒ <span class="ot">(</span>b₂ , σ₂<span class="ot">))</span> <span class="ot">=</span> <span class="ot">(</span>Ty→Ty1 σ₁<span class="ot">)</span> IndexedTry1<span class="ot">.</span>⇒ <span class="ot">(</span>Ty→Ty1 σ₂<span class="ot">)</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">:</span> <span class="ot">{</span>b <span class="ot">:</span> Boxity<span class="ot">}</span> <span class="ot">→</span> IndexedTry1<span class="ot">.</span>Ty b <span class="ot">→</span> Ty b</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">(</span>IndexedTry1<span class="ot">.</span>base x<span class="ot">)</span> <span class="ot">=</span> base x</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">(</span>σ₁ IndexedTry1<span class="ot">.</span>⇒ σ₂<span class="ot">)</span> <span class="ot">=</span> -, <span class="ot">(</span>Ty1→Ty σ₁<span class="ot">)</span> ⇒ -, <span class="ot">(</span>Ty1→Ty σ₂<span class="ot">)</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>Ty1→Ty <span class="ot">(</span>IndexedTry1<span class="ot">.</span>□ σ<span class="ot">)</span> <span class="ot">=</span> □ <span class="ot">(</span>Ty1→Ty σ<span class="ot">)</span></span></code></pre></div>
<p>I expect it is also trivial to prove this is an isomorphism, though
I’m not particularly motivated to do it. The point is that, as anyone
who has spent any time proving things with proof assistants knows, two
types can be completely isomorphic, and yet one can be vastly easier
to work with than the other in certain contexts. Often when I’m
trying to prove something in Agda it feels like at least half the
battle is just coming up with the right representation that makes the
proofs go through easily.</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Decidable equality for indexed data types" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Mon, 09 Sep 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/09/09/OneLevelTypesIndexed.lagda.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: tree path decomposition, part II</title>
    <link>http://byorgey.github.io/blog/posts/2024/08/08/TreeDecomposition.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: tree path decomposition, part II</h1>

<div class="info">
  Posted on August  8, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;tree&#39;." href="/tag/tree.html" rel="tag">tree</a>, <a title="All pages tagged &#39;path&#39;." href="/tag/path.html" rel="tag">path</a>, <a title="All pages tagged &#39;decomposition&#39;." href="/tag/decomposition.html" rel="tag">decomposition</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">a previous
post</a>
I discussed the first half of my solution to <a href="https://open.kattis.com/problems/factorfulltree">Factor-Full
Tree</a>. In this post,
I will demonstrate how to <em>decompose a tree into disjoint paths</em>.
<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Technically, we should clarify that we are looking for <em>directed</em>
paths in a rooted tree, that is, paths that only proceed down the
tree. One could also ask about decomposing an unrooted tree into
disjoint undirected paths; I haven’t thought about how to do that in
general but intuitively I expect it is not too much more difficult.<br />
<br />
</span></span> For
this particular problem, we want to decompose a tree into
<em>maximum-length</em> paths (<em>i.e.</em> we start by taking the longest possible
path, then take the longest path from what remains, and so on); I will call
this the <em>max-chain decomposition</em> (I don’t know if there is a
standard term). However, there are other types of path
decomposition, such as heavy-light decomposition, so we will try to
keep the decomposition code somewhat generic.</p>
<section id="preliminaries" class="level2">
<h2>Preliminaries</h2>
<p>This post is literate Haskell; you can <a href="https://github.com/byorgey/blog/blob/main/posts/2024/08/08/TreeDecomposition.lhs">find the source code on GitHub</a>.
We begin with some language pragmas and imports.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">TreeDecomposition</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;), (***))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (second)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> (<span class="dt">ByteString</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">NE</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>, (!), (!?))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ord</span> (<span class="dt">Down</span>(..), comparing)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tree</span> (<span class="dt">Tree</span>(..), foldTree)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> (swap)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ScannerBS</span></span></code></pre></div>
<p><a href="https://github.com/byorgey/comprog-hs/blob/master/ScannerBS.hs">See here for the <code>ScannerBS</code> module</a>.</p>
</section>
<section id="generic-path-decomposition" class="level2">
<h2>Generic path decomposition</h2>
<p>Remember, our goal is to split up a tree into a collection of linear
paths; that is, in general, something like this:</p>
<figure>
<img src="/diagrams/0ff41d66358cc1f5.svg" />
</figure>
<p>What do we need in order to specify a decomposition of a
tree into disjoint paths this way? Really, all we need is to choose <em>at most
one linked child</em> for each node. In other words, at every node we can
choose to continue the current path into a single child node (in which
case all the other children will start their own new paths), or we
could choose to terminate the current path (in which case every child
will be the start of its own new path). We can represent such a
choice with a function of type</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SubtreeSelector</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, [<span class="dt">Tree</span> a])</span></code></pre></div>
<p>which takes as input the value at a node and the list of all the
subtrees, and possibly returns a selected subtree along with the list of remaining
subtrees.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">Of course, there is nothing in the
type that actually requires a <code>SubtreeSelector</code> to return one of the
trees from its input paired with the rest, but nothing we will do
depends on this being true. In fact, I expect there may be some
interesting algorithms obtainable by running a “path decomposition”
with a “selector” function that actually makes up new trees instead of just
selecting one, similar to <a href="https://hackage.haskell.org/package/split-0.2.5/docs/Data-List-Split.html#v:chop">the <code>chop</code> function</a>.<br />
<br />
</span></span></p>
<p>Given such a subtree selection function, a generic path decomposition
function will then take a tree and turn it into a list of non-empty
paths:<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote">We could also imagine wanting information about the parent of each
path, and a mapping from tree nodes to some kind of path ID, but we
will keep things simple for now.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pathDecomposition ::</span> <span class="dt">SubtreeSelector</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">NonEmpty</span> a]</span></code></pre></div>
<p>Implementing <code>pathDecomposition</code> is a nice exercise; you might like to
try it yourself! You can find my implementation at the end of this
blog post.</p>
</section>
<section id="max-chain-decomposition" class="level2">
<h2>Max-chain decomposition</h2>
<p>Now, let’s use our generic path decomposition to implement a max-chain
decomposition. At each node we want to select the <em>tallest</em> subtree;
in order to do this efficiently, we can first annotate each tree node with
its height, via a straightforward <a href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Tree.html#v:foldTree">tree fold</a>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Height</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">labelHeight ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Height</span>, a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>labelHeight <span class="ot">=</span> foldTree node</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  node a ts <span class="ot">=</span> <span class="kw">case</span> ts <span class="kw">of</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">0</span>, a) []</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">maximum</span> (<span class="fu">map</span> (<span class="fu">fst</span> <span class="op">.</span> rootLabel) ts), a) ts</span></code></pre></div>
<p>Our subtree selection function can now select the subtree with the
largest <code>Height</code> annotation. Instead of implementing this directly,
we might as well make a generic function for selecting the “best”
element from a list (we will reuse it later):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">selectMaxBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [a])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>selectMaxBy _ [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>selectMaxBy cmp (a <span class="op">:</span> as) <span class="ot">=</span> <span class="kw">case</span> selectMaxBy cmp as <span class="kw">of</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, [])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (b, bs) <span class="ot">-&gt;</span> <span class="kw">case</span> cmp a b <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (b, a <span class="op">:</span> bs)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, b <span class="op">:</span> bs)</span></code></pre></div>
<p>We can now put the pieces together to implement max-chain
decomposition. We first label the tree by height, then do a path
decomposition that selects the tallest subtree at each node. We leave
the height annotations in the final output since they might be
useful—for example, we can tell how long each path is just by
looking at the <code>Height</code> annotation on the first element. If we don’t
need them we can easily get rid of them later. We also sort by
descending <code>Height</code>, since getting the longest chains first was kind
of the whole point.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maxChainDecomposition ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">NonEmpty</span> (<span class="dt">Height</span>, a)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>maxChainDecomposition <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  labelHeight <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  pathDecomposition (<span class="fu">const</span> (selectMaxBy (comparing (<span class="fu">fst</span> <span class="op">.</span> rootLabel)))) <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  sortBy (comparing (<span class="dt">Down</span> <span class="op">.</span> <span class="fu">fst</span> <span class="op">.</span> NE.head))</span></code></pre></div>
</section>
<section id="factor-full-tree-solution" class="level2">
<h2>Factor-full tree solution</h2>
<p>To flesh this out into a full solution to <a href="https://open.kattis.com/problems/factorfulltree">Factor-Full
Tree</a>, after
computing the chain decomposition we need to assign prime factors to
the chains. From those, we can compute the value for each node if we
know which chain it is in and the value of its parent. To this end,
we will need one more function which computes a <code>Map</code> recording the
parent of each node in a tree. Note that if we already know all the
edges in a given edge list are oriented the same way, we can build
this much more simply as <em>e.g.</em> <code>map swap &gt;&gt;&gt; M.fromList</code>; but when
(as in general) we don’t know which way the edges should be oriented
first, we might as well first build a <code>Tree a</code> via DFS with
<code>edgesToTree</code> and then construct the <code>parentMap</code> like this afterwards.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parentMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>parentMap <span class="ot">=</span> foldTree node <span class="op">&gt;&gt;&gt;</span> <span class="fu">snd</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  node ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [(a, <span class="dt">Map</span> a a)] <span class="ot">-&gt;</span> (a, <span class="dt">Map</span> a a)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  node a b <span class="ot">=</span> (a, M.fromList (<span class="fu">map</span> (,a) as) <span class="op">&lt;&gt;</span> <span class="fu">mconcat</span> ms)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    (as, ms) <span class="ot">=</span> <span class="fu">unzip</span> b</span></code></pre></div>
<p>Finally, we can solve Factor-Full tree. Note that some code from my
<a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">previous blog
post</a>
is needed as well, and is included at the end of the post for
completeness. Once we compute the max chain decomposition and the
prime factor for each node, we use a <a href="https://byorgey.github.io/blog/posts/2023/04/11/competitive-programming-in-haskell-topsort-via-laziness.html">lazy recursive
<code>Map</code></a>
to compute the value assigned to each node.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">TC</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>solve <span class="dt">TC</span>{<span class="op">..</span>} <span class="ot">=</span> M.elems assignment</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Build the tree and compute its parent map</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    t <span class="ot">=</span> edgesToTree <span class="dt">Node</span> edges <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    parent <span class="ot">=</span> parentMap t</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Compute the max chain decomposition, and use it to assign a prime factor</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- to each non-root node</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    paths ::</span> [[<span class="dt">Node</span>]]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    paths <span class="ot">=</span> <span class="fu">map</span> (NE.toList <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">snd</span>) <span class="op">$</span> maxChainDecomposition t</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    factor ::</span> <span class="dt">Map</span> <span class="dt">Node</span> <span class="dt">Int</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    factor <span class="ot">=</span> M.fromList <span class="op">.</span> <span class="fu">concat</span> <span class="op">$</span> <span class="fu">zipWith</span> (\p <span class="ot">-&gt;</span> <span class="fu">map</span> (,p)) primes paths</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Compute an assignment of each node to a value, using a lazy map</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    assignment ::</span> <span class="dt">Map</span> <span class="dt">Node</span> <span class="dt">Int</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    assignment <span class="ot">=</span> M.fromList <span class="op">$</span> (<span class="dv">1</span>,<span class="dv">1</span>) <span class="op">:</span> [(v, factor<span class="op">!</span>v <span class="op">*</span> assignment<span class="op">!</span>(parent<span class="op">!</span>v)) <span class="op">|</span> v <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="op">..</span>n]]</span></code></pre></div>
<p>For an explanation of this code for <code>primes</code>, see <a href="https://byorgey.github.io/blog/posts/2020/02/07/competitive-programming-in-haskell-primes-and-factoring.html">this old blog post</a>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Int</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span></code></pre></div>
</section>
<section id="bonus-heavy-light-decomposition" class="level2">
<h2>Bonus: heavy-light decomposition</h2>
<p>We can easily use our generic path decomposition to compute a <a href="https://cp-algorithms.com/graph/hld.html">heavy-light
decomposition</a> as well:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Size</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">labelSize ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Size</span>, a)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>labelSize <span class="ot">=</span> foldTree <span class="op">$</span> \a ts <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">sum</span> (<span class="fu">map</span> (<span class="fu">fst</span> <span class="op">.</span> rootLabel) ts), a) ts</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">heavyLightDecomposition ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">NonEmpty</span> (<span class="dt">Size</span>, a)]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>heavyLightDecomposition <span class="ot">=</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  labelSize <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  pathDecomposition (<span class="fu">const</span> (selectMaxBy (comparing (<span class="fu">fst</span> <span class="op">.</span> rootLabel))))</span></code></pre></div>
<p>I plan to write about this in a future post.</p>
</section>
<section id="leftover-code" class="level2">
<h2>Leftover code</h2>
<p>Here’s my implementation of <code>pathDecomposition</code>; how did you do?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>pathDecomposition select <span class="ot">=</span> go</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  go <span class="ot">=</span> selectPath select <span class="op">&gt;&gt;&gt;</span> second (<span class="fu">concatMap</span> go) <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> (<span class="op">:</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">selectPath ::</span> <span class="dt">SubtreeSelector</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (<span class="dt">NonEmpty</span> a, [<span class="dt">Tree</span> a])</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>selectPath select <span class="ot">=</span> go</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  go (<span class="dt">Node</span> a ts) <span class="ot">=</span> <span class="kw">case</span> select a ts <span class="kw">of</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (NE.singleton a, ts)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> (t, ts&#39;) <span class="ot">-&gt;</span> ((a <span class="op">NE.&lt;|</span>) <span class="op">***</span> (ts&#39; <span class="op">++</span>)) (go t)</span></code></pre></div>
<p>We also include some input parsing and tree-building code from <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">last time</a>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> BS.interact <span class="op">$</span> runScanner tc <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">show</span> <span class="op">&gt;&gt;&gt;</span> BS.pack) <span class="op">&gt;&gt;&gt;</span> BS.unwords</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot"> n ::</span> <span class="dt">Int</span>,<span class="ot"> edges ::</span> [(<span class="dt">Node</span>, <span class="dt">Node</span>)] }</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">&lt;-</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">&gt;&lt;</span> pair int int</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span>{<span class="op">..</span>}</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>edgesToMap <span class="ot">=</span> <span class="fu">concatMap</span> (\p <span class="ot">-&gt;</span> [p, swap p]) <span class="op">&gt;&gt;&gt;</span> dirEdgesToMap</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="ot">dirEdgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>dirEdgesToMap <span class="ot">=</span> <span class="fu">map</span> (second (<span class="op">:</span> [])) <span class="op">&gt;&gt;&gt;</span> M.fromListWith (<span class="op">++</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="ot">mapToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>mapToTree nd m root <span class="ot">=</span> dfs root root</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>  dfs parent root <span class="ot">=</span> nd root (<span class="fu">maybe</span> [] (<span class="fu">map</span> (dfs root) <span class="op">.</span> <span class="fu">filter</span> (<span class="op">/=</span> parent)) (m <span class="op">!?</span> root))</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [(a, a)] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>edgesToTree nd <span class="ot">=</span> mapToTree nd <span class="op">.</span> edgesToMap</span></code></pre></div>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: tree path decomposition, part II" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 08 Aug 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/08/08/TreeDecomposition.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Help me attend ICFP in Milan!</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/20/ko-fi-help-me-attend-icfp.html</link>
    <description><![CDATA[
<h1>Help me attend ICFP in Milan!</h1>

<div class="info">
  Posted on July 20, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;community&#39;." href="/tag/community.html" rel="tag">community</a>, <a title="All pages tagged &#39;contribution&#39;." href="/tag/contribution.html" rel="tag">contribution</a>, <a title="All pages tagged &#39;ICFP&#39;." href="/tag/ICFP.html" rel="tag">ICFP</a>, <a title="All pages tagged &#39;ko-fi&#39;." href="/tag/ko-fi.html" rel="tag">ko-fi</a>, <a title="All pages tagged &#39;open-source&#39;." href="/tag/open-source.html" rel="tag">open-source</a>, <a title="All pages tagged &#39;tips&#39;." href="/tag/tips.html" rel="tag">tips</a>
  
</div>

<section>
<p><strong>tl;dr</strong>: if you appreciate my past or ongoing contributions to the
Haskell community, please consider helping me get to ICFP this year by <a href="https://ko-fi.com/byorgey">donating
via my ko-fi page</a>!</p>
<p><a href="https://ko-fi.com/I3I5KYUQX"><img src="https://ko-fi.com/img/githubbutton_sm.svg" alt="ko-fi" /></a></p>
<p>Working at a <a href="https://www.hendrix.edu/">small liberal arts institution</a>
has some tremendous benefits (close interaction with motivated students,
freedom to pursue the projects I want rather than jump through a bunch
of hoops to get tenure, fantastic colleagues), and I love my job. But
there are also downsides; the biggest ones for me are the difficulty of
securing enough travel funding, and, relatedly, the difficulty of
cultivating and maintaining collaborations.</p>
<p><a href="https://byorgey.github.io/blog/posts/2023/05/22/new-ko-fi-page-help-me-attend-icfp.html">Last
year</a>
I was very grateful for people’s generosity in helping me get to
Seattle. I am planning to again attend <a href="https://icfp24.sigplan.org/">ICFP in Milan this
September</a>; this time I will even bring
some students along. I have once again secured some funding from my
institution, but it will not be enough to cover all the expenses.</p>
<p>So, if you have been positively impacted by my
contributions to the Haskell community (<em>e.g.</em> <a href="https://www.cis.upenn.edu/~cis1940/spring13/">CIS
194</a>, the
<a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>,
<a href="https://diagrams.github.io/">diagrams</a>,
<a href="https://hackage.haskell.org/package/split">split</a>,
<a href="https://hackage.haskell.org/package/MonadRandom">MonadRandom</a>, <a href="https://byorgey.github.io/blog/posts/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy.html">burrito
metaphors</a>…)
and/or would like to support my ongoing work (<a href="https://byorgey.github.io/blog/tag/Kattis.html">competitive programming
in
Haskell</a>,
<a href="https://github.com/swarm-game/swarm/#readme">swarm</a>,
<a href="https://github.com/disco-lang/disco/#readme">disco</a>, <a href="https://hackage.haskell.org/user/BrentYorgey">ongoing package
maintenance</a>…), and are
able to express that appreciation or support with a <a href="https://ko-fi.com/byorgey">donation of any
size</a> to help me get to ICFP, I would really appreciate it!</p>
<p>Thank you, friends — I hope to see many people in Milan! Next up:
I will soon publish another post about <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">tree path decomposition</a>!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Help me attend ICFP in Milan!" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Sat, 20 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/20/ko-fi-help-me-attend-icfp.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Rivers: eventually constant streams in Haskell</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/18/River.html</link>
    <description><![CDATA[
<h1>Rivers: eventually constant streams in Haskell</h1>

<div class="info">
  Posted on July 18, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;stream&#39;." href="/tag/stream.html" rel="tag">stream</a>, <a title="All pages tagged &#39;river&#39;." href="/tag/river.html" rel="tag">river</a>, <a title="All pages tagged &#39;eventually&#39;." href="/tag/eventually.html" rel="tag">eventually</a>, <a title="All pages tagged &#39;constant&#39;." href="/tag/constant.html" rel="tag">constant</a>, <a title="All pages tagged &#39;binary&#39;." href="/tag/binary.html" rel="tag">binary</a>, <a title="All pages tagged &#39;2-adic&#39;." href="/tag/2-adic.html" rel="tag">2-adic</a>, <a title="All pages tagged &#39;p-adic&#39;." href="/tag/p-adic.html" rel="tag">p-adic</a>
  
</div>

<section>
<p>Lately I’ve been thinking about representing <em>eventually constant
streams</em> in Haskell. An eventually constant stream is an infinite
stream which eventually, after some finite prefix, starts repeating
the same value forever. For example,</p>
<p><span class="math inline">\(6, 8, 2, 9, 3, 1, 1, 1, 1, \dots\)</span></p>
<p>There are many things we can do in a
decidable way with eventually constant streams that we can’t do with
infinite streams in general—for example, test them for equality.</p>
<p>This is a work in progress. I only have one specific use case in mind
(infinite-precision two’s complement arithmetic, explained at the end
of the post), so I would love to hear of other potential use cases, or
any other feedback. Depending on the feedback I may eventually turn
this into a package on Hackage.</p>
<p>This blog post is typeset from a literate Haskell file; if you want to
play along you can <a href="https://github.com/byorgey/blog/blob/main/posts/2024/07/16/River.lhs">download the source from GitHub</a>.</p>
<section id="the-river-type" class="level2">
<h2>The <code>River</code> type</h2>
<p>Some preliminaries:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">River</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">All</span> (..), <span class="dt">Any</span> (..))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> (<span class="dt">Max</span> (..), <span class="dt">Min</span> (..))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (all, and, any, drop, foldMap, maximum, minimum, or, repeat, take, zipWith, (!!))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">P</span></span></code></pre></div>
<p>Now let’s get to the main definition. A value of type <code>River a</code> is
either a constant <code>C a</code>, representing an infinite stream of copies of
<code>a</code>, or a <code>Cons</code> with an <code>a</code> and a <code>River a</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">River</span> a <span class="ot">=</span> <span class="dt">C</span> <span class="op">!</span>a <span class="op">|</span> <span class="dt">Cons</span> <span class="op">!</span>a <span class="op">!</span>(<span class="dt">River</span> a)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>I call this a <code>River</code> since “all <code>River</code>s flow to the <code>C</code>”!</p>
<p>The <a href="https://tech.fpcomplete.com/haskell/tutorial/all-about-strictness/">strictness annotations</a> on the <code>a</code> values just seem like a good
idea in general. The strictness annotation on the <code>River a</code> tail,
however, is more interesting: it’s there to rule out infinite streams<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Although the strictness annotation on the <code>River a</code> is semantically correct, I could imagine not wanting it there for performance reasons; I’d be happy to hear any feedback on this point.<br />
<br />
</span></span>
constructed using only <code>Cons</code>, such as <code>flipflop = Cons 0 (Cons 1 flipflop)</code>. In
other words, the only way to make a non-<a href="https://en.wikibooks.org/wiki/Haskell/Denotational_semantics">bottom</a> value of type <code>Stream a</code> is
to have a finite sequence of <code>Cons</code> finally terminated by <code>C</code>.</p>
<p>We need to be a bit careful here, since there are multiple ways to
represent streams which are semantically supposed to be the same. For
example, <code>Cons 1 (Cons 1 (C 1))</code> and <code>C 1</code> both represent an infinite stream of
all <code>1</code>’s. In general, we have the law</p>
<p><code>C a === Cons a (C a)</code>,</p>
<p>and want to make sure that any functions we write respect this
<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">It would be interesting to try implementing rivers as a higher inductive type, say, in <a href="https://agda.readthedocs.io/en/v2.6.20240714/language/cubical.html">Cubical Agda</a>.<br />
<br />
</span></span>
equivalence, <em>i.e.</em> do not distinguish between such values. This is
the reason I did not derive an <code>Eq</code> instance; we will have to write
our own.</p>
<p>We can partially solve this problem with a <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pattern_synonyms.html"><em>bidirectional pattern
synonym</em></a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">expand ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>expand (<span class="dt">C</span> a) <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">C</span> a)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>expand as <span class="ot">=</span> as</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span><span class="ot"> (:::) ::</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> (<span class="op">:::</span>) a as <span class="ot">&lt;-</span> (expand <span class="ot">-&gt;</span> <span class="dt">Cons</span> a as)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">:::</span> as <span class="ot">=</span> <span class="dt">Cons</span> a as</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# COMPLETE (:::) #-}</span></span></code></pre></div>
<p>Matching with the pattern <code>(a ::: as)</code> uses a <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/view_patterns.html"><em>view pattern</em></a>
to potentially expand a <code>C</code> one step into a <code>Cons</code>, so that we can
pretend all <code>River</code> values are always constructed with <code>(:::)</code>.
In the other direction, <code>(:::)</code> merely constructs a <code>Cons</code>.</p>
<p>We mark <code>(:::)</code> as <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/pragmas.html#complete-pragmas"><code>COMPLETE</code></a> on its own since it is, in fact,
sufficient to handle every possible input of type <code>River</code>. However,
in order to obtain terminating algorithms we will often include one or
more special cases for <code>C</code>.</p>
</section>
<section id="normalization-by-construction" class="level2">
<h2>Normalization by construction?</h2>
<p>As an alternative, we could use a variant pattern synonym:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">::=</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span><span class="ot"> (::=) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> (<span class="op">::=</span>) a as <span class="ot">&lt;-</span> (expand <span class="ot">-&gt;</span> <span class="dt">Cons</span> a as)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    a&#39; <span class="op">::=</span> <span class="dt">C</span> a <span class="op">|</span> a&#39; <span class="op">==</span> a <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    a <span class="op">::=</span> as <span class="ot">=</span> <span class="dt">Cons</span> a as</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# COMPLETE (::=) #-}</span></span></code></pre></div>
<p>As compared to <code>(:::)</code>, this has an extra <code>Eq a</code> constraint: when we
construct a <code>River</code> with <code>(::=)</code>, it checks to see whether we are
consing an identical value onto an existing <code>C a</code>, and if so, simply
returns the <code>C a</code> unchanged. If we always use <code>(::=)</code> instead of
directly using <code>Cons</code>, it ensures that <code>River</code> values are always
<em>normalized</em>—that is, for every eventually constant stream, we
always use the canonical representative where the element immediately
preciding the constant tail is not equal to it.</p>
<p>This, in turn, <em>technically</em> makes it impossible to write functions
which do not respect the equivalence <code>C a === Cons a (C a)</code>, simply
because they will only ever be given canonical rivers as input.
However, as we will see when we discuss folds, it is still possible to
write “bad” functions, <em>i.e.</em> functions that are semantically
questionable as functions on eventually constant streams—it would
just mean we cannot directly observe them behaving badly.</p>
<p>The big downside of using this formulation is that the <code>Eq</code> constraint
infects absolutely everything—we even end up with <code>Eq</code> constraints
in places where we would not expect them (for example, on <code>head :: River a -&gt; a</code>), because the pattern synonym incurs an <code>Eq</code> constraint
anywhere we use it, regardless of whether we are using it to construct
or destruct <code>River</code> values. As you can see from the definition above,
we only do an equality check when using <code>(::=)</code> to construct a
<code>River</code>, not when using it to pattern-match, but there is no way to
give the pattern synonym different types in the two directions.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Of course, we could make it a unidirectional pattern synonym and just make a differently named smart constructor, but that seems somewhat ugly, as we would have to remember which to use in which situation.<br />
<br />
</span></span></p>
<p>So, because this normalizing variant does not really go far enough in
removing our burden of proof, and has some big downsides in the form
of leaking <code>Eq</code> constraints everywhere, I have chosen to stick with
the simpler <code>(:::)</code> in this post. But I am still a bit unsure about this
choice; in fact, I went back and forth two times while writing.</p>
<p>We can at least provide a <code>normalize</code> function, which we can use when
we want to ensure normalization:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalize ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>normalize (<span class="dt">C</span> a) <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>normalize (a <span class="op">::=</span> as) <span class="ot">=</span> a <span class="op">::=</span> as</span></code></pre></div>
</section>
<section id="some-standard-functions-on-rivers" class="level2">
<h2>Some standard functions on rivers</h2>
<p>With the preliminary definitions out of the way, we can now build up a
library of standard functions and instances for working with <code>River a</code>
values. To start, we can write an <code>Eq</code> instance as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">River</span> a) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> a <span class="op">==</span> <span class="dt">C</span> b <span class="ot">=</span> a <span class="op">==</span> b</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  (a <span class="op">:::</span> as) <span class="op">==</span> (b <span class="op">:::</span> bs) <span class="ot">=</span> a <span class="op">==</span> b <span class="op">&amp;&amp;</span> as <span class="op">==</span> bs</span></code></pre></div>
<p>Notice that we only need two cases, not four: if we compare two values
whose finite prefixes are different lengths, the shorter one will
automatically expand (via matching on <code>(:::)</code>) to the length of the
longer.</p>
<p>We already derived a <code>Functor</code> instance; we can also define a “zippy”
<code>Applicative</code> instance like so:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">repeat</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">repeat</span> <span class="ot">=</span> <span class="dt">C</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">River</span> <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">repeat</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> f <span class="op">&lt;*&gt;</span> <span class="dt">C</span> x <span class="ot">=</span> <span class="dt">C</span> (f x)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">:::</span> fs) <span class="op">&lt;*&gt;</span> (x <span class="op">:::</span> xs) <span class="ot">=</span> f x <span class="op">:::</span> (fs <span class="op">&lt;*&gt;</span> xs)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> b <span class="ot">-&gt;</span> <span class="dt">River</span> c</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> <span class="ot">=</span> liftA2</span></code></pre></div>
<p>We can write safe <code>head</code>, <code>tail</code>, and index functions:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (a <span class="op">:::</span> _) <span class="ot">=</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> (_ <span class="op">:::</span> as) <span class="ot">=</span> as</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">9</span> <span class="op">!!</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">(!!) ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="dt">C</span> a <span class="op">!!</span> _ <span class="ot">=</span> a</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>(a <span class="op">:::</span> _) <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>(_ <span class="op">:::</span> as) <span class="op">!!</span> n <span class="ot">=</span> as <span class="op">!!</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>We can also write <code>take</code> and <code>drop</code> variants. Note that <code>take</code>
returns a finite prefix of a <code>River</code>, which is a list, not another
<code>River</code>. The special case for <code>drop _ (C a)</code> is not strictly
necessary, but makes it more efficient.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n _ <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n (a <span class="op">:::</span> as) <span class="ot">=</span> a <span class="op">:</span> <span class="fu">take</span> (n <span class="op">-</span> <span class="dv">1</span>) as</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> n r <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> r</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> _ (<span class="dt">C</span> a) <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> n (_ <span class="op">:::</span> as) <span class="ot">=</span> <span class="fu">drop</span> (n <span class="op">-</span> <span class="dv">1</span>) as</span></code></pre></div>
<p>There are many other such functions we could implement (<em>e.g.</em> <code>span</code>,
<code>dropWhile</code>, <code>tails</code>…); if I eventually put this on Hackage I would
be sure to have a much more thorough selection of functions. Which
functions would you want to see?</p>
</section>
<section id="folds-for-river" class="level2">
<h2>Folds for <code>River</code></h2>
<p>How do we fold over a <code>River a</code>? The <code>Foldable</code> type class requires us
to define either <code>foldMap</code> or <code>foldr</code>; let’s think about <code>foldMap</code>,
which would have type</p>
<pre><code>foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; River a -&gt; m</code></pre>
<p>However, this doesn’t really make sense. For example, suppose we have
a <code>River Int</code>; if we had <code>foldMap</code> with the above type, we could use
<code>foldMap Sum</code> to turn our <code>River Int</code> into a <code>Sum Int</code>. But what is
the sum of an infinite stream of <code>Int</code>? Unless the eventually
repeating part is <code>C 0</code>, this is not well-defined. If we simply write
a function to add up all the <code>Int</code> values in a <code>River</code>, including
(once) the value contained in the final <code>C</code>, this would be a good
example of a semantically “bad” function: it does not respect the law
<code>C a === a ::: C a</code>. If we ensure <code>River</code> values are always
normalized, we would not be able to directly observe anything amiss,
but the function still seems suspect.</p>
<p>Thinking about the law <code>C a === a ::: C a</code> again is the key.
Supposing <code>foldMap f (C a) = f a</code> (since it’s unclear what else it
could possibly do), applying <code>foldMap</code> to both sides of the law we
obtain <code>f a == f a &lt;&gt; f a</code>, that is, the combining operation must be
<em>idempotent</em>. This makes sense: with an idempotent operation,
continuing to apply the operation to the infinite constant tail will
not change the answer, so we can simply stop once we reach the <code>C</code>.</p>
<p>We can create a subclass of <code>Semigroup</code> to represent <em>idempotent</em>
semigroups, that is, semigroups for which <code>a &lt;&gt; a = a</code>. There are
several idempotent semigroups in <code>base</code>; we list a few below. Note
that since rivers are never empty, we can get away with just a
semigroup and not a monoid, since we do not need an identity value
onto which to map an empty structure.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">Idempotent</span> m</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- No methods, since Idempotent represents adding only a law,</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- namely, ∀ a. a &lt;&gt; a == a</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Exercise for the reader: convince yourself that these are all</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- idempotent</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Idempotent</span> <span class="dt">All</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Idempotent</span> <span class="dt">Any</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Idempotent</span> <span class="dt">Ordering</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Idempotent</span> (<span class="dt">Max</span> a)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Idempotent</span> (<span class="dt">Min</span> a)</span></code></pre></div>
<p>Now, although we cannot make a <code>Foldable</code> instance, we can write our own
variant of <code>foldMap</code> which requires an idempotent semigroup instead of
a monoid:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span><span class="ot"> ::</span> <span class="dt">Idempotent</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> m</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> f (<span class="dt">C</span> a) <span class="ot">=</span> f a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> f (a <span class="op">:::</span> as) <span class="ot">=</span> f a <span class="op">&lt;&gt;</span> <span class="fu">foldMap</span> f as</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fold ::</span> <span class="dt">Idempotent</span> m <span class="ot">=&gt;</span> <span class="dt">River</span> m <span class="ot">-&gt;</span> m</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>fold <span class="ot">=</span> <span class="fu">foldMap</span> <span class="fu">id</span></span></code></pre></div>
<p>We can then instantiate it at some of the semigroups listed above to
get some useful folds. These are all guaranteed to terminate and
yield a sensible answer on any <code>River</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">River</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> <span class="ot">=</span> getAll <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">All</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span><span class="ot"> ::</span> <span class="dt">River</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> <span class="ot">=</span> getAny <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Any</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span> f <span class="ot">=</span> <span class="fu">and</span> <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span> f <span class="ot">=</span> <span class="fu">or</span> <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span> <span class="ot">=</span> getMax <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Max</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="fu">minimum</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="fu">minimum</span> <span class="ot">=</span> getMin <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Min</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="ot">lexicographic ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>lexicographic xs ys <span class="ot">=</span> fold <span class="op">$</span> <span class="fu">zipWith</span> <span class="fu">compare</span> xs ys</span></code></pre></div>
<p>We could make an <code>instance Ord a =&gt; Ord (River a)</code> with <code>compare = lexicographic</code>; however, in the next section I want to make a
different <code>Ord</code> instance for a specific instantiation of <code>River</code>.</p>
</section>
<section id="application-2-adic-numbers" class="level2">
<h2>Application: <span class="math inline">\(2\)</span>-adic numbers</h2>
<p>Briefly, here’s the particular application I have in mind:
infinite-precision two’s complement arithmetic, <em>i.e.</em> <span class="math inline">\(2\)</span>-adic
numbers. <a href="https://cdsmithus.medium.com/the-collatz-step-and-2-adic-integers-6f003efaf81c">Chris Smith also wrote about <span class="math inline">\(2\)</span>-adic numbers
recently</a>;
however, unlike Chris, I am not interested in <span class="math inline">\(2\)</span>-adic numbers in
general, but only specifically those <span class="math inline">\(2\)</span>-adic numbers which represent
an embedded copy of <span class="math inline">\(\mathbb{Z}\)</span>. These are precisely the eventually
constant ones: nonnegative integers are represented in binary as
usual, with an infinite tail of <span class="math inline">\(0\)</span> bits, and negative integers are
represented with an infinite tail of <span class="math inline">\(1\)</span> bits. For example, <span class="math inline">\(-1\)</span> is
represented as an infinite string of all <span class="math inline">\(1\)</span>’s. The amazing thing
about this representation (and the reason it is commonly used in
hardware) is that the usual addition and multiplication algorithms
continue to work without needing special cases to handle negative
integers. If you’ve never seen how this works, you should definitely
<a href="https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">read</a>
<a href="https://en.wikipedia.org/wiki/Two%27s_complement">about it</a>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bit</span> <span class="ot">=</span> <span class="dt">O</span> <span class="op">|</span> <span class="dt">I</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bits</span> <span class="ot">=</span> <span class="dt">River</span> <span class="dt">Bit</span></span></code></pre></div>
<p>First, some functions to convert to and from integers. We only need
special cases for <span class="math inline">\(0\)</span> and <span class="math inline">\(-1\)</span>, and beyond that it is just the usual
business with <code>mod</code> and <code>div</code> to peel off one bit at a time, or
multiplying by two and adding to build up one bit at a time. (I am a <a href="https://ro-che.info/articles/2014-05-09-clauses">big fan of</a> <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/lambda_case.html"><code>LambdaCase</code></a>.)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toBits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>toBits <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span>  <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">I</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  n  <span class="ot">-&gt;</span> <span class="fu">toEnum</span> (<span class="fu">fromIntegral</span> (n <span class="ot">`mod`</span> <span class="dv">2</span>)) <span class="op">:::</span> toBits (n <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fromBits ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>fromBits <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">I</span> <span class="ot">-&gt;</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  b <span class="op">:::</span> bs <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="op">*</span> fromBits bs <span class="op">+</span> <span class="fu">fromIntegral</span> (<span class="fu">fromEnum</span> b)</span></code></pre></div>
<p>For testing, we can also make a <code>Show</code> instance. When it comes to
showing the infinite constant tail, I chose to repeat the bit 3 times
and then show an ellipsis; this is not really necessary but somehow
helps my brain more easily see whether it is an infinite tail of zeros
or ones.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bits</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="ot">=</span> <span class="fu">reverse</span> <span class="op">.</span> go</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">C</span> b) <span class="ot">=</span> <span class="fu">replicate</span> <span class="dv">3</span> (showBit b) <span class="op">++</span> <span class="st">&quot;...&quot;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    go (b <span class="op">:::</span> bs) <span class="ot">=</span> showBit b <span class="op">:</span> go bs</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    showBit <span class="ot">=</span> (<span class="st">&quot;01&quot;</span> <span class="op">P.!!</span>) <span class="op">.</span> <span class="fu">fromEnum</span></span></code></pre></div>
<p>Let’s try it out:</p>
<pre><code>ghci&gt; toBits 26
...00011010
ghci&gt; toBits (-30)
...11100010
ghci&gt; fromBits (toBits (-30))
-30
ghci&gt; quickCheck $ \x -&gt; fromBits (toBits x) == x
+++ OK, passed 100 tests.</code></pre>
</section>
<section id="arithmetic-on-2-adic-numbers" class="level2">
<h2>Arithmetic on <span class="math inline">\(2\)</span>-adic numbers</h2>
<p>Let’s implement some arithmetic. First, incrementing. It is standard
except for a special case for <code>C I</code> (without which, incrementing <code>C I</code>
would diverge). Notice that we use <code>(::=)</code> instead of <code>(:::)</code>, which
ensures our <code>Bits</code> values remain normalized.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inc ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>inc <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">I</span>      <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">O</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">I</span> <span class="op">::=</span> bs</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> inc bs</span></code></pre></div>
<p><code>dec</code> is similar, just the opposite:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dec ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>dec <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">O</span>      <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">I</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> bs</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">O</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">I</span> <span class="op">::=</span> dec bs</span></code></pre></div>
<p>Then we can write <code>inv</code> to invert all bits, and <code>neg</code> as the
composition of <code>inc</code> and <code>inv</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inv ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>inv <span class="ot">=</span> <span class="fu">fmap</span> <span class="op">$</span> \<span class="kw">case</span> { <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">I</span>; <span class="dt">I</span> <span class="ot">-&gt;</span> <span class="dt">O</span> }</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">neg ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>neg <span class="ot">=</span> inc <span class="op">.</span> inv</span></code></pre></div>
<p>Trying it out:</p>
<pre><code>λ&gt; toBits 3
...00011
λ&gt; neg it
...11101
λ&gt; inc it
...1110
λ&gt; inc it
...111
λ&gt; inc it
...000
λ&gt; inc it
...0001
λ&gt; dec it
...000
λ&gt; dec it
...111</code></pre>
<p>Finally, addition, multiplication, and <code>Ord</code> and <code>Num</code> instances:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>add <span class="ot">=</span> \cases</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">O</span>)      y          <span class="ot">-&gt;</span> y</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  x          (<span class="dt">C</span> <span class="dt">O</span>)      <span class="ot">-&gt;</span> x</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">I</span>)      (<span class="dt">C</span> <span class="dt">I</span>)      <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> <span class="dt">C</span> <span class="dt">I</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">I</span> <span class="op">::=</span> xs) (<span class="dt">I</span> <span class="op">::=</span> ys) <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> inc (add xs ys)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  (x <span class="op">::=</span> xs) (y <span class="op">::=</span> ys) <span class="ot">-&gt;</span> (x <span class="op">.|.</span> y) <span class="op">::=</span> add xs ys</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span> <span class="op">.|.</span> _ <span class="ot">=</span> <span class="dt">I</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">.|.</span> y <span class="ot">=</span> y</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>mul <span class="ot">=</span> \cases</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">O</span>)      _     <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  _          (<span class="dt">C</span> <span class="dt">O</span>) <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">I</span>)      y     <span class="ot">-&gt;</span> neg y</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  x          (<span class="dt">C</span> <span class="dt">I</span>) <span class="ot">-&gt;</span> neg x</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">O</span> <span class="op">::=</span> xs) ys    <span class="ot">-&gt;</span>         <span class="dt">O</span> <span class="op">::=</span> mul xs ys</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">I</span> <span class="op">::=</span> xs) ys    <span class="ot">-&gt;</span> add ys (<span class="dt">O</span> <span class="op">::=</span> mul xs ys)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Bits</span> <span class="kw">where</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- It&#39;s a bit mind-boggling that this works</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> (<span class="dt">C</span> x) (<span class="dt">C</span> y) <span class="ot">=</span> <span class="fu">compare</span> y x</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> (x <span class="op">::=</span> xs) (y <span class="op">::=</span> ys) <span class="ot">=</span> <span class="fu">compare</span> xs ys <span class="op">&lt;&gt;</span> <span class="fu">compare</span> x y</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Bits</span> <span class="kw">where</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> toBits</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">negate</span> <span class="ot">=</span> neg</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> add</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>  (<span class="op">*</span>) <span class="ot">=</span> mul</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span> <span class="ot">=</span> toBits <span class="op">.</span> <span class="fu">abs</span> <span class="op">.</span> fromBits</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">signum</span> <span class="ot">=</span> toBits <span class="op">.</span> <span class="fu">signum</span> <span class="op">.</span> fromBits</span></code></pre></div>
<pre><code>λ&gt; quickCheck $ withMaxSuccess 1000 $ \x y -&gt; fromBits (mul (toBits x) (toBits y)) == x * y
+++ OK, passed 1000 tests.
λ&gt; quickCheck $ \x y -&gt; compare (toBits x) (toBits y) == compare x y
+++ OK, passed 100 tests.</code></pre>
<p>Just for fun, let’s implement the Collatz map:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">collatz ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>collatz (<span class="dt">O</span> <span class="op">::=</span> bs) <span class="ot">=</span> bs</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>collatz bs<span class="op">@</span>(<span class="dt">I</span> <span class="op">::=</span> _) <span class="ot">=</span> <span class="dv">3</span><span class="op">*</span>bs <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<pre><code>λ&gt; P.take 20 $ map fromBits (iterate collatz (toBits (-13)))
[-13,-38,-19,-56,-28,-14,-7,-20,-10,-5,-14,-7,-20,-10,-5,-14,-7,-20,-10,-5]
λ&gt; P.take 20 $ map fromBits (iterate collatz (toBits 7))
[7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1]</code></pre>
</section>
<section id="questions-future-work" class="level2">
<h2>Questions / future work</h2>
<ul>
<li><p>Is <code>(:::)</code> or <code>(::=)</code> the better default? It’s tempting to just say
“provide both and let the user decide”. I don’t disagree with that;
however, the question is which one we use to implement various basic
functions such as <code>map</code>/<code>fmap</code>. For example, if we use <code>(:::)</code>, we
can make a <code>Functor</code> instance, but values may not be normalized
after mapping.</p></li>
<li><p>Can we generalize from eventually constant to eventually <em>periodic</em>?
That is, instead of repeating the same value forever, we cycle
through a repeating period of some finite length. I think this
is possible, but it would make the implementation more
complex, and I don’t know the right way to generalize <code>foldMap</code>. (We
could insist that it only works for <em>commutative</em> idempotent
semigroups, but in that case what’s the point of having a <em>sequence</em>
of values rather than just a set?)</p></li>
</ul>
<p>Happy to hear any comments or suggestions!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Rivers: eventually constant streams in Haskell" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 18 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/18/River.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: tree path decomposition, part I</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: tree path decomposition, part I</h1>

<div class="info">
  Posted on July 11, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;tree&#39;." href="/tag/tree.html" rel="tag">tree</a>, <a title="All pages tagged &#39;path&#39;." href="/tag/path.html" rel="tag">path</a>, <a title="All pages tagged &#39;decomposition&#39;." href="/tag/decomposition.html" rel="tag">decomposition</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">a previous
post</a>
I challenged you to solve <a href="https://open.kattis.com/problems/factorfulltree">Factor-Full
Tree</a>. In this
problem, we are given an unlabelled rooted tree, and asked to create a <em>divisor
labelling</em>. That is, we must label the vertices with positive
integers in such a way that <span class="math inline">\(v\)</span> is an ancestor of <span class="math inline">\(u\)</span> if and only if
<span class="math inline">\(v\)</span>’s label evenly divides <span class="math inline">\(u\)</span>’s label.</p>
<p>For example, here is a tree with a divisor labelling:</p>
<p><span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Divisor labelling of a tree<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/0d43c38705f7e411.svg" />
</figure>
<p>The interesting point (though irrelevant to solving the problem) is
that this is a method for encoding a tree as a set of integers:
because <span class="math inline">\(v\)</span> is an ancestor of <span class="math inline">\(u\)</span> <em>if and only if</em> <span class="math inline">\(v\)</span>’s label divides
<span class="math inline">\(u\)</span>’s, all the information about the tree’s structure is fully
contained in the set of labels. For example, if we simply write
down the set <span class="math inline">\(\{1, 5, 6, 7, 12, 14, 21, 49, 63\}\)</span>, it is possible to
fully reconstruct the above tree from this set.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">Note that we
consider trees equivalent up to reordering of siblings, that is, each
node has a <em>bag</em>, not a <em>list</em>, of children.<br />
<br />
</span></span> This is not a
particularly <em>efficient</em> way to encode a tree, but it is certainly
interesting!</p>
<section id="basic-setup" class="level2">
<h2>Basic setup</h2>
<p>First, some basic setup.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote"><a href="https://byorgey.github.io/blog/posts/2019/05/22/competitive-programming-in-haskell-scanner.html">See here</a> for the <code>Scanner</code>
abstraction, and
<a href="https://byorgey.github.io/blog/posts/2019/04/24/competitive-programming-in-haskell-basic-setup.html">here</a>
for the basics of how I organize solutions.<br />
<br />
</span></span> The first line of
input specifies the number of nodes <span class="math inline">\(N\)</span>, and after that there are
<span class="math inline">\(N-1\)</span> lines, each specifying a single undirected edge.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (second)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>, (!?))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> (swap)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> C.interact <span class="op">$</span> runScanner tc <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> format</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot"> n ::</span> <span class="dt">Int</span>,<span class="ot"> edges ::</span> [<span class="dt">Edge</span>] }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">&lt;-</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">&gt;&lt;</span> pair int int</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span>{<span class="op">..</span>}</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ot">format ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>format <span class="ot">=</span> <span class="fu">map</span> showB <span class="op">&gt;&gt;&gt;</span> C.unwords</span></code></pre></div>
<p>We are guaranteed that the edges describe a tree; next we will
actually build a tree data structure from the input.</p>
</section>
<section id="building-trees" class="level2">
<h2>Building trees</h2>
<p>There are many
similar problems which specify a tree structure by giving a list of
edges, so it’s worthwhile trying to write some generic code to
transform such an input into an actual tree. In an imperative language
we would do this by building a map from each node to its neighbors,
then doing a DFS to orient the tree. Our Haskell code will be
similar, except building the map and doing a DFS will both be
one-liners!</p>
<p>First, a function to turn a list of undirected edges into a <code>Map</code>
associating each vertex to all its neighbors. It’s convenient to
decompose this into a function to turn a list of <em>directed</em> edges into
a <code>Map</code>, and a function to duplicate and swap each pair. We won’t
need <code>dirEdgesToMap</code> for this problem, but we can certainly imagine
wanting it elsewhere.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>edgesToMap <span class="ot">=</span> <span class="fu">concatMap</span> (\p <span class="ot">-&gt;</span> [p, swap p]) <span class="op">&gt;&gt;&gt;</span> dirEdgesToMap</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dirEdgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>dirEdgesToMap <span class="ot">=</span> <span class="fu">map</span> (second (<span class="op">:</span> [])) <span class="op">&gt;&gt;&gt;</span> M.fromListWith (<span class="op">++</span>)</span></code></pre></div>
<p>Next, we can turn such a neighbor <code>Map</code> into a tree. Rather than
returning a literal <code>Tree</code> data structure, it’s convenient to
incorporate a tree fold: that is, given a function <code>a -&gt; [b] -&gt; b</code>, a neighbor
map, and a root node, we fold over the whole tree and return the
resulting <code>b</code> value. (Of course, if we want an actual <code>Tree</code> we can use
<code>mapToTree Node</code>.) We can also compose these into a single function <code>edgesToTree</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mapToTree nd m root <span class="ot">=</span> dfs root root</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  dfs parent root <span class="ot">=</span> nd root (<span class="fu">maybe</span> [] (<span class="fu">map</span> (dfs root) <span class="op">.</span> <span class="fu">filter</span> (<span class="op">/=</span> parent)) (m <span class="op">!?</span> root))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [(a, a)] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>edgesToTree nd <span class="ot">=</span> mapToTree nd <span class="op">.</span> edgesToMap</span></code></pre></div>
</section>
<section id="inventing-divisor-labellings" class="level2">
<h2>Inventing divisor labellings</h2>
<p>So how do we create a divisor labelling for a given tree? Clearly, we
might as well choose the root to have label <span class="math inline">\(1\)</span>, and every time we
descend from a parent to a child, we must multiply by some integer,
which might as well be a prime. Of course, we need to multiply by a
<em>different</em> prime for each sibling. We might at first imagine simply
multiplying by 2 for each (arbitrarily chosen) leftmost child, 3 for
each second child, 5 for each third child, and so on, but this does
not work—the second child of the first child ends up with the same
label as the first child of the second child, and so on.</p>
<p>Each node <span class="math inline">\(u\)</span>’s label is some prime <span class="math inline">\(p\)</span> times its parent’s label; call
<span class="math inline">\(p\)</span> the <em>factor</em> of node <span class="math inline">\(u\)</span>. It is OK for one child of <span class="math inline">\(u\)</span> to also
have factor <span class="math inline">\(p\)</span>, but the other children must get different factors.
To be safe, we can give each additional child a new <em>globally unique</em>
prime factor. This is not always necessary—in some cases it can be
OK to reuse a factor if it does not lead to identically numbered
nodes—but it is certainly sufficient. As an example, below is a
divisor labelling of the example tree from before, via this scheme.
Each edge is labelled with the factor of its child.</p>
<p><span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="marginnote">Divisor labelling of a tree with consecutive primes<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/13d7ee7b4e591669.svg" />
</figure>
<p>Notice how we use <span class="math inline">\(2\)</span> for the first child of the root, and <span class="math inline">\(3\)</span> for the
next child. <span class="math inline">\(3\)</span>’s first child can also use a factor of <span class="math inline">\(3\)</span>, yielding
a label of <span class="math inline">\(3^2 = 9\)</span>. <span class="math inline">\(3\)</span>’s next child uses a new, globally unique
prime <span class="math inline">\(5\)</span>, and its third child uses <span class="math inline">\(7\)</span>; the final child of <span class="math inline">\(1\)</span> uses
the next available prime, <span class="math inline">\(11\)</span>.</p>
<p>We can code this up via a simple stateful traversal of the tree. (For
<code>primes</code>, see <a href="https://byorgey.github.io/blog/posts/2020/02/07/competitive-programming-in-haskell-primes-and-factoring.html">this
post</a>.)
It’s a bit fiddly since we have to switch to the next prime <em>between</em>
consecutive children, but not <em>after</em> the last child.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">curPrime ::</span> <span class="dt">State</span> [<span class="dt">Integer</span>] <span class="dt">Integer</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>curPrime <span class="ot">=</span> gets <span class="fu">head</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="ot">nextPrime ::</span> <span class="dt">State</span> [<span class="dt">Integer</span>] ()</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>nextPrime <span class="ot">=</span> modify <span class="fu">tail</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="ot">labelTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Integer</span>, a)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>labelTree <span class="ot">=</span> <span class="fu">flip</span> evalState primes <span class="op">.</span> go <span class="dv">1</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Integer</span>] (<span class="dt">Tree</span> (<span class="dt">Integer</span>, a))</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  go x (<span class="dt">Node</span> a ts) <span class="ot">=</span> <span class="dt">Node</span> (x, a) <span class="op">&lt;$&gt;</span> labelChildren x ts</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  labelChildren ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Integer</span>] [<span class="dt">Tree</span> (<span class="dt">Integer</span>, a)]</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  labelChildren _ [] <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  labelChildren x (t <span class="op">:</span> ts) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    p <span class="ot">&lt;-</span> curPrime</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    t&#39; <span class="ot">&lt;-</span> go (x <span class="op">*</span> p) t</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ts <span class="kw">of</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>      [] <span class="ot">-&gt;</span> <span class="fu">pure</span> [t&#39;]</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        nextPrime</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        (t&#39; <span class="op">:</span>) <span class="op">&lt;$&gt;</span> labelChildren x ts</span></code></pre></div>
<p>There is a bit of additional glue code we need get the parsed tree
from the input, apply <code>labelTree</code>, and then print out the node
labels in order. However, I’m not going to bother showing it,
because—this solution is not accepted! It fails with a WA (Wrong
Answer) verdict. What gives?</p>
</section>
<section id="keeping-things-small" class="level2">
<h2>Keeping things small</h2>
<p>The key is one of the last sentences in the problem statement, which I
haven’t mentioned so far: all the labels in our output must be at most
<span class="math inline">\(10^{18}\)</span>. Why is this a problem? Multiplying by primes over and
over again, it’s not hard to get rather large numbers. For example,
consider the tree below:</p>
<p><span class="sidenote-wrapper"><label for="sn-4" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="marginnote">Tree for which our naïve scheme generates labels that are too large<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/93210957d4a3e60e.svg" />
</figure>
<p>Under our scheme, the root gets label <span class="math inline">\(1\)</span>, and the children of the
root get consecutive primes <span class="math inline">\(2, 3, 5, \dots, 29\)</span>. Then the nodes
in the long chain hanging off the last sibling get labels <span class="math inline">\(29^2, 29^3, \dots, 29^{13}\)</span>, and <span class="math inline">\(29^{13}\)</span> is too big—in fact, it is
approximately <span class="math inline">\(10^{19}\)</span>. And this tree has only 23 nodes; in general
the input can have up to 60.</p>
<p>Of course, <span class="math inline">\(29\)</span> was a poor choice of factor for such a long chain—we
should have instead labelled the long chain with powers of,
say, 2. Notice that if we have a “tree” consisting of a single long
chain of 60 nodes (and you can bet this is one of the secret test
inputs!), we just barely get by labelling it with powers of two from
<span class="math inline">\(2^0\)</span> up to <span class="math inline">\(2^{59}\)</span>: in fact <span class="math inline">\(2^{59} &lt; 10^{18} &lt; 2^{60}\)</span>. So in
general, we want to find a way to label long chains with small primes,
and reserve larger primes for shorter chains.</p>
</section>
<section id="attempt-1-sorting-by-height" class="level2">
<h2>Attempt 1: sorting by height</h2>
<p>One obvious approach is to simply sort the children at each node by
decreasing height, before traversing the tree to assign prime
factors. This handles the above example correctly, since the long
chain would be sorted to the front and assigned the factor 2.
However, this does not work in general! It can still fail to assign
the smallest primes to the longest chains. As a simple example,
consider this tree, in which the children of every node are already
sorted by decreasing height from left to right:</p>
<p><span class="sidenote-wrapper"><label for="sn-5" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="marginnote">Tree for which sorting by height first does not work<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/6bb8ef474a78c853.svg" />
</figure>
<p>The straightforward traversal algorithm indeed assigns powers of 2 to
the left spine of the tree, but it then assigns 3, 5, 7, and so on to
all the tiny spurs hanging off it. So by the time we get to other long
chain hanging off the root, it is assigned powers of <span class="math inline">\(43\)</span>, which are
too big. In fact, we want to assign powers of 2 to the left spine,
powers of 3 to the chain on the right, and then use the rest of the
primes for all the short spurs. But this sort of “non-local”
labelling means we can’t assign primes via a tree traversal.</p>
<p>To drive this point home, here’s another example tree. This one is
small enough that it probably doesn’t matter too much how we label it,
but it’s worth thinking about how to label the longest chains with the
smallest primes. I’ve drawn it in a “left-leaning” style to further
emphasize the different chains that are involved.</p>
<p><span class="sidenote-wrapper"><label for="sn-6" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="marginnote">Tree with chains of various lengths<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/45540cc73cab6222.svg" />
</figure>
<p>In fact, we want to assign the factor 2 to the long chain on the left;
then the factor 3 to the second-longest chain, in the fourth column;
then 5 to the length-6 chain in the second column; 7 to the length-3
chain all the way on the right; and finally 11 to the smallest chain, in column 3.</p>
<p>In general, then, we want a way to <em>decompose</em> an arbitrary tree into
chains, where we repeatedly identify the longest chain, remove it from
consideration, and then identify the longest chain from the remaining
nodes, and so on. Once we have decomposed a tree into chains, it will
be a relatively simple matter to sort the chains by length and assign
consecutive prime factors.</p>
<p>This decomposition occasionally comes in handy (for example, see
<a href="https://open.kattis.com/problems/floatingformation">Floating
Formation</a>), and
belongs to a larger family of important tree decomposition techniques
such as <a href="https://cp-algorithms.com/graph/hld.html">heavy-light
decomposition</a>. Next time,
I’ll demonstrate how to implement such tree decompositions in Haskell!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: tree path decomposition, part I" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 11 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Products with unordered n-tuples</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/25/unordered-n-tuple-product.html</link>
    <description><![CDATA[
<h1>Products with unordered n-tuples</h1>

<div class="info">
  Posted on June 25, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;type-level programming&#39;." href="/tag/type-level%20programming.html" rel="tag">type-level programming</a>, <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;product&#39;." href="/tag/product.html" rel="tag">product</a>, <a title="All pages tagged &#39;unordered&#39;." href="/tag/unordered.html" rel="tag">unordered</a>, <a title="All pages tagged &#39;tuples&#39;." href="/tag/tuples.html" rel="tag">tuples</a>
  
</div>

<section>
<p>Recently, Dani Rybe wrote <a href="https://danryba253.github.io/danirybeblog/posts/unordered-n-tuples/">this really cool blog
post</a>
(in turn based on <a href="https://gelisam.blogspot.com/2013/07/the-commutative-monad.html">this old post by Samuel
Gélineau</a>)
about encoding truly <em>unordered</em> n-tuples in Haskell. This is
something I thought about a long time ago in my work on
combinatorial species, but I never came up with a way to represent
them. Samuel and Dani’s solution is wonderful and clever and totally
impractical, and I love it.</p>
<p>I won’t go into more detail than that; I’ll let you go read it if
you’re interested. This blog post exists solely to respond to Dani’s
statement towards the end of her post:</p>
<blockquote>
<p>I’m not sure how to, for example, write a function that multiplies
the inputs.</p>
</blockquote>
<p>Challenge accepted!</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Int</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>mul <span class="ot">=</span> unfuck mulU</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulU ::</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  mulU <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">&lt;</span> <span class="dv">0</span>) \(<span class="dt">US</span> neg nonNeg) <span class="ot">-&gt;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    mulNonNeg nonNeg <span class="op">*</span> mulPos primes (<span class="fu">abs</span> <span class="op">&lt;$&gt;</span> neg) <span class="op">*</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">^</span> ulen neg</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulNonNeg ::</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  mulNonNeg <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">==</span> <span class="dv">0</span>) \(<span class="dt">US</span> zero pos) <span class="ot">-&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> ulen zero <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> mulPos primes pos</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulPos ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  mulPos ps <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">==</span> <span class="dv">1</span>) \(<span class="dt">US</span> _ pos) <span class="ot">-&gt;</span> mulGTOne ps pos</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulGTOne ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  mulGTOne (p <span class="op">:</span> ps) <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> ((<span class="op">==</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) \(<span class="dt">US</span> divP nondivP) <span class="ot">-&gt;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    mulPos (p <span class="op">:</span> ps) ((<span class="ot">`div`</span> p) <span class="op">&lt;$&gt;</span> divP) <span class="op">*</span> (p <span class="op">^</span> ulen divP) <span class="op">*</span> mulGTOne ps nondivP</span></code></pre></div>
<p>Since every integer has a unique prime factorization, at each step we
split the remaining numbers into those divisible by <span class="math inline">\(p\)</span> and those not
divisible by <span class="math inline">\(p\)</span>. For the ones that are, we divide out <span class="math inline">\(p\)</span> from all
of them, multiply by the appropriate power of <span class="math inline">\(p\)</span>, and recurse on
what’s left; for those that are not, we move on to trying the next
prime.</p>
<p>Dani also speculates about <code>ubind :: U n (U m a) -&gt; U (n :*: m) a</code>. I
believe in my heart this should be possible to implement, but after
playing with it a bit, I concluded it would require an astounding feat
of type-fu.</p>
<p>PS I’m working on getting comments set up here on my new
blog… hopefully coming soon!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Products with unordered n-tuples" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 25 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/25/unordered-n-tuple-product.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: sieving with mutable arrays</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/21/cpih-product-divisors.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: sieving with mutable arrays</h1>

<div class="info">
  Posted on June 21, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;sieve&#39;." href="/tag/sieve.html" rel="tag">sieve</a>, <a title="All pages tagged &#39;mutable array&#39;." href="/tag/mutable%20array.html" rel="tag">mutable array</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">a previous
post</a>
I challenged you to solve <a href="https://open.kattis.com/problems/productdivisors">Product
Divisors</a>. In this
problem, we are given a sequence of positive integers <span class="math inline">\(a_1, \dots, a_n\)</span>, and we are asked to compute the total number of divisors of
their product. For example, if we are given the numbers <span class="math inline">\(4, 2, 3\)</span>,
then the answer should be <span class="math inline">\(8\)</span>, since <span class="math inline">\(4 \times 2 \times 3 = 24\)</span> has
the <span class="math inline">\(8\)</span> distinct divisors <span class="math inline">\(1, 2, 3, 4, 6, 8, 12, 24\)</span>.</p>
<section id="counting-divisors" class="level2">
<h2>Counting divisors</h2>
<p>In general, if <span class="math inline">\(a\)</span> has the prime factorization <span class="math inline">\(a = p_1^{\alpha_1} p_2^{\alpha_2} \cdots p_k^{\alpha_k}\)</span> (where the <span class="math inline">\(p_i\)</span> are all distinct primes), then
the number of divisors of <span class="math inline">\(a\)</span> is</p>
<p><span class="math display">\[(\alpha_1 + 1)(\alpha_2 + 1) \cdots (\alpha_k + 1),\]</span></p>
<p>since we can independently choose how many powers of each prime to
include. There are <span class="math inline">\(\alpha_i + 1\)</span> choices for <span class="math inline">\(p_i\)</span> since we can
choose anything from <span class="math inline">\(p_i^0\)</span> up to <span class="math inline">\(p_i^{\alpha_i}\)</span>, inclusive.</p>
<p>So at a fundamental level, the solution is clear: factor each <span class="math inline">\(a_i\)</span>,
count up the number of copies of each prime in their product, then do
something like <code>map (+1) &gt;&gt;&gt; product</code>. We are also told the answer
should be given mod <span class="math inline">\(10^9 + 7\)</span>, so we can use a<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Using <code>Int</code>
instead of <code>Integer</code> here is OK as long as we are sure to be running
on a 64-bit system; multiplying two <code>Int</code> values up to <span class="math inline">\(10^9 + 7\)</span>
yields a result that still fits within a 64-bit signed <code>Int</code>.
Otherwise (<em>e.g.</em> <a href="https://byorgey.github.io/blog/posts/2021/09/21/competitive-programming-in-haskell-codeforces-educational-round-114.html">on Codeforces</a>) we would have to use <code>Integer</code>.<br />
<br />
</span></span> <a href="https://byorgey.github.io/blog/posts/2020/02/15/competitive-programming-in-haskell-modular-arithmetic-part-1.html"><code>newtype</code> with a
custom <code>Num</code> instance</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="dv">10</span><span class="op">^</span><span class="dv">9</span> <span class="op">+</span> <span class="dv">7</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> {<span class="ot"> unM ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">M</span> <span class="kw">where</span> <span class="fu">show</span> <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> unM</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">M</span> <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">M</span> <span class="op">.</span> (<span class="ot">`mod`</span> p) <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">+</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">+</span> y) <span class="ot">`mod`</span> p)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">-</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">-</span> y) <span class="ot">`mod`</span> p)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">*</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">*</span> y) <span class="ot">`mod`</span> p)</span></code></pre></div>
</section>
<section id="a-naïve-solution-tle" class="level2">
<h2>A naïve solution (TLE)</h2>
<p>Of course, I would not be writing about this problem if it were that
easy! If we try implementing the above solution idea in a
straightforward way—for example, if we <a href="https://byorgey.wordpress.com/2020/02/07/competitive-programming-in-haskell-primes-and-factoring/">take the simple factoring code from this blog
post</a>
and then do something like <code>map factor &gt;&gt;&gt; M.unionsWith (+) &gt;&gt;&gt; M.elems &gt;&gt;&gt; map (+1) &gt;&gt;&gt; product</code>, we get the dreaded Time Limit Exceeded.</p>
<p>Why doesn’t this work? I haven’t mentioned how many integers might be
in the input: in fact, we might be given as many as one million (<span class="math inline">\(10^6\)</span>)! We need
to be able to factor each number very quickly if we’re going to finish
within the one second time limit. Factoring each number from scratch
by trial division is simply too slow.</p>
</section>
<section id="factoring-via-sieve" class="level2">
<h2>Factoring via sieve</h2>
<p>While <a href="https://cp-algorithms.com/algebra/factorization.html">more sophisticated methods</a> are needed to factor a <em>single</em>
number more quickly than trial division, there is a standard technique
we can use to speed things up when we need to factor <em>many</em> numbers.
We can use a <em>sieve</em> to precompute a lookup table, which we can then
use to factor numbers very quickly.</p>
<p>In particular, we will compute a table <span class="math inline">\(\mathit{smallest}\)</span> such that
<span class="math inline">\(\mathit{smallest}[i]\)</span> will store the <em>smallest prime factor</em> of <span class="math inline">\(i\)</span>.
Given this table, to factor a positive integer <span class="math inline">\(i\)</span>, we simply look up
<span class="math inline">\(\mathit{smallest}[i] = p\)</span>, add it to the prime factorization, then
recurse on <span class="math inline">\(i/p\)</span>; the base case is when <span class="math inline">\(i = 1\)</span>.</p>
<p>How do we compute <span class="math inline">\(\mathit{smallest}\)</span>? The basic idea is to create an
array of size <span class="math inline">\(n\)</span>, initializing it with <span class="math inline">\(\mathit{smallest}[k] = k\)</span>. For each <span class="math inline">\(k\)</span> from <span class="math inline">\(2\)</span> up to <span class="math inline">\(n\)</span>,<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">We could optimize this even
further via the <a href="https://codeforces.com/blog/entry/54090">approach in this blog
post</a>, which takes <span class="math inline">\(O(n)\)</span>
rather than <span class="math inline">\(O(n \lg n)\)</span> time, but it would complicate our Haskell
quite a bit and it’s not needed for solving this problem.<br />
<br />
</span></span> if
<span class="math inline">\(\mathit{smallest}[k]\)</span> is still equal to <span class="math inline">\(k\)</span>, then <span class="math inline">\(k\)</span> must be prime;
iterate through multiples of <span class="math inline">\(k\)</span> (starting with <span class="math inline">\(k^2\)</span>, since any
smaller multiple of <span class="math inline">\(k\)</span> is already divisible by a smaller prime) and
set each <span class="math inline">\(\mathit{smallest}[ki]\)</span> to the minimum of <span class="math inline">\(k\)</span> and whatever
value it had before.</p>
</section>
<section id="sieving-in-haskell" class="level2">
<h2>Sieving in Haskell</h2>
<p>This is one of those cases where for efficiency’s sake, we actually
want to use an honest-to-goodness mutable array. Immutable arrays are
not a good fit for sieving, and using something like a <code>Map</code> would
introduce a lot of overhead that we would rather avoid. However, we
only need the table to be mutable while we are computing it; after
that, it should just be an immutable lookup table. This is a great fit
for an <code>STUArray</code>:<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote">Note that as of this writing, the version of the
<code>array</code> library installed in the Kattis environment does not have
<code>modifyArray'</code>, so we actually have to do <code>readArray</code> followed by
<code>writeArray</code>.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>maxN <span class="ot">=</span> <span class="dv">1000000</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">smallest ::</span> <span class="dt">UArray</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>smallest <span class="ot">=</span> runSTUArray <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newListArray (<span class="dv">2</span>,maxN) [<span class="dv">2</span> <span class="op">..</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  forM_ [<span class="dv">2</span> <span class="op">..</span> maxN] <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    k&#39; <span class="ot">&lt;-</span> readArray a k</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    when (k <span class="op">==</span> k&#39;) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      forM_ [k<span class="op">*</span>k, k<span class="op">*</span>(k<span class="op">+</span><span class="dv">1</span>) <span class="op">..</span> maxN] <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        modifyArray&#39; a n (<span class="fu">min</span> k)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a</span></code></pre></div>
<p>Haskell, the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">world’s finest imperative programming language</a>!</p>
</section>
<section id="combining-factorizations" class="level2">
<h2>Combining factorizations</h2>
<p>We can now write a new <code>factor</code> function that works by repeatedly
looking up the smallest prime factor:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span> <span class="ot">-&gt;</span> M.empty</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) p <span class="dv">1</span> (factor (n <span class="ot">`div`</span> p))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    p <span class="ot">=</span> smallest<span class="op">!</span>n</span></code></pre></div>
<p>And now we can just do <code>map factor &gt;&gt;&gt; M.unionsWith (+) &gt;&gt;&gt; M.elems &gt;&gt;&gt; map (+1) &gt;&gt;&gt; product</code>
as before, but since our <code>factor</code> is so much faster this time, it
should…</p>
<p>What’s that? Still TLE? Sigh.</p>
</section>
<section id="counting-primes-via-a-second-mutable-array" class="level2">
<h2>Counting primes via a (second) mutable array</h2>
<p>Unfortunately, creating a bunch of <code>Map</code> values and then doing
<code>unionsWith</code> one million times still introduces way too much overhead.
For many problems working with <code>Map</code> (which is impressively fast) is
good enough, but not in this case. Instead of returning a <code>Map</code> from
each call to <code>factor</code> and then later combining them, we can write a version of
<code>factor</code> that directly increments counters for each prime in a
mutable array:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">STUArray</span> s <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>factor counts n <span class="ot">=</span> go n</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    go <span class="dv">1</span> <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    go n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> p <span class="ot">=</span> smallest<span class="op">!</span>n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      modifyArray&#39; counts p (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      go (n <span class="ot">`div`</span> p)</span></code></pre></div>
<p>Then we have the following top-level solution, which is finally fast
enough:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> C.interact <span class="op">$</span> runScanner (numberOf int) <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> showB</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">M</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>solve <span class="ot">=</span> counts <span class="op">&gt;&gt;&gt;</span> elems <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> ((<span class="op">+</span><span class="dv">1</span>) <span class="op">&gt;&gt;&gt;</span> <span class="dt">M</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">product</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">counts ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">UArray</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>counts ns <span class="ot">=</span> runSTUArray <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  cs <span class="ot">&lt;-</span> newArray (<span class="dv">2</span>,maxN) <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  forM_ ns (factor cs)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> cs</span></code></pre></div>
<p>This solution runs in just over 0.4s for me. Considering that this is
only about 4x slower than the fastest solution (0.09s, in C++), I’m
pretty happy with it! We did have to sacrifice a bit of elegance for
speed, especially with the <code>factor</code> and <code>counts</code> functions instead of
<code>M.unionsWith</code>, but in the end it’s not too bad.</p>
<p>I thought we might be able to make this even faster by using a strict
fold over the <code>counts</code> array instead of converting to a list with
<code>elems</code> and then doing a <code>map</code> and a <code>product</code>, but (1) there is no
generic fold operation on <code>UArray</code>, and (2) I trust that GHC is
already doing a pretty good job optimizing this via list fusion.</p>
</section>
<section id="next-time" class="level2">
<h2>Next time</h2>
<p>Next time I’ll write about my solution to the <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">other challenge
problem</a>,
<a href="https://open.kattis.com/problems/factorfulltree">Factor-Full Tree</a>.
Until then, give it a try!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: sieving with mutable arrays" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Fri, 21 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/21/cpih-product-divisors.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Swarm swarm III (virtual hackathon)</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/12/swarm-swarm-3.html</link>
    <description><![CDATA[
<h1>Swarm swarm III (virtual hackathon)</h1>

<div class="info">
  Posted on June 12, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;hackathon&#39;." href="/tag/hackathon.html" rel="tag">hackathon</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>This Saturday, June 15, we will have the third Swarm swarm, <em>i.e.</em>
collaborative virtual hackathon. Details can be found <a href="https://github.com/swarm-game/swarm/wiki/Swarm-swarm">here on the
Swarm wiki</a>.</p>
<ul>
<li>Time: <a href="https://www.timeanddate.com/worldclock/fixedtime.html?msg=Swarm+swarm+III&amp;iso=20240615T16&amp;p1=1440&amp;ah=6">11am-5pm CDT / 4pm-10pm UTC / 9:30pm-3:30am
IST</a>
(feel free to drop in and out any time)</li>
<li>Place: <a href="https://app.gather.town/app/SpqG1ic5pNKM7YqS/The%20Swarm%20Hive">The Swarm Hive on
gather.town</a></li>
<li>Who: you! Anyone interested in hacking on Swarm is welcome, from
experienced to first-time contributors. If you’ve been thinking of
getting involved but haven’t yet, this could be a perfect
opportunity.</li>
</ul>
<p>As a reminder, <a href="https://swarm-game.github.io/">Swarm</a> is a 2D,
open-world programming and resource gathering game, implemented in
Haskell, with a strongly-typed, functional programming language and a
unique upgrade system. Unlocking language features is tied to
collecting resources, making it an interesting challenge to bootstrap
your way into the use of the full language.</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Swarm swarm III (virtual hackathon)" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Wed, 12 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/12/swarm-swarm-3.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Two Hard Problems</title>
    <link>http://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Two Hard Problems</h1>

<div class="info">
  Posted on May 28, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>
  
</div>

<section>
<p>I haven’t written here in a while—partly due to being busy, but also
partly due to getting sick of Wordpress and deciding it was finally
time to rebuild my blog from scratch using
<a href="https://jaspervdj.be/hakyll/">Hakyll</a>. I still haven’t quite worked
out what I’m doing about comments (I looked into
<a href="https://isso-comments.de/">Isso</a> but haven’t gotten it to work
yet—if you have used it successfully, let me know!).</p>
<p>For today I have two hard competitive programming challenge problems
for you. Both involve some number theory, and both are fairly
challenging, but that’s about all they have in common!</p>
<ul>
<li><a href="https://open.kattis.com/problems/productdivisors">Product Divisors</a></li>
<li><a href="https://open.kattis.com/problems/factorfulltree">Factor-Full Tree</a></li>
</ul>
<p>Since there are no comments (for now), feel free to email me with your
thoughts. I’ll post my solutions (with commentary) in a later post or
two!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: Two Hard Problems" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 28 May 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Swarm 0.4 release</title>
    <link>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</link>
    <description><![CDATA[
<h1>Swarm 0.4 release</h1>

<div class="info">
  Posted on August 22, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;resource&#39;." href="/tag/resource.html" rel="tag">resource</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>
The <a href="https://github.com/swarm-game/swarm/">Swarm</a> development team is very proud to announce the latest release of the game. This should still be considered a development/preview release—you still can’t <a href="https://github.com/swarm-game/swarm/issues/50">save your games</a>—but it’s made some remarkable progress and there are lots of fun things to try.
</p>
<h2 id="what-is-it">
What is it?
</h2>
<p>
As a reminder, Swarm is a 2D, open-world programming and resource gathering game with a strongly-typed, functional programming language and a unique upgrade system. Unlocking language features is tied to collecting resources, making it an interesting challenge to bootstrap your way into the use of the full language. It has also become a flexible and powerful platform for constructing programming challenges.
</p>
<p>
A few of the most significant new features are highlighted below; for full details, see the <a href="https://github.com/swarm-game/swarm/releases/tag/0.4.0.0">release notes</a>. If you just want to try it out, see the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>.
</p>
<h2 id="expanded-design-possibilities">
Expanded design possibilities
</h2>
<p>
The default play mode is the open-world, resource-gathering scenario—but Swarm also supports “challenge scenarios”, where you have to complete one or more specific objectives with given resources on a custom map. There are currently 58 scenarios and counting—some are silly proofs of concept, but many are quite fun and challenging! I especially recommend checking out the <code>Ranching</code> and <code>Sokoban</code> scenarios, as well as <code>A Frivolous Excursion</code> (pictured below). And creating new scenarios is a great way you can contribute to Swarm even if you don’t know Haskell, or aren’t comfortable hacking on the codebase.
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/excursion.png" />
</p>
</div>
<p>
Recently, a large amount of work has gone into expanding the possibilities for scenario design:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1332">Structure templates</a> allow you to design map tiles and then reuse them multiple times within a scenario.
</li>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1356">Waypoints and portals</a> provide a mechanism for automatically navigating and teleporting around the world.
</li>
<li>
Scenarios can have multiple <a href="https://github.com/swarm-game/swarm/pull/1353">subworlds</a> besides the main “overworld”, connected by portals. For example you could go “into a building” and have a separate map for the building interior.
</li>
<li>
There are a slew of new robot commands, many to do with different sensing modalities: <code>stride</code>, <code>detect</code>, <code>sniff</code>, <code>chirp,</code> <code>resonate</code>, <code>watch</code>, <code>surveil</code>, <code>scout</code>, <code>instant</code>, <code>push</code>, <code>density</code>, <code>use</code>, <code>halt</code>, and <code>backup</code>.
</li>
<li>
A <a href="https://github.com/swarm-game/swarm/pull/1376">new domain-specific language</a> for describing procedurally generated worlds. The default procedurally generated world used to be hardcoded, but now it is described externally via the new DSL, and you can design your own procedurally generated worlds without editing the Swarm source code.
</li>
<li>
The <a href="https://github.com/swarm-game/swarm/pull/1214">key input handler</a> feature allows you to program robots to respond to keyboard input, so you can <em>e.g.</em> drive them around manually, or interactively trigger more complex behaviors. This makes it possible to design “arcade-style” challenges, where the player needs to guide a robot and react to obstacles in real time—but they get to program the robot to respond to their commands first!
</li>
<li>
A new prototype <a href="https://github.com/swarm-game/swarm/pull/873">integrated world editor</a> lets you design worlds interactively.
</li>
</ul>
<h2 id="ui-improvements">
UI improvements
</h2>
<p>
In the past, entity and goal descriptions were simply plain text; recently, we switched to actually parsing Markdown. Partly, this is just to make things look nice, since we can highlight code snippets, entity names, etc.:
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/crafting.png" />
</p>
</div>
<p>
But it also means that we can now validate all code examples and entity names, and even test that the tutorial is pedagogically sound: any command used in a tutorial solution must be mentioned in a previous tutorial, or else our CI fails!
</p>
<p>
There are also a number of other small UI enhancements, such as improved type error messages, inventory search, and a collapsible REPL panel, among others.
</p>
<h2 id="scoring-metrics">
Scoring metrics
</h2>
<p>
We now keep track of a number of metrics related to challenge scenario solutions, such as total time, total game ticks, and code size. These metrics are tracked and saved across runs, so you can compete with yourself, and with others. For now, see these wiki pages:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Speedrunning">Swarm speedrunning</a>
</li>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Code-golf">Swarm code golf</a>
</li>
</ul>
<p>
In the future, perhaps there will eventually be some kind of <a href="https://github.com/swarm-game/swarm/issues/1259">social website</a> with leaderboards and user-uploaded scenarios.
</p>
<h2 id="debugging">
Debugging
</h2>
<p>
Last but not least, we now have an <a href="https://github.com/swarm-game/swarm/pull/1081">integrated single-stepping and debugging mode</a> (enabled by the <code>tweezers</code> device).
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/debugger.png" />
</p>
</div>
<h2 id="give-it-a-try">
Give it a try!
</h2>
<p>
To install, check out the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>: you can download a <a href="https://github.com/swarm-game/swarm/releases">binary release</a> (for now, Linux only, but MacOS binaries should be on the horizon), or <a href="https://hackage.haskell.org/package/swarm">install from Hackage</a>. Give it a try and send us your feedback, either <a href="https://github.com/swarm-game/swarm/issues/new/choose">via a github issue</a> or <a href="https://web.libera.chat/?channels=#swarm">IRC</a>!
</p>
<h2 id="future-plans-getting-involved">
Future plans &amp; getting involved
</h2>
<p>
We’re still hard at work on the game. Fun upcoming things include:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/issues/50">Saving and loading games</a>
</li>
<li>
New world features like aliens and <a href="https://github.com/swarm-game/swarm/issues/112">cities</a>
</li>
<li>
New language features like <a href="https://github.com/swarm-game/swarm/issues/154">recursive types</a>, <a href="https://github.com/swarm-game/swarm/issues/98">arrays</a>, <a href="https://github.com/swarm-game/swarm/issues/94">inter-robot communication</a>, and <a href="https://github.com/swarm-game/swarm/issues/495">a proper <code>import</code> construct</a>
</li>
</ul>
<p>
Of course, there are also <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">tons of small things that need fixing and polishing</a> too! If you’re interested in getting involved, check out our <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">contribution guide</a>, come <a href="https://web.libera.chat/?channels=#swarm">join us on IRC</a> (<code>#swarm</code> on Libera.Chat), or take a look at the list of <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">issues marked “low-hanging fruit”</a>.
</p>
<p>
Brought to you by the Swarm development team:
</p>
<ul>
<li>
Brent Yorgey
</li>
<li>
Karl Ostmo
</li>
<li>
Ondřej Šebek
</li>
</ul>
<p>
With contributions from:
</p>
<ul>
<li>
Alexander Block
</li>
<li>
Brian Wignall
</li>
<li>
Chris Casinghino
</li>
<li>
Daniel Díaz Carrete
</li>
<li>
Huw Campbell
</li>
<li>
Ishan Bhanuka
</li>
<li>
Jacob
</li>
<li>
Jens Petersen
</li>
<li>
José Rafael Vieira
</li>
<li>
Joshua Price
</li>
<li>
lsmor
</li>
<li>
Noah Yorgey
</li>
<li>
Norbert Dzikowski
</li>
<li>
Paul Brauner
</li>
<li>
Ryan Yates
</li>
<li>
Sam Tay
</li>
<li>
Steven Garcia
</li>
<li>
Tamas Zsar
</li>
<li>
Tristan de Cacqueray
</li>
<li>
Valentin Golev
</li>
</ul>
<p>
…not to mention many others who gave valuable suggestions and feedback. Want to see your name listed here in the next release? <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">See how you can contribute!</a>
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Swarm 0.4 release" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-08-22T17:37:34Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>

    </channel>
</rss>
