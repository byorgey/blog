<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>blog :: Brent -> [String]</title>
        <link>http://byorgey.github.io/blog</link>
        <description><![CDATA[Brent Yorgey's academic blog]]></description>
        <atom:link href="http://byorgey.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 20 Jul 2024 00:00:00 UT</lastBuildDate>
        <item>
    <title>Help me attend ICFP in Milan!</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/20/ko-fi-help-me-attend-icfp.html</link>
    <description><![CDATA[
<h1>Help me attend ICFP in Milan!</h1>

<div class="info">
  Posted on July 20, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;community&#39;." href="/tag/community.html" rel="tag">community</a>, <a title="All pages tagged &#39;contribution&#39;." href="/tag/contribution.html" rel="tag">contribution</a>, <a title="All pages tagged &#39;ICFP&#39;." href="/tag/ICFP.html" rel="tag">ICFP</a>, <a title="All pages tagged &#39;ko-fi&#39;." href="/tag/ko-fi.html" rel="tag">ko-fi</a>, <a title="All pages tagged &#39;open-source&#39;." href="/tag/open-source.html" rel="tag">open-source</a>, <a title="All pages tagged &#39;tips&#39;." href="/tag/tips.html" rel="tag">tips</a>
  
</div>

<section>
<p><strong>tl;dr</strong>: if you appreciate my past or ongoing contributions to the
Haskell community, please consider helping me get to ICFP this year by <a href="https://ko-fi.com/byorgey">donating
via my ko-fi page</a>!</p>
<p><a href="https://ko-fi.com/I3I5KYUQX"><img src="https://ko-fi.com/img/githubbutton_sm.svg" alt="ko-fi" /></a></p>
<p>Working at a <a href="https://www.hendrix.edu/">small liberal arts institution</a>
has some tremendous benefits (close interaction with motivated students,
freedom to pursue the projects I want rather than jump through a bunch
of hoops to get tenure, fantastic colleagues), and I love my job. But
there are also downsides; the biggest ones for me are the difficulty of
securing enough travel funding, and, relatedly, the difficulty of
cultivating and maintaining collaborations.</p>
<p><a href="https://byorgey.github.io/blog/posts/2023/05/22/new-ko-fi-page-help-me-attend-icfp.html">Last
year</a>
I was very grateful for people’s generosity in helping me get to
Seattle. I am planning to again attend <a href="https://icfp24.sigplan.org/">ICFP in Milan this
September</a>; this time I will even bring
some students along. I have once again secured some funding from my
institution, but it will not be enough to cover all the expenses.</p>
<p>So, if you have been positively impacted by my
contributions to the Haskell community (<em>e.g.</em> <a href="https://www.cis.upenn.edu/~cis1940/spring13/">CIS
194</a>, the
<a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>,
<a href="https://diagrams.github.io/">diagrams</a>,
<a href="https://hackage.haskell.org/package/split">split</a>,
<a href="https://hackage.haskell.org/package/MonadRandom">MonadRandom</a>, <a href="https://byorgey.github.io/blog/posts/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy.html">burrito
metaphors</a>…)
and/or would like to support my ongoing work (<a href="https://byorgey.github.io/blog/tag/Kattis.html">competitive programming
in
Haskell</a>,
<a href="https://github.com/swarm-game/swarm/#readme">swarm</a>,
<a href="https://github.com/disco-lang/disco/#readme">disco</a>, <a href="https://hackage.haskell.org/user/BrentYorgey">ongoing package
maintenance</a>…), and are
able to express that appreciation or support with a <a href="https://ko-fi.com/byorgey">donation of any
size</a> to help me get to ICFP, I would really appreciate it!</p>
<p>Thank you, friends — I hope to see many people in Milan! Next up:
I will soon publish another post about <a href="https://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html">tree path decomposition</a>!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Help me attend ICFP in Milan!" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Sat, 20 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/20/ko-fi-help-me-attend-icfp.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Rivers: eventually constant streams in Haskell</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/18/River.html</link>
    <description><![CDATA[
<h1>Rivers: eventually constant streams in Haskell</h1>

<div class="info">
  Posted on July 18, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;stream&#39;." href="/tag/stream.html" rel="tag">stream</a>, <a title="All pages tagged &#39;river&#39;." href="/tag/river.html" rel="tag">river</a>, <a title="All pages tagged &#39;eventually&#39;." href="/tag/eventually.html" rel="tag">eventually</a>, <a title="All pages tagged &#39;constant&#39;." href="/tag/constant.html" rel="tag">constant</a>, <a title="All pages tagged &#39;binary&#39;." href="/tag/binary.html" rel="tag">binary</a>, <a title="All pages tagged &#39;2-adic&#39;." href="/tag/2-adic.html" rel="tag">2-adic</a>, <a title="All pages tagged &#39;p-adic&#39;." href="/tag/p-adic.html" rel="tag">p-adic</a>
  
</div>

<section>
<p>Lately I’ve been thinking about representing <em>eventually constant
streams</em> in Haskell. An eventually constant stream is an infinite
stream which eventually, after some finite prefix, starts repeating
the same value forever. For example,</p>
<p><span class="math inline">\(6, 8, 2, 9, 3, 1, 1, 1, 1, \dots\)</span></p>
<p>There are many things we can do in a
decidable way with eventually constant streams that we can’t do with
infinite streams in general—for example, test them for equality.</p>
<p>This is a work in progress. I only have one specific use case in mind
(infinite-precision two’s complement arithmetic, explained at the end
of the post), so I would love to hear of other potential use cases, or
any other feedback. Depending on the feedback I may eventually turn
this into a package on Hackage.</p>
<p>This blog post is typeset from a literate Haskell file; if you want to
play along you can <a href="https://github.com/byorgey/blog/blob/main/posts/2024/07/16/River.lhs">download the source from GitHub</a>.</p>
<section id="the-river-type" class="level2">
<h2>The <code>River</code> type</h2>
<p>Some preliminaries:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">River</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">All</span> (..), <span class="dt">Any</span> (..))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span> (<span class="dt">Max</span> (..), <span class="dt">Min</span> (..))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (all, and, any, drop, foldMap, maximum, minimum, or, repeat, take, zipWith, (!!))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">P</span></span></code></pre></div>
<p>Now let’s get to the main definition. A value of type <code>River a</code> is
either a constant <code>C a</code>, representing an infinite stream of copies of
<code>a</code>, or a <code>Cons</code> with an <code>a</code> and a <code>River a</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">River</span> a <span class="ot">=</span> <span class="dt">C</span> <span class="op">!</span>a <span class="op">|</span> <span class="dt">Cons</span> <span class="op">!</span>a <span class="op">!</span>(<span class="dt">River</span> a)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>I call this a <code>River</code> since “all <code>River</code>s flow to the <code>C</code>”!</p>
<p>The <a href="https://tech.fpcomplete.com/haskell/tutorial/all-about-strictness/">strictness annotations</a> on the <code>a</code> values just seem like a good
idea in general. The strictness annotation on the <code>River a</code> tail,
however, is more interesting: it’s there to rule out infinite streams<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Although the strictness annotation on the <code>River a</code> is semantically correct, I could imagine not wanting it there for performance reasons; I’d be happy to hear any feedback on this point.<br />
<br />
</span></span>
constructed using only <code>Cons</code>, such as <code>flipflop = Cons 0 (Cons 1 flipflop)</code>. In
other words, the only way to make a non-<a href="https://en.wikibooks.org/wiki/Haskell/Denotational_semantics">bottom</a> value of type <code>Stream a</code> is
to have a finite sequence of <code>Cons</code> finally terminated by <code>C</code>.</p>
<p>We need to be a bit careful here, since there are multiple ways to
represent streams which are semantically supposed to be the same. For
example, <code>Cons 1 (Cons 1 (C 1))</code> and <code>C 1</code> both represent an infinite stream of
all <code>1</code>’s. In general, we have the law</p>
<p><code>C a === Cons a (C a)</code>,</p>
<p>and want to make sure that any functions we write respect this
<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">It would be interesting to try implementing rivers as a higher inductive type, say, in <a href="https://agda.readthedocs.io/en/v2.6.20240714/language/cubical.html">Cubical Agda</a>.<br />
<br />
</span></span>
equivalence, <em>i.e.</em> do not distinguish between such values. This is
the reason I did not derive an <code>Eq</code> instance; we will have to write
our own.</p>
<p>We can partially solve this problem with a <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pattern_synonyms.html"><em>bidirectional pattern
synonym</em></a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">expand ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>expand (<span class="dt">C</span> a) <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">C</span> a)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>expand as <span class="ot">=</span> as</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span><span class="ot"> (:::) ::</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> (<span class="op">:::</span>) a as <span class="ot">&lt;-</span> (expand <span class="ot">-&gt;</span> <span class="dt">Cons</span> a as)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">:::</span> as <span class="ot">=</span> <span class="dt">Cons</span> a as</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# COMPLETE (:::) #-}</span></span></code></pre></div>
<p>Matching with the pattern <code>(a ::: as)</code> uses a <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/view_patterns.html"><em>view pattern</em></a>
to potentially expand a <code>C</code> one step into a <code>Cons</code>, so that we can
pretend all <code>River</code> values are always constructed with <code>(:::)</code>.
In the other direction, <code>(:::)</code> merely constructs a <code>Cons</code>.</p>
<p>We mark <code>(:::)</code> as <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/pragmas.html#complete-pragmas"><code>COMPLETE</code></a> on its own since it is, in fact,
sufficient to handle every possible input of type <code>River</code>. However,
in order to obtain terminating algorithms we will often include one or
more special cases for <code>C</code>.</p>
</section>
<section id="normalization-by-construction" class="level2">
<h2>Normalization by construction?</h2>
<p>As an alternative, we could use a variant pattern synonym:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">::=</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span><span class="ot"> (::=) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> (<span class="op">::=</span>) a as <span class="ot">&lt;-</span> (expand <span class="ot">-&gt;</span> <span class="dt">Cons</span> a as)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    a&#39; <span class="op">::=</span> <span class="dt">C</span> a <span class="op">|</span> a&#39; <span class="op">==</span> a <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    a <span class="op">::=</span> as <span class="ot">=</span> <span class="dt">Cons</span> a as</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# COMPLETE (::=) #-}</span></span></code></pre></div>
<p>As compared to <code>(:::)</code>, this has an extra <code>Eq a</code> constraint: when we
construct a <code>River</code> with <code>(::=)</code>, it checks to see whether we are
consing an identical value onto an existing <code>C a</code>, and if so, simply
returns the <code>C a</code> unchanged. If we always use <code>(::=)</code> instead of
directly using <code>Cons</code>, it ensures that <code>River</code> values are always
<em>normalized</em>—that is, for every eventually constant stream, we
always use the canonical representative where the element immediately
preciding the constant tail is not equal to it.</p>
<p>This, in turn, <em>technically</em> makes it impossible to write functions
which do not respect the equivalence <code>C a === Cons a (C a)</code>, simply
because they will only ever be given canonical rivers as input.
However, as we will see when we discuss folds, it is still possible to
write “bad” functions, <em>i.e.</em> functions that are semantically
questionable as functions on eventually constant streams—it would
just mean we cannot directly observe them behaving badly.</p>
<p>The big downside of using this formulation is that the <code>Eq</code> constraint
infects absolutely everything—we even end up with <code>Eq</code> constraints
in places where we would not expect them (for example, on <code>head :: River a -&gt; a</code>), because the pattern synonym incurs an <code>Eq</code> constraint
anywhere we use it, regardless of whether we are using it to construct
or destruct <code>River</code> values. As you can see from the definition above,
we only do an equality check when using <code>(::=)</code> to construct a
<code>River</code>, not when using it to pattern-match, but there is no way to
give the pattern synonym different types in the two directions.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Of course, we could make it a unidirectional pattern synonym and just make a differently named smart constructor, but that seems somewhat ugly, as we would have to remember which to use in which situation.<br />
<br />
</span></span></p>
<p>So, because this normalizing variant does not really go far enough in
removing our burden of proof, and has some big downsides in the form
of leaking <code>Eq</code> constraints everywhere, I have chosen to stick with
the simpler <code>(:::)</code> in this post. But I am still a bit unsure about this
choice; in fact, I went back and forth two times while writing.</p>
<p>We can at least provide a <code>normalize</code> function, which we can use when
we want to ensure normalization:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalize ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>normalize (<span class="dt">C</span> a) <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>normalize (a <span class="op">::=</span> as) <span class="ot">=</span> a <span class="op">::=</span> as</span></code></pre></div>
</section>
<section id="some-standard-functions-on-rivers" class="level2">
<h2>Some standard functions on rivers</h2>
<p>With the preliminary definitions out of the way, we can now build up a
library of standard functions and instances for working with <code>River a</code>
values. To start, we can write an <code>Eq</code> instance as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">River</span> a) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> a <span class="op">==</span> <span class="dt">C</span> b <span class="ot">=</span> a <span class="op">==</span> b</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  (a <span class="op">:::</span> as) <span class="op">==</span> (b <span class="op">:::</span> bs) <span class="ot">=</span> a <span class="op">==</span> b <span class="op">&amp;&amp;</span> as <span class="op">==</span> bs</span></code></pre></div>
<p>Notice that we only need two cases, not four: if we compare two values
whose finite prefixes are different lengths, the shorter one will
automatically expand (via matching on <code>(:::)</code>) to the length of the
longer.</p>
<p>We already derived a <code>Functor</code> instance; we can also define a “zippy”
<code>Applicative</code> instance like so:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">repeat</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">repeat</span> <span class="ot">=</span> <span class="dt">C</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">River</span> <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">repeat</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> f <span class="op">&lt;*&gt;</span> <span class="dt">C</span> x <span class="ot">=</span> <span class="dt">C</span> (f x)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">:::</span> fs) <span class="op">&lt;*&gt;</span> (x <span class="op">:::</span> xs) <span class="ot">=</span> f x <span class="op">:::</span> (fs <span class="op">&lt;*&gt;</span> xs)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> b <span class="ot">-&gt;</span> <span class="dt">River</span> c</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> <span class="ot">=</span> liftA2</span></code></pre></div>
<p>We can write safe <code>head</code>, <code>tail</code>, and index functions:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (a <span class="op">:::</span> _) <span class="ot">=</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> (_ <span class="op">:::</span> as) <span class="ot">=</span> as</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">9</span> <span class="op">!!</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">(!!) ::</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="dt">C</span> a <span class="op">!!</span> _ <span class="ot">=</span> a</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>(a <span class="op">:::</span> _) <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>(_ <span class="op">:::</span> as) <span class="op">!!</span> n <span class="ot">=</span> as <span class="op">!!</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>We can also write <code>take</code> and <code>drop</code> variants. Note that <code>take</code>
returns a finite prefix of a <code>River</code>, which is a list, not another
<code>River</code>. The special case for <code>drop _ (C a)</code> is not strictly
necessary, but makes it more efficient.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n _ <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> n (a <span class="op">:::</span> as) <span class="ot">=</span> a <span class="op">:</span> <span class="fu">take</span> (n <span class="op">-</span> <span class="dv">1</span>) as</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> n r <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> r</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> _ (<span class="dt">C</span> a) <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="fu">drop</span> n (_ <span class="op">:::</span> as) <span class="ot">=</span> <span class="fu">drop</span> (n <span class="op">-</span> <span class="dv">1</span>) as</span></code></pre></div>
<p>There are many other such functions we could implement (<em>e.g.</em> <code>span</code>,
<code>dropWhile</code>, <code>tails</code>…); if I eventually put this on Hackage I would
be sure to have a much more thorough selection of functions. Which
functions would you want to see?</p>
</section>
<section id="folds-for-river" class="level2">
<h2>Folds for <code>River</code></h2>
<p>How do we fold over a <code>River a</code>? The <code>Foldable</code> type class requires us
to define either <code>foldMap</code> or <code>foldr</code>; let’s think about <code>foldMap</code>,
which would have type</p>
<pre><code>foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; River a -&gt; m</code></pre>
<p>However, this doesn’t really make sense. For example, suppose we have
a <code>River Int</code>; if we had <code>foldMap</code> with the above type, we could use
<code>foldMap Sum</code> to turn our <code>River Int</code> into a <code>Sum Int</code>. But what is
the sum of an infinite stream of <code>Int</code>? Unless the eventually
repeating part is <code>C 0</code>, this is not well-defined. If we simply write
a function to add up all the <code>Int</code> values in a <code>River</code>, including
(once) the value contained in the final <code>C</code>, this would be a good
example of a semantically “bad” function: it does not respect the law
<code>C a === a ::: C a</code>. If we ensure <code>River</code> values are always
normalized, we would not be able to directly observe anything amiss,
but the function still seems suspect.</p>
<p>Thinking about the law <code>C a === a ::: C a</code> again is the key.
Supposing <code>foldMap f (C a) = f a</code> (since it’s unclear what else it
could possibly do), applying <code>foldMap</code> to both sides of the law we
obtain <code>f a == f a &lt;&gt; f a</code>, that is, the combining operation must be
<em>idempotent</em>. This makes sense: with an idempotent operation,
continuing to apply the operation to the infinite constant tail will
not change the answer, so we can simply stop once we reach the <code>C</code>.</p>
<p>We can create a subclass of <code>Semigroup</code> to represent <em>idempotent</em>
semigroups, that is, semigroups for which <code>a &lt;&gt; a = a</code>. There are
several idempotent semigroups in <code>base</code>; we list a few below. Note
that since rivers are never empty, we can get away with just a
semigroup and not a monoid, since we do not need an identity value
onto which to map an empty structure.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Semigroup</span> m <span class="ot">=&gt;</span> <span class="dt">Idempotent</span> m</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- No methods, since Idempotent represents adding only a law,</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- namely, ∀ a. a &lt;&gt; a == a</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Exercise for the reader: convince yourself that these are all</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- idempotent</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Idempotent</span> <span class="dt">All</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Idempotent</span> <span class="dt">Any</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Idempotent</span> <span class="dt">Ordering</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Idempotent</span> (<span class="dt">Max</span> a)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Idempotent</span> (<span class="dt">Min</span> a)</span></code></pre></div>
<p>Now, although we cannot make a <code>Foldable</code> instance, we can write our own
variant of <code>foldMap</code> which requires an idempotent semigroup instead of
a monoid:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span><span class="ot"> ::</span> <span class="dt">Idempotent</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> m</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> f (<span class="dt">C</span> a) <span class="ot">=</span> f a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldMap</span> f (a <span class="op">:::</span> as) <span class="ot">=</span> f a <span class="op">&lt;&gt;</span> <span class="fu">foldMap</span> f as</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fold ::</span> <span class="dt">Idempotent</span> m <span class="ot">=&gt;</span> <span class="dt">River</span> m <span class="ot">-&gt;</span> m</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>fold <span class="ot">=</span> <span class="fu">foldMap</span> <span class="fu">id</span></span></code></pre></div>
<p>We can then instantiate it at some of the semigroups listed above to
get some useful folds. These are all guaranteed to terminate and
yield a sensible answer on any <code>River</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">River</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> <span class="ot">=</span> getAll <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">All</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span><span class="ot"> ::</span> <span class="dt">River</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> <span class="ot">=</span> getAny <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Any</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span> f <span class="ot">=</span> <span class="fu">and</span> <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span> f <span class="ot">=</span> <span class="fu">or</span> <span class="op">.</span> <span class="fu">fmap</span> f</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span> <span class="ot">=</span> getMax <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Max</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="fu">minimum</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="fu">minimum</span> <span class="ot">=</span> getMin <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Min</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="ot">lexicographic ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">River</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>lexicographic xs ys <span class="ot">=</span> fold <span class="op">$</span> <span class="fu">zipWith</span> <span class="fu">compare</span> xs ys</span></code></pre></div>
<p>We could make an <code>instance Ord a =&gt; Ord (River a)</code> with <code>compare = lexicographic</code>; however, in the next section I want to make a
different <code>Ord</code> instance for a specific instantiation of <code>River</code>.</p>
</section>
<section id="application-2-adic-numbers" class="level2">
<h2>Application: <span class="math inline">\(2\)</span>-adic numbers</h2>
<p>Briefly, here’s the particular application I have in mind:
infinite-precision two’s complement arithmetic, <em>i.e.</em> <span class="math inline">\(2\)</span>-adic
numbers. <a href="https://cdsmithus.medium.com/the-collatz-step-and-2-adic-integers-6f003efaf81c">Chris Smith also wrote about <span class="math inline">\(2\)</span>-adic numbers
recently</a>;
however, unlike Chris, I am not interested in <span class="math inline">\(2\)</span>-adic numbers in
general, but only specifically those <span class="math inline">\(2\)</span>-adic numbers which represent
an embedded copy of <span class="math inline">\(\mathbb{Z}\)</span>. These are precisely the eventually
constant ones: nonnegative integers are represented in binary as
usual, with an infinite tail of <span class="math inline">\(0\)</span> bits, and negative integers are
represented with an infinite tail of <span class="math inline">\(1\)</span> bits. For example, <span class="math inline">\(-1\)</span> is
represented as an infinite string of all <span class="math inline">\(1\)</span>’s. The amazing thing
about this representation (and the reason it is commonly used in
hardware) is that the usual addition and multiplication algorithms
continue to work without needing special cases to handle negative
integers. If you’ve never seen how this works, you should definitely
<a href="https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">read</a>
<a href="https://en.wikipedia.org/wiki/Two%27s_complement">about it</a>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bit</span> <span class="ot">=</span> <span class="dt">O</span> <span class="op">|</span> <span class="dt">I</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bits</span> <span class="ot">=</span> <span class="dt">River</span> <span class="dt">Bit</span></span></code></pre></div>
<p>First, some functions to convert to and from integers. We only need
special cases for <span class="math inline">\(0\)</span> and <span class="math inline">\(-1\)</span>, and beyond that it is just the usual
business with <code>mod</code> and <code>div</code> to peel off one bit at a time, or
multiplying by two and adding to build up one bit at a time. (I am a <a href="https://ro-che.info/articles/2014-05-09-clauses">big fan of</a> <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/lambda_case.html"><code>LambdaCase</code></a>.)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toBits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>toBits <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span>  <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">I</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  n  <span class="ot">-&gt;</span> <span class="fu">toEnum</span> (<span class="fu">fromIntegral</span> (n <span class="ot">`mod`</span> <span class="dv">2</span>)) <span class="op">:::</span> toBits (n <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fromBits ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>fromBits <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">I</span> <span class="ot">-&gt;</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  b <span class="op">:::</span> bs <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="op">*</span> fromBits bs <span class="op">+</span> <span class="fu">fromIntegral</span> (<span class="fu">fromEnum</span> b)</span></code></pre></div>
<p>For testing, we can also make a <code>Show</code> instance. When it comes to
showing the infinite constant tail, I chose to repeat the bit 3 times
and then show an ellipsis; this is not really necessary but somehow
helps my brain more easily see whether it is an infinite tail of zeros
or ones.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bits</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="ot">=</span> <span class="fu">reverse</span> <span class="op">.</span> go</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">C</span> b) <span class="ot">=</span> <span class="fu">replicate</span> <span class="dv">3</span> (showBit b) <span class="op">++</span> <span class="st">&quot;...&quot;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    go (b <span class="op">:::</span> bs) <span class="ot">=</span> showBit b <span class="op">:</span> go bs</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    showBit <span class="ot">=</span> (<span class="st">&quot;01&quot;</span> <span class="op">P.!!</span>) <span class="op">.</span> <span class="fu">fromEnum</span></span></code></pre></div>
<p>Let’s try it out:</p>
<pre><code>ghci&gt; toBits 26
...00011010
ghci&gt; toBits (-30)
...11100010
ghci&gt; fromBits (toBits (-30))
-30
ghci&gt; quickCheck $ \x -&gt; fromBits (toBits x) == x
+++ OK, passed 100 tests.</code></pre>
</section>
<section id="arithmetic-on-2-adic-numbers" class="level2">
<h2>Arithmetic on <span class="math inline">\(2\)</span>-adic numbers</h2>
<p>Let’s implement some arithmetic. First, incrementing. It is standard
except for a special case for <code>C I</code> (without which, incrementing <code>C I</code>
would diverge). Notice that we use <code>(::=)</code> instead of <code>(:::)</code>, which
ensures our <code>Bits</code> values remain normalized.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inc ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>inc <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">I</span>      <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">O</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">I</span> <span class="op">::=</span> bs</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> inc bs</span></code></pre></div>
<p><code>dec</code> is similar, just the opposite:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dec ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>dec <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">C</span> <span class="dt">O</span>      <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">I</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> bs</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">O</span> <span class="op">::=</span> bs <span class="ot">-&gt;</span> <span class="dt">I</span> <span class="op">::=</span> dec bs</span></code></pre></div>
<p>Then we can write <code>inv</code> to invert all bits, and <code>neg</code> as the
composition of <code>inc</code> and <code>inv</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inv ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>inv <span class="ot">=</span> <span class="fu">fmap</span> <span class="op">$</span> \<span class="kw">case</span> { <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">I</span>; <span class="dt">I</span> <span class="ot">-&gt;</span> <span class="dt">O</span> }</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">neg ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>neg <span class="ot">=</span> inc <span class="op">.</span> inv</span></code></pre></div>
<p>Trying it out:</p>
<pre><code>λ&gt; toBits 3
...00011
λ&gt; neg it
...11101
λ&gt; inc it
...1110
λ&gt; inc it
...111
λ&gt; inc it
...000
λ&gt; inc it
...0001
λ&gt; dec it
...000
λ&gt; dec it
...111</code></pre>
<p>Finally, addition, multiplication, and <code>Ord</code> and <code>Num</code> instances:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>add <span class="ot">=</span> \cases</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">O</span>)      y          <span class="ot">-&gt;</span> y</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  x          (<span class="dt">C</span> <span class="dt">O</span>)      <span class="ot">-&gt;</span> x</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">I</span>)      (<span class="dt">C</span> <span class="dt">I</span>)      <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> <span class="dt">C</span> <span class="dt">I</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">I</span> <span class="op">::=</span> xs) (<span class="dt">I</span> <span class="op">::=</span> ys) <span class="ot">-&gt;</span> <span class="dt">O</span> <span class="op">::=</span> inc (add xs ys)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  (x <span class="op">::=</span> xs) (y <span class="op">::=</span> ys) <span class="ot">-&gt;</span> (x <span class="op">.|.</span> y) <span class="op">::=</span> add xs ys</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span> <span class="op">.|.</span> _ <span class="ot">=</span> <span class="dt">I</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">.|.</span> y <span class="ot">=</span> y</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>mul <span class="ot">=</span> \cases</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">O</span>)      _     <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  _          (<span class="dt">C</span> <span class="dt">O</span>) <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="dt">O</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">C</span> <span class="dt">I</span>)      y     <span class="ot">-&gt;</span> neg y</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  x          (<span class="dt">C</span> <span class="dt">I</span>) <span class="ot">-&gt;</span> neg x</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">O</span> <span class="op">::=</span> xs) ys    <span class="ot">-&gt;</span>         <span class="dt">O</span> <span class="op">::=</span> mul xs ys</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">I</span> <span class="op">::=</span> xs) ys    <span class="ot">-&gt;</span> add ys (<span class="dt">O</span> <span class="op">::=</span> mul xs ys)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Bits</span> <span class="kw">where</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- It&#39;s a bit mind-boggling that this works</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> (<span class="dt">C</span> x) (<span class="dt">C</span> y) <span class="ot">=</span> <span class="fu">compare</span> y x</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> (x <span class="op">::=</span> xs) (y <span class="op">::=</span> ys) <span class="ot">=</span> <span class="fu">compare</span> xs ys <span class="op">&lt;&gt;</span> <span class="fu">compare</span> x y</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Bits</span> <span class="kw">where</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> toBits</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">negate</span> <span class="ot">=</span> neg</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> add</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>  (<span class="op">*</span>) <span class="ot">=</span> mul</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span> <span class="ot">=</span> toBits <span class="op">.</span> <span class="fu">abs</span> <span class="op">.</span> fromBits</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">signum</span> <span class="ot">=</span> toBits <span class="op">.</span> <span class="fu">signum</span> <span class="op">.</span> fromBits</span></code></pre></div>
<pre><code>λ&gt; quickCheck $ withMaxSuccess 1000 $ \x y -&gt; fromBits (mul (toBits x) (toBits y)) == x * y
+++ OK, passed 1000 tests.
λ&gt; quickCheck $ \x y -&gt; compare (toBits x) (toBits y) == compare x y
+++ OK, passed 100 tests.</code></pre>
<p>Just for fun, let’s implement the Collatz map:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">collatz ::</span> <span class="dt">Bits</span> <span class="ot">-&gt;</span> <span class="dt">Bits</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>collatz (<span class="dt">O</span> <span class="op">::=</span> bs) <span class="ot">=</span> bs</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>collatz bs<span class="op">@</span>(<span class="dt">I</span> <span class="op">::=</span> _) <span class="ot">=</span> <span class="dv">3</span><span class="op">*</span>bs <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<pre><code>λ&gt; P.take 20 $ map fromBits (iterate collatz (toBits (-13)))
[-13,-38,-19,-56,-28,-14,-7,-20,-10,-5,-14,-7,-20,-10,-5,-14,-7,-20,-10,-5]
λ&gt; P.take 20 $ map fromBits (iterate collatz (toBits 7))
[7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1]</code></pre>
</section>
<section id="questions-future-work" class="level2">
<h2>Questions / future work</h2>
<ul>
<li><p>Is <code>(:::)</code> or <code>(::=)</code> the better default? It’s tempting to just say
“provide both and let the user decide”. I don’t disagree with that;
however, the question is which one we use to implement various basic
functions such as <code>map</code>/<code>fmap</code>. For example, if we use <code>(:::)</code>, we
can make a <code>Functor</code> instance, but values may not be normalized
after mapping.</p></li>
<li><p>Can we generalize from eventually constant to eventually <em>periodic</em>?
That is, instead of repeating the same value forever, we cycle
through a repeating period of some finite length. I think this
is possible, but it would make the implementation more
complex, and I don’t know the right way to generalize <code>foldMap</code>. (We
could insist that it only works for <em>commutative</em> idempotent
semigroups, but in that case what’s the point of having a <em>sequence</em>
of values rather than just a set?)</p></li>
</ul>
<p>Happy to hear any comments or suggestions!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Rivers: eventually constant streams in Haskell" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 18 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/18/River.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: tree path decomposition, part I</title>
    <link>http://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: tree path decomposition, part I</h1>

<div class="info">
  Posted on July 11, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;tree&#39;." href="/tag/tree.html" rel="tag">tree</a>, <a title="All pages tagged &#39;path&#39;." href="/tag/path.html" rel="tag">path</a>, <a title="All pages tagged &#39;decomposition&#39;." href="/tag/decomposition.html" rel="tag">decomposition</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">a previous
post</a>
I challenged you to solve <a href="https://open.kattis.com/problems/factorfulltree">Factor-Full
Tree</a>. In this
problem, we are given an unlabelled rooted tree, and asked to create a <em>divisor
labelling</em>. That is, we must label the vertices with positive
integers in such a way that <span class="math inline">\(v\)</span> is an ancestor of <span class="math inline">\(u\)</span> if and only if
<span class="math inline">\(v\)</span>’s label evenly divides <span class="math inline">\(u\)</span>’s label.</p>
<p>For example, here is a tree with a divisor labelling:</p>
<p><span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Divisor labelling of a tree<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/0d43c38705f7e411.svg" />
</figure>
<p>The interesting point (though irrelevant to solving the problem) is
that this is a method for encoding a tree as a set of integers:
because <span class="math inline">\(v\)</span> is an ancestor of <span class="math inline">\(u\)</span> <em>if and only if</em> <span class="math inline">\(v\)</span>’s label divides
<span class="math inline">\(u\)</span>’s, all the information about the tree’s structure is fully
contained in the set of labels. For example, if we simply write
down the set <span class="math inline">\(\{1, 5, 6, 7, 12, 14, 21, 49, 63\}\)</span>, it is possible to
fully reconstruct the above tree from this set.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">Note that we
consider trees equivalent up to reordering of siblings, that is, each
node has a <em>bag</em>, not a <em>list</em>, of children.<br />
<br />
</span></span> This is not a
particularly <em>efficient</em> way to encode a tree, but it is certainly
interesting!</p>
<section id="basic-setup" class="level2">
<h2>Basic setup</h2>
<p>First, some basic setup.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote"><a href="https://byorgey.github.io/blog/posts/2019/05/22/competitive-programming-in-haskell-scanner.html">See here</a> for the <code>Scanner</code>
abstraction, and
<a href="https://byorgey.github.io/blog/posts/2019/04/24/competitive-programming-in-haskell-basic-setup.html">here</a>
for the basics of how I organize solutions.<br />
<br />
</span></span> The first line of
input specifies the number of nodes <span class="math inline">\(N\)</span>, and after that there are
<span class="math inline">\(N-1\)</span> lines, each specifying a single undirected edge.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span> ((&gt;&gt;&gt;))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (second)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>, (!?))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> (swap)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> C.interact <span class="op">$</span> runScanner tc <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> format</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TC</span> <span class="ot">=</span> <span class="dt">TC</span> {<span class="ot"> n ::</span> <span class="dt">Int</span>,<span class="ot"> edges ::</span> [<span class="dt">Edge</span>] }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="ot">tc ::</span> <span class="dt">Scanner</span> <span class="dt">TC</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>tc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> int</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">&lt;-</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">&gt;&lt;</span> pair int int</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">TC</span>{<span class="op">..</span>}</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ot">format ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>format <span class="ot">=</span> <span class="fu">map</span> showB <span class="op">&gt;&gt;&gt;</span> C.unwords</span></code></pre></div>
<p>We are guaranteed that the edges describe a tree; next we will
actually build a tree data structure from the input.</p>
</section>
<section id="building-trees" class="level2">
<h2>Building trees</h2>
<p>There are many
similar problems which specify a tree structure by giving a list of
edges, so it’s worthwhile trying to write some generic code to
transform such an input into an actual tree. In an imperative language
we would do this by building a map from each node to its neighbors,
then doing a DFS to orient the tree. Our Haskell code will be
similar, except building the map and doing a DFS will both be
one-liners!</p>
<p>First, a function to turn a list of undirected edges into a <code>Map</code>
associating each vertex to all its neighbors. It’s convenient to
decompose this into a function to turn a list of <em>directed</em> edges into
a <code>Map</code>, and a function to duplicate and swap each pair. We won’t
need <code>dirEdgesToMap</code> for this problem, but we can certainly imagine
wanting it elsewhere.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>edgesToMap <span class="ot">=</span> <span class="fu">concatMap</span> (\p <span class="ot">-&gt;</span> [p, swap p]) <span class="op">&gt;&gt;&gt;</span> dirEdgesToMap</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dirEdgesToMap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [(a, a)] <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>dirEdgesToMap <span class="ot">=</span> <span class="fu">map</span> (second (<span class="op">:</span> [])) <span class="op">&gt;&gt;&gt;</span> M.fromListWith (<span class="op">++</span>)</span></code></pre></div>
<p>Next, we can turn such a neighbor <code>Map</code> into a tree. Rather than
returning a literal <code>Tree</code> data structure, it’s convenient to
incorporate a tree fold: that is, given a function <code>a -&gt; [b] -&gt; b</code>, a neighbor
map, and a root node, we fold over the whole tree and return the
resulting <code>b</code> value. (Of course, if we want an actual <code>Tree</code> we can use
<code>mapToTree Node</code>.) We can also compose these into a single function <code>edgesToTree</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Map</span> a [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mapToTree nd m root <span class="ot">=</span> dfs root root</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  dfs parent root <span class="ot">=</span> nd root (<span class="fu">maybe</span> [] (<span class="fu">map</span> (dfs root) <span class="op">.</span> <span class="fu">filter</span> (<span class="op">/=</span> parent)) (m <span class="op">!?</span> root))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">edgesToTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [(a, a)] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>edgesToTree nd <span class="ot">=</span> mapToTree nd <span class="op">.</span> edgesToMap</span></code></pre></div>
</section>
<section id="inventing-divisor-labellings" class="level2">
<h2>Inventing divisor labellings</h2>
<p>So how do we create a divisor labelling for a given tree? Clearly, we
might as well choose the root to have label <span class="math inline">\(1\)</span>, and every time we
descend from a parent to a child, we must multiply by some integer,
which might as well be a prime. Of course, we need to multiply by a
<em>different</em> prime for each sibling. We might at first imagine simply
multiplying by 2 for each (arbitrarily chosen) leftmost child, 3 for
each second child, 5 for each third child, and so on, but this does
not work—the second child of the first child ends up with the same
label as the first child of the second child, and so on.</p>
<p>Each node <span class="math inline">\(u\)</span>’s label is some prime <span class="math inline">\(p\)</span> times its parent’s label; call
<span class="math inline">\(p\)</span> the <em>factor</em> of node <span class="math inline">\(u\)</span>. It is OK for one child of <span class="math inline">\(u\)</span> to also
have factor <span class="math inline">\(p\)</span>, but the other children must get different factors.
To be safe, we can give each additional child a new <em>globally unique</em>
prime factor. This is not always necessary—in some cases it can be
OK to reuse a factor if it does not lead to identically numbered
nodes—but it is certainly sufficient. As an example, below is a
divisor labelling of the example tree from before, via this scheme.
Each edge is labelled with the factor of its child.</p>
<p><span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="marginnote">Divisor labelling of a tree with consecutive primes<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/13d7ee7b4e591669.svg" />
</figure>
<p>Notice how we use <span class="math inline">\(2\)</span> for the first child of the root, and <span class="math inline">\(3\)</span> for the
next child. <span class="math inline">\(3\)</span>’s first child can also use a factor of <span class="math inline">\(3\)</span>, yielding
a label of <span class="math inline">\(3^2 = 9\)</span>. <span class="math inline">\(3\)</span>’s next child uses a new, globally unique
prime <span class="math inline">\(5\)</span>, and its third child uses <span class="math inline">\(7\)</span>; the final child of <span class="math inline">\(1\)</span> uses
the next available prime, <span class="math inline">\(11\)</span>.</p>
<p>We can code this up via a simple stateful traversal of the tree. (For
<code>primes</code>, see <a href="https://byorgey.github.io/blog/posts/2020/02/07/competitive-programming-in-haskell-primes-and-factoring.html">this
post</a>.)
It’s a bit fiddly since we have to switch to the next prime <em>between</em>
consecutive children, but not <em>after</em> the last child.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">curPrime ::</span> <span class="dt">State</span> [<span class="dt">Integer</span>] <span class="dt">Integer</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>curPrime <span class="ot">=</span> gets <span class="fu">head</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="ot">nextPrime ::</span> <span class="dt">State</span> [<span class="dt">Integer</span>] ()</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>nextPrime <span class="ot">=</span> modify <span class="fu">tail</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="ot">labelTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Integer</span>, a)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>labelTree <span class="ot">=</span> <span class="fu">flip</span> evalState primes <span class="op">.</span> go <span class="dv">1</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Integer</span>] (<span class="dt">Tree</span> (<span class="dt">Integer</span>, a))</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  go x (<span class="dt">Node</span> a ts) <span class="ot">=</span> <span class="dt">Node</span> (x, a) <span class="op">&lt;$&gt;</span> labelChildren x ts</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  labelChildren ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Integer</span>] [<span class="dt">Tree</span> (<span class="dt">Integer</span>, a)]</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  labelChildren _ [] <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  labelChildren x (t <span class="op">:</span> ts) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    p <span class="ot">&lt;-</span> curPrime</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    t&#39; <span class="ot">&lt;-</span> go (x <span class="op">*</span> p) t</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ts <span class="kw">of</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>      [] <span class="ot">-&gt;</span> <span class="fu">pure</span> [t&#39;]</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        nextPrime</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        (t&#39; <span class="op">:</span>) <span class="op">&lt;$&gt;</span> labelChildren x ts</span></code></pre></div>
<p>There is a bit of additional glue code we need get the parsed tree
from the input, apply <code>labelTree</code>, and then print out the node
labels in order. However, I’m not going to bother showing it,
because—this solution is not accepted! It fails with a WA (Wrong
Answer) verdict. What gives?</p>
</section>
<section id="keeping-things-small" class="level2">
<h2>Keeping things small</h2>
<p>The key is one of the last sentences in the problem statement, which I
haven’t mentioned so far: all the labels in our output must be at most
<span class="math inline">\(10^{18}\)</span>. Why is this a problem? Multiplying by primes over and
over again, it’s not hard to get rather large numbers. For example,
consider the tree below:</p>
<p><span class="sidenote-wrapper"><label for="sn-4" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="marginnote">Tree for which our naïve scheme generates labels that are too large<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/93210957d4a3e60e.svg" />
</figure>
<p>Under our scheme, the root gets label <span class="math inline">\(1\)</span>, and the children of the
root get consecutive primes <span class="math inline">\(2, 3, 5, \dots, 29\)</span>. Then the nodes
in the long chain hanging off the last sibling get labels <span class="math inline">\(29^2, 29^3, \dots, 29^{13}\)</span>, and <span class="math inline">\(29^{13}\)</span> is too big—in fact, it is
approximately <span class="math inline">\(10^{19}\)</span>. And this tree has only 23 nodes; in general
the input can have up to 60.</p>
<p>Of course, <span class="math inline">\(29\)</span> was a poor choice of factor for such a long chain—we
should have instead labelled the long chain with powers of,
say, 2. Notice that if we have a “tree” consisting of a single long
chain of 60 nodes (and you can bet this is one of the secret test
inputs!), we just barely get by labelling it with powers of two from
<span class="math inline">\(2^0\)</span> up to <span class="math inline">\(2^{59}\)</span>: in fact <span class="math inline">\(2^{59} &lt; 10^{18} &lt; 2^{60}\)</span>. So in
general, we want to find a way to label long chains with small primes,
and reserve larger primes for shorter chains.</p>
</section>
<section id="attempt-1-sorting-by-height" class="level2">
<h2>Attempt 1: sorting by height</h2>
<p>One obvious approach is to simply sort the children at each node by
decreasing height, before traversing the tree to assign prime
factors. This handles the above example correctly, since the long
chain would be sorted to the front and assigned the factor 2.
However, this does not work in general! It can still fail to assign
the smallest primes to the longest chains. As a simple example,
consider this tree, in which the children of every node are already
sorted by decreasing height from left to right:</p>
<p><span class="sidenote-wrapper"><label for="sn-5" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="marginnote">Tree for which sorting by height first does not work<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/6bb8ef474a78c853.svg" />
</figure>
<p>The straightforward traversal algorithm indeed assigns powers of 2 to
the left spine of the tree, but it then assigns 3, 5, 7, and so on to
all the tiny spurs hanging off it. So by the time we get to other long
chain hanging off the root, it is assigned powers of <span class="math inline">\(43\)</span>, which are
too big. In fact, we want to assign powers of 2 to the left spine,
powers of 3 to the chain on the right, and then use the rest of the
primes for all the short spurs. But this sort of “non-local”
labelling means we can’t assign primes via a tree traversal.</p>
<p>To drive this point home, here’s another example tree. This one is
small enough that it probably doesn’t matter too much how we label it,
but it’s worth thinking about how to label the longest chains with the
smallest primes. I’ve drawn it in a “left-leaning” style to further
emphasize the different chains that are involved.</p>
<p><span class="sidenote-wrapper"><label for="sn-6" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="marginnote">Tree for which XXX<br />
<br />
</span></span></p>
<figure>
<img src="/diagrams/45540cc73cab6222.svg" />
</figure>
<p>In fact, we want to assign the factor 2 to the long chain on the left;
then the factor 3 to the second-longest chain, in the fourth column;
then 5 to the length-6 chain in the second column; 7 to the length-3
chain all the way on the right; and finally 11 to the smallest chain, in column 3.</p>
<p>In general, then, we want a way to <em>decompose</em> an arbitrary tree into
chains, where we repeatedly identify the longest chain, remove it from
consideration, and then identify the longest chain from the remaining
nodes, and so on. Once we have decomposed a tree into chains, it will
be a relatively simple matter to sort the chains by length and assign
consecutive prime factors.</p>
<p>This decomposition occasionally comes in handy (for example, see
<a href="https://open.kattis.com/problems/floatingformation">Floating
Formation</a>), and
belongs to a larger family of important tree decomposition techniques
such as <a href="https://cp-algorithms.com/graph/hld.html">heavy-light
decomposition</a>. Next time,
I’ll demonstrate how to implement such tree decompositions in Haskell!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: tree path decomposition, part I" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Thu, 11 Jul 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/07/11/cpih-factor-full-tree.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Products with unordered n-tuples</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/25/unordered-n-tuple-product.html</link>
    <description><![CDATA[
<h1>Products with unordered n-tuples</h1>

<div class="info">
  Posted on June 25, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;type-level programming&#39;." href="/tag/type-level%20programming.html" rel="tag">type-level programming</a>, <a title="All pages tagged &#39;Haskell&#39;." href="/tag/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged &#39;product&#39;." href="/tag/product.html" rel="tag">product</a>, <a title="All pages tagged &#39;unordered&#39;." href="/tag/unordered.html" rel="tag">unordered</a>, <a title="All pages tagged &#39;tuples&#39;." href="/tag/tuples.html" rel="tag">tuples</a>
  
</div>

<section>
<p>Recently, Dani Rybe wrote <a href="https://danryba253.github.io/danirybeblog/posts/unordered-n-tuples/">this really cool blog
post</a>
(in turn based on <a href="https://gelisam.blogspot.com/2013/07/the-commutative-monad.html">this old post by Samuel
Gélineau</a>)
about encoding truly <em>unordered</em> n-tuples in Haskell. This is
something I thought about a long time ago in my work on
combinatorial species, but I never came up with a way to represent
them. Samuel and Dani’s solution is wonderful and clever and totally
impractical, and I love it.</p>
<p>I won’t go into more detail than that; I’ll let you go read it if
you’re interested. This blog post exists solely to respond to Dani’s
statement towards the end of her post:</p>
<blockquote>
<p>I’m not sure how to, for example, write a function that multiplies
the inputs.</p>
</blockquote>
<p>Challenge accepted!</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Int</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> <span class="dv">2</span> <span class="op">:</span> sieve primes [<span class="dv">3</span> <span class="op">..</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  sieve (p <span class="op">:</span> ps) xs <span class="ot">=</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (h, t) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">&lt;</span> p <span class="op">*</span> p) xs</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> h <span class="op">++</span> sieve ps (<span class="fu">filter</span> ((<span class="op">/=</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) t)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>mul <span class="ot">=</span> unfuck mulU</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulU ::</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  mulU <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">&lt;</span> <span class="dv">0</span>) \(<span class="dt">US</span> neg nonNeg) <span class="ot">-&gt;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    mulNonNeg nonNeg <span class="op">*</span> mulPos primes (<span class="fu">abs</span> <span class="op">&lt;$&gt;</span> neg) <span class="op">*</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">^</span> ulen neg</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulNonNeg ::</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  mulNonNeg <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">==</span> <span class="dv">0</span>) \(<span class="dt">US</span> zero pos) <span class="ot">-&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> ulen zero <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> mulPos primes pos</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulPos ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  mulPos ps <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> (<span class="op">==</span> <span class="dv">1</span>) \(<span class="dt">US</span> _ pos) <span class="ot">-&gt;</span> mulGTOne ps pos</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="ot">  mulGTOne ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">U</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  mulGTOne (p <span class="op">:</span> ps) <span class="ot">=</span> ufold <span class="dv">1</span> <span class="fu">id</span> ((<span class="op">==</span> <span class="dv">0</span>) <span class="op">.</span> (<span class="ot">`mod`</span> p)) \(<span class="dt">US</span> divP nondivP) <span class="ot">-&gt;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    mulPos (p <span class="op">:</span> ps) ((<span class="ot">`div`</span> p) <span class="op">&lt;$&gt;</span> divP) <span class="op">*</span> (p <span class="op">^</span> ulen divP) <span class="op">*</span> mulGTOne ps nondivP</span></code></pre></div>
<p>Since every integer has a unique prime factorization, at each step we
split the remaining numbers into those divisible by <span class="math inline">\(p\)</span> and those not
divisible by <span class="math inline">\(p\)</span>. For the ones that are, we divide out <span class="math inline">\(p\)</span> from all
of them, multiply by the appropriate power of <span class="math inline">\(p\)</span>, and recurse on
what’s left; for those that are not, we move on to trying the next
prime.</p>
<p>Dani also speculates about <code>ubind :: U n (U m a) -&gt; U (n :*: m) a</code>. I
believe in my heart this should be possible to implement, but after
playing with it a bit, I concluded it would require an astounding feat
of type-fu.</p>
<p>PS I’m working on getting comments set up here on my new
blog… hopefully coming soon!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Products with unordered n-tuples" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 25 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/25/unordered-n-tuple-product.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: sieving with mutable arrays</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/21/cpih-product-divisors.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: sieving with mutable arrays</h1>

<div class="info">
  Posted on June 21, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>, <a title="All pages tagged &#39;sieve&#39;." href="/tag/sieve.html" rel="tag">sieve</a>, <a title="All pages tagged &#39;mutable array&#39;." href="/tag/mutable%20array.html" rel="tag">mutable array</a>
  
</div>

<section>
<p>In <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">a previous
post</a>
I challenged you to solve <a href="https://open.kattis.com/problems/productdivisors">Product
Divisors</a>. In this
problem, we are given a sequence of positive integers <span class="math inline">\(a_1, \dots, a_n\)</span>, and we are asked to compute the total number of divisors of
their product. For example, if we are given the numbers <span class="math inline">\(4, 2, 3\)</span>,
then the answer should be <span class="math inline">\(8\)</span>, since <span class="math inline">\(4 \times 2 \times 3 = 24\)</span> has
the <span class="math inline">\(8\)</span> distinct divisors <span class="math inline">\(1, 2, 3, 4, 6, 8, 12, 24\)</span>.</p>
<section id="counting-divisors" class="level2">
<h2>Counting divisors</h2>
<p>In general, if <span class="math inline">\(a\)</span> has the prime factorization <span class="math inline">\(a = p_1^{\alpha_1} p_2^{\alpha_2} \cdots p_k^{\alpha_k}\)</span> (where the <span class="math inline">\(p_i\)</span> are all distinct primes), then
the number of divisors of <span class="math inline">\(a\)</span> is</p>
<p><span class="math display">\[(\alpha_1 + 1)(\alpha_2 + 1) \cdots (\alpha_k + 1),\]</span></p>
<p>since we can independently choose how many powers of each prime to
include. There are <span class="math inline">\(\alpha_i + 1\)</span> choices for <span class="math inline">\(p_i\)</span> since we can
choose anything from <span class="math inline">\(p_i^0\)</span> up to <span class="math inline">\(p_i^{\alpha_i}\)</span>, inclusive.</p>
<p>So at a fundamental level, the solution is clear: factor each <span class="math inline">\(a_i\)</span>,
count up the number of copies of each prime in their product, then do
something like <code>map (+1) &gt;&gt;&gt; product</code>. We are also told the answer
should be given mod <span class="math inline">\(10^9 + 7\)</span>, so we can use a<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">Using <code>Int</code>
instead of <code>Integer</code> here is OK as long as we are sure to be running
on a 64-bit system; multiplying two <code>Int</code> values up to <span class="math inline">\(10^9 + 7\)</span>
yields a result that still fits within a 64-bit signed <code>Int</code>.
Otherwise (<em>e.g.</em> <a href="https://byorgey.github.io/blog/posts/2021/09/21/competitive-programming-in-haskell-codeforces-educational-round-114.html">on Codeforces</a>) we would have to use <code>Integer</code>.<br />
<br />
</span></span> <a href="https://byorgey.github.io/blog/posts/2020/02/15/competitive-programming-in-haskell-modular-arithmetic-part-1.html"><code>newtype</code> with a
custom <code>Num</code> instance</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="dv">10</span><span class="op">^</span><span class="dv">9</span> <span class="op">+</span> <span class="dv">7</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> {<span class="ot"> unM ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">M</span> <span class="kw">where</span> <span class="fu">show</span> <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> unM</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">M</span> <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">M</span> <span class="op">.</span> (<span class="ot">`mod`</span> p) <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">+</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">+</span> y) <span class="ot">`mod`</span> p)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">-</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">-</span> y) <span class="ot">`mod`</span> p)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">M</span> x <span class="op">*</span> <span class="dt">M</span> y <span class="ot">=</span> <span class="dt">M</span> ((x <span class="op">*</span> y) <span class="ot">`mod`</span> p)</span></code></pre></div>
</section>
<section id="a-naïve-solution-tle" class="level2">
<h2>A naïve solution (TLE)</h2>
<p>Of course, I would not be writing about this problem if it were that
easy! If we try implementing the above solution idea in a
straightforward way—for example, if we <a href="https://byorgey.wordpress.com/2020/02/07/competitive-programming-in-haskell-primes-and-factoring/">take the simple factoring code from this blog
post</a>
and then do something like <code>map factor &gt;&gt;&gt; M.unionsWith (+) &gt;&gt;&gt; M.elems &gt;&gt;&gt; map (+1) &gt;&gt;&gt; product</code>, we get the dreaded Time Limit Exceeded.</p>
<p>Why doesn’t this work? I haven’t mentioned how many integers might be
in the input: in fact, we might be given as many as one million (<span class="math inline">\(10^6\)</span>)! We need
to be able to factor each number very quickly if we’re going to finish
within the one second time limit. Factoring each number from scratch
by trial division is simply too slow.</p>
</section>
<section id="factoring-via-sieve" class="level2">
<h2>Factoring via sieve</h2>
<p>While <a href="https://cp-algorithms.com/algebra/factorization.html">more sophisticated methods</a> are needed to factor a <em>single</em>
number more quickly than trial division, there is a standard technique
we can use to speed things up when we need to factor <em>many</em> numbers.
We can use a <em>sieve</em> to precompute a lookup table, which we can then
use to factor numbers very quickly.</p>
<p>In particular, we will compute a table <span class="math inline">\(\mathit{smallest}\)</span> such that
<span class="math inline">\(\mathit{smallest}[i]\)</span> will store the <em>smallest prime factor</em> of <span class="math inline">\(i\)</span>.
Given this table, to factor a positive integer <span class="math inline">\(i\)</span>, we simply look up
<span class="math inline">\(\mathit{smallest}[i] = p\)</span>, add it to the prime factorization, then
recurse on <span class="math inline">\(i/p\)</span>; the base case is when <span class="math inline">\(i = 1\)</span>.</p>
<p>How do we compute <span class="math inline">\(\mathit{smallest}\)</span>? The basic idea is to create an
array of size <span class="math inline">\(n\)</span>, initializing it with <span class="math inline">\(\mathit{smallest}[k] = k\)</span>. For each <span class="math inline">\(k\)</span> from <span class="math inline">\(2\)</span> up to <span class="math inline">\(n\)</span>,<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">We could optimize this even
further via the <a href="https://codeforces.com/blog/entry/54090">approach in this blog
post</a>, which takes <span class="math inline">\(O(n)\)</span>
rather than <span class="math inline">\(O(n \lg n)\)</span> time, but it would complicate our Haskell
quite a bit and it’s not needed for solving this problem.<br />
<br />
</span></span> if
<span class="math inline">\(\mathit{smallest}[k]\)</span> is still equal to <span class="math inline">\(k\)</span>, then <span class="math inline">\(k\)</span> must be prime;
iterate through multiples of <span class="math inline">\(k\)</span> (starting with <span class="math inline">\(k^2\)</span>, since any
smaller multiple of <span class="math inline">\(k\)</span> is already divisible by a smaller prime) and
set each <span class="math inline">\(\mathit{smallest}[ki]\)</span> to the minimum of <span class="math inline">\(k\)</span> and whatever
value it had before.</p>
</section>
<section id="sieving-in-haskell" class="level2">
<h2>Sieving in Haskell</h2>
<p>This is one of those cases where for efficiency’s sake, we actually
want to use an honest-to-goodness mutable array. Immutable arrays are
not a good fit for sieving, and using something like a <code>Map</code> would
introduce a lot of overhead that we would rather avoid. However, we
only need the table to be mutable while we are computing it; after
that, it should just be an immutable lookup table. This is a great fit
for an <code>STUArray</code>:<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote">Note that as of this writing, the version of the
<code>array</code> library installed in the Kattis environment does not have
<code>modifyArray'</code>, so we actually have to do <code>readArray</code> followed by
<code>writeArray</code>.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>maxN <span class="ot">=</span> <span class="dv">1000000</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">smallest ::</span> <span class="dt">UArray</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>smallest <span class="ot">=</span> runSTUArray <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newListArray (<span class="dv">2</span>,maxN) [<span class="dv">2</span> <span class="op">..</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  forM_ [<span class="dv">2</span> <span class="op">..</span> maxN] <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    k&#39; <span class="ot">&lt;-</span> readArray a k</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    when (k <span class="op">==</span> k&#39;) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      forM_ [k<span class="op">*</span>k, k<span class="op">*</span>(k<span class="op">+</span><span class="dv">1</span>) <span class="op">..</span> maxN] <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        modifyArray&#39; a n (<span class="fu">min</span> k)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a</span></code></pre></div>
<p>Haskell, the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">world’s finest imperative programming language</a>!</p>
</section>
<section id="combining-factorizations" class="level2">
<h2>Combining factorizations</h2>
<p>We can now write a new <code>factor</code> function that works by repeatedly
looking up the smallest prime factor:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span> <span class="ot">-&gt;</span> M.empty</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">-&gt;</span> M.insertWith (<span class="op">+</span>) p <span class="dv">1</span> (factor (n <span class="ot">`div`</span> p))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    p <span class="ot">=</span> smallest<span class="op">!</span>n</span></code></pre></div>
<p>And now we can just do <code>map factor &gt;&gt;&gt; M.unionsWith (+) &gt;&gt;&gt; M.elems &gt;&gt;&gt; map (+1) &gt;&gt;&gt; product</code>
as before, but since our <code>factor</code> is so much faster this time, it
should…</p>
<p>What’s that? Still TLE? Sigh.</p>
</section>
<section id="counting-primes-via-a-second-mutable-array" class="level2">
<h2>Counting primes via a (second) mutable array</h2>
<p>Unfortunately, creating a bunch of <code>Map</code> values and then doing
<code>unionsWith</code> one million times still introduces way too much overhead.
For many problems working with <code>Map</code> (which is impressively fast) is
good enough, but not in this case. Instead of returning a <code>Map</code> from
each call to <code>factor</code> and then later combining them, we can write a version of
<code>factor</code> that directly increments counters for each prime in a
mutable array:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">STUArray</span> s <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>factor counts n <span class="ot">=</span> go n</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    go <span class="dv">1</span> <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    go n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> p <span class="ot">=</span> smallest<span class="op">!</span>n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      modifyArray&#39; counts p (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      go (n <span class="ot">`div`</span> p)</span></code></pre></div>
<p>Then we have the following top-level solution, which is finally fast
enough:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> C.interact <span class="op">$</span> runScanner (numberOf int) <span class="op">&gt;&gt;&gt;</span> solve <span class="op">&gt;&gt;&gt;</span> showB</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">M</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>solve <span class="ot">=</span> counts <span class="op">&gt;&gt;&gt;</span> elems <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> ((<span class="op">+</span><span class="dv">1</span>) <span class="op">&gt;&gt;&gt;</span> <span class="dt">M</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">product</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">counts ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">UArray</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>counts ns <span class="ot">=</span> runSTUArray <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  cs <span class="ot">&lt;-</span> newArray (<span class="dv">2</span>,maxN) <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  forM_ ns (factor cs)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> cs</span></code></pre></div>
<p>This solution runs in just over 0.4s for me. Considering that this is
only about 4x slower than the fastest solution (0.09s, in C++), I’m
pretty happy with it! We did have to sacrifice a bit of elegance for
speed, especially with the <code>factor</code> and <code>counts</code> functions instead of
<code>M.unionsWith</code>, but in the end it’s not too bad.</p>
<p>I thought we might be able to make this even faster by using a strict
fold over the <code>counts</code> array instead of converting to a list with
<code>elems</code> and then doing a <code>map</code> and a <code>product</code>, but (1) there is no
generic fold operation on <code>UArray</code>, and (2) I trust that GHC is
already doing a pretty good job optimizing this via list fusion.</p>
</section>
<section id="next-time" class="level2">
<h2>Next time</h2>
<p>Next time I’ll write about my solution to the <a href="https://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html">other challenge
problem</a>,
<a href="https://open.kattis.com/problems/factorfulltree">Factor-Full Tree</a>.
Until then, give it a try!</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: sieving with mutable arrays" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Fri, 21 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/21/cpih-product-divisors.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Swarm swarm III (virtual hackathon)</title>
    <link>http://byorgey.github.io/blog/posts/2024/06/12/swarm-swarm-3.html</link>
    <description><![CDATA[
<h1>Swarm swarm III (virtual hackathon)</h1>

<div class="info">
  Posted on June 12, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;hackathon&#39;." href="/tag/hackathon.html" rel="tag">hackathon</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>This Saturday, June 15, we will have the third Swarm swarm, <em>i.e.</em>
collaborative virtual hackathon. Details can be found <a href="https://github.com/swarm-game/swarm/wiki/Swarm-swarm">here on the
Swarm wiki</a>.</p>
<ul>
<li>Time: <a href="https://www.timeanddate.com/worldclock/fixedtime.html?msg=Swarm+swarm+III&amp;iso=20240615T16&amp;p1=1440&amp;ah=6">11am-5pm CDT / 4pm-10pm UTC / 9:30pm-3:30am
IST</a>
(feel free to drop in and out any time)</li>
<li>Place: <a href="https://app.gather.town/app/SpqG1ic5pNKM7YqS/The%20Swarm%20Hive">The Swarm Hive on
gather.town</a></li>
<li>Who: you! Anyone interested in hacking on Swarm is welcome, from
experienced to first-time contributors. If you’ve been thinking of
getting involved but haven’t yet, this could be a perfect
opportunity.</li>
</ul>
<p>As a reminder, <a href="https://swarm-game.github.io/">Swarm</a> is a 2D,
open-world programming and resource gathering game, implemented in
Haskell, with a strongly-typed, functional programming language and a
unique upgrade system. Unlocking language features is tied to
collecting resources, making it an interesting challenge to bootstrap
your way into the use of the full language.</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Swarm swarm III (virtual hackathon)" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Wed, 12 Jun 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/06/12/swarm-swarm-3.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: Two Hard Problems</title>
    <link>http://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: Two Hard Problems</h1>

<div class="info">
  Posted on May 28, 2024
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;number theory&#39;." href="/tag/number%20theory.html" rel="tag">number theory</a>
  
</div>

<section>
<p>I haven’t written here in a while—partly due to being busy, but also
partly due to getting sick of Wordpress and deciding it was finally
time to rebuild my blog from scratch using
<a href="https://jaspervdj.be/hakyll/">Hakyll</a>. I still haven’t quite worked
out what I’m doing about comments (I looked into
<a href="https://isso-comments.de/">Isso</a> but haven’t gotten it to work
yet—if you have used it successfully, let me know!).</p>
<p>For today I have two hard competitive programming challenge problems
for you. Both involve some number theory, and both are fairly
challenging, but that’s about all they have in common!</p>
<ul>
<li><a href="https://open.kattis.com/problems/productdivisors">Product Divisors</a></li>
<li><a href="https://open.kattis.com/problems/factorfulltree">Factor-Full Tree</a></li>
</ul>
<p>Since there are no comments (for now), feel free to email me with your
thoughts. I’ll post my solutions (with commentary) in a later post or
two!</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: Two Hard Problems" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>Tue, 28 May 2024 00:00:00 UT</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2024/05/28/competitive-programming-in-haskell-two-problems.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Swarm 0.4 release</title>
    <link>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</link>
    <description><![CDATA[
<h1>Swarm 0.4 release</h1>

<div class="info">
  Posted on August 22, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;resource&#39;." href="/tag/resource.html" rel="tag">resource</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>
The <a href="https://github.com/swarm-game/swarm/">Swarm</a> development team is very proud to announce the latest release of the game. This should still be considered a development/preview release—you still can’t <a href="https://github.com/swarm-game/swarm/issues/50">save your games</a>—but it’s made some remarkable progress and there are lots of fun things to try.
</p>
<h2 id="what-is-it">
What is it?
</h2>
<p>
As a reminder, Swarm is a 2D, open-world programming and resource gathering game with a strongly-typed, functional programming language and a unique upgrade system. Unlocking language features is tied to collecting resources, making it an interesting challenge to bootstrap your way into the use of the full language. It has also become a flexible and powerful platform for constructing programming challenges.
</p>
<p>
A few of the most significant new features are highlighted below; for full details, see the <a href="https://github.com/swarm-game/swarm/releases/tag/0.4.0.0">release notes</a>. If you just want to try it out, see the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>.
</p>
<h2 id="expanded-design-possibilities">
Expanded design possibilities
</h2>
<p>
The default play mode is the open-world, resource-gathering scenario—but Swarm also supports “challenge scenarios”, where you have to complete one or more specific objectives with given resources on a custom map. There are currently 58 scenarios and counting—some are silly proofs of concept, but many are quite fun and challenging! I especially recommend checking out the <code>Ranching</code> and <code>Sokoban</code> scenarios, as well as <code>A Frivolous Excursion</code> (pictured below). And creating new scenarios is a great way you can contribute to Swarm even if you don’t know Haskell, or aren’t comfortable hacking on the codebase.
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/excursion.png" />
</p>
</div>
<p>
Recently, a large amount of work has gone into expanding the possibilities for scenario design:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1332">Structure templates</a> allow you to design map tiles and then reuse them multiple times within a scenario.
</li>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1356">Waypoints and portals</a> provide a mechanism for automatically navigating and teleporting around the world.
</li>
<li>
Scenarios can have multiple <a href="https://github.com/swarm-game/swarm/pull/1353">subworlds</a> besides the main “overworld”, connected by portals. For example you could go “into a building” and have a separate map for the building interior.
</li>
<li>
There are a slew of new robot commands, many to do with different sensing modalities: <code>stride</code>, <code>detect</code>, <code>sniff</code>, <code>chirp,</code> <code>resonate</code>, <code>watch</code>, <code>surveil</code>, <code>scout</code>, <code>instant</code>, <code>push</code>, <code>density</code>, <code>use</code>, <code>halt</code>, and <code>backup</code>.
</li>
<li>
A <a href="https://github.com/swarm-game/swarm/pull/1376">new domain-specific language</a> for describing procedurally generated worlds. The default procedurally generated world used to be hardcoded, but now it is described externally via the new DSL, and you can design your own procedurally generated worlds without editing the Swarm source code.
</li>
<li>
The <a href="https://github.com/swarm-game/swarm/pull/1214">key input handler</a> feature allows you to program robots to respond to keyboard input, so you can <em>e.g.</em> drive them around manually, or interactively trigger more complex behaviors. This makes it possible to design “arcade-style” challenges, where the player needs to guide a robot and react to obstacles in real time—but they get to program the robot to respond to their commands first!
</li>
<li>
A new prototype <a href="https://github.com/swarm-game/swarm/pull/873">integrated world editor</a> lets you design worlds interactively.
</li>
</ul>
<h2 id="ui-improvements">
UI improvements
</h2>
<p>
In the past, entity and goal descriptions were simply plain text; recently, we switched to actually parsing Markdown. Partly, this is just to make things look nice, since we can highlight code snippets, entity names, etc.:
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/crafting.png" />
</p>
</div>
<p>
But it also means that we can now validate all code examples and entity names, and even test that the tutorial is pedagogically sound: any command used in a tutorial solution must be mentioned in a previous tutorial, or else our CI fails!
</p>
<p>
There are also a number of other small UI enhancements, such as improved type error messages, inventory search, and a collapsible REPL panel, among others.
</p>
<h2 id="scoring-metrics">
Scoring metrics
</h2>
<p>
We now keep track of a number of metrics related to challenge scenario solutions, such as total time, total game ticks, and code size. These metrics are tracked and saved across runs, so you can compete with yourself, and with others. For now, see these wiki pages:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Speedrunning">Swarm speedrunning</a>
</li>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Code-golf">Swarm code golf</a>
</li>
</ul>
<p>
In the future, perhaps there will eventually be some kind of <a href="https://github.com/swarm-game/swarm/issues/1259">social website</a> with leaderboards and user-uploaded scenarios.
</p>
<h2 id="debugging">
Debugging
</h2>
<p>
Last but not least, we now have an <a href="https://github.com/swarm-game/swarm/pull/1081">integrated single-stepping and debugging mode</a> (enabled by the <code>tweezers</code> device).
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/debugger.png" />
</p>
</div>
<h2 id="give-it-a-try">
Give it a try!
</h2>
<p>
To install, check out the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>: you can download a <a href="https://github.com/swarm-game/swarm/releases">binary release</a> (for now, Linux only, but MacOS binaries should be on the horizon), or <a href="https://hackage.haskell.org/package/swarm">install from Hackage</a>. Give it a try and send us your feedback, either <a href="https://github.com/swarm-game/swarm/issues/new/choose">via a github issue</a> or <a href="https://web.libera.chat/?channels=#swarm">IRC</a>!
</p>
<h2 id="future-plans-getting-involved">
Future plans &amp; getting involved
</h2>
<p>
We’re still hard at work on the game. Fun upcoming things include:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/issues/50">Saving and loading games</a>
</li>
<li>
New world features like aliens and <a href="https://github.com/swarm-game/swarm/issues/112">cities</a>
</li>
<li>
New language features like <a href="https://github.com/swarm-game/swarm/issues/154">recursive types</a>, <a href="https://github.com/swarm-game/swarm/issues/98">arrays</a>, <a href="https://github.com/swarm-game/swarm/issues/94">inter-robot communication</a>, and <a href="https://github.com/swarm-game/swarm/issues/495">a proper <code>import</code> construct</a>
</li>
</ul>
<p>
Of course, there are also <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">tons of small things that need fixing and polishing</a> too! If you’re interested in getting involved, check out our <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">contribution guide</a>, come <a href="https://web.libera.chat/?channels=#swarm">join us on IRC</a> (<code>#swarm</code> on Libera.Chat), or take a look at the list of <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">issues marked “low-hanging fruit”</a>.
</p>
<p>
Brought to you by the Swarm development team:
</p>
<ul>
<li>
Brent Yorgey
</li>
<li>
Karl Ostmo
</li>
<li>
Ondřej Šebek
</li>
</ul>
<p>
With contributions from:
</p>
<ul>
<li>
Alexander Block
</li>
<li>
Brian Wignall
</li>
<li>
Chris Casinghino
</li>
<li>
Daniel Díaz Carrete
</li>
<li>
Huw Campbell
</li>
<li>
Ishan Bhanuka
</li>
<li>
Jacob
</li>
<li>
Jens Petersen
</li>
<li>
José Rafael Vieira
</li>
<li>
Joshua Price
</li>
<li>
lsmor
</li>
<li>
Noah Yorgey
</li>
<li>
Norbert Dzikowski
</li>
<li>
Paul Brauner
</li>
<li>
Ryan Yates
</li>
<li>
Sam Tay
</li>
<li>
Steven Garcia
</li>
<li>
Tamas Zsar
</li>
<li>
Tristan de Cacqueray
</li>
<li>
Valentin Golev
</li>
</ul>
<p>
…not to mention many others who gave valuable suggestions and feedback. Want to see your name listed here in the next release? <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">See how you can contribute!</a>
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Swarm 0.4 release" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-08-22T17:37:34Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Compiling to Intrinsically Typed Combinators</title>
    <link>http://byorgey.github.io/blog/posts/2023/07/13/compiling-to-intrinsically-typed-combinators.html</link>
    <description><![CDATA[
<h1>Compiling to Intrinsically Typed Combinators</h1>

<div class="info">
  Posted on July 13, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;bracket&#39;." href="/tag/bracket.html" rel="tag">bracket</a>, <a title="All pages tagged &#39;combinators&#39;." href="/tag/combinators.html" rel="tag">combinators</a>, <a title="All pages tagged &#39;compile&#39;." href="/tag/compile.html" rel="tag">compile</a>, <a title="All pages tagged &#39;DSL&#39;." href="/tag/DSL.html" rel="tag">DSL</a>, <a title="All pages tagged &#39;indexed&#39;." href="/tag/indexed.html" rel="tag">indexed</a>, <a title="All pages tagged &#39;typed&#39;." href="/tag/typed.html" rel="tag">typed</a>
  
</div>

<section>
<p>
<strong>tl;dr</strong>: <em>How to compile a functional language via combinators (and evaluate via the Haskell runtime) while keeping the entire process type-indexed, with a bibliography and lots of references for further reading</em>
</p>
<p>
There is a long history, starting with Schönfinkel and Curry, of abstracting away variable names from lambda calculus terms by converting to combinators, aka <em>bracket abstraction</em>. This was popular in the 80’s as a compilation technique for functional languages <span class="citation">(Turner, 1979; Augustsson, 1986; Jones, 1987; Diller, 1988)</span>, then apparently abandoned. More recently, however, it has been making a bit of a comeback. For example, see <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=f801c21b2630df3094c9c800c18ebc1e969865da">Naylor</a> <span class="citation">(2008)</span>, <a href="https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html">Gratzer</a> <span class="citation">(2015)</span>, <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">Lynn</a> <span class="citation">(2017)</span>, and <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">Mahler</a> <span class="citation">(2021)</span>. Bracket abstraction is intimately related to compiling to cartesian closed categories <span class="citation">(Elliott, 2017; Mahler, 2021)</span>, and also enables cool tricks like doing evaluation via the Haskell runtime system <span class="citation">(Naylor, 2008; Seo, 2016; Mahler, 2022)</span>.
</p>
<p>
However, it always bothered me that the conversion to combinators was invariably described in an untyped way. Partly to gain some assurance that we are doing things correctly, but mostly for fun, I wondered if it would be possible to do the whole pipeline in an explicitly type-indexed way. I eventually found <a href="http://okmij.org/ftp/tagless-final/ski.pdf">a nice paper by Oleg Kiselyov</a> <span class="citation">(2018)</span> which explains exactly how to do it (it even came with <a href="http://okmij.org/ftp/tagless-final/skconv.ml">OCaml code</a> that I was easily able to port to Haskell!).
</p>
<p>
In this blog post, I:
</p>
<ul>
<li>
Show an example of typechecking and elaboration for a functional language into explicitly type-indexed terms, such that it is impossible to write down ill-typed terms
</li>
<li>
Demonstrate a Haskell port of Oleg Kiselyov’s typed bracket abstraction algorithm
</li>
<li>
Demonstrate type-indexed evaluation of terms via the Haskell runtime
</li>
<li>
Put together an extensive bibliography with references for further reading
</li>
</ul>
<p>
This blog post is rendered automatically from a literate Haskell file; you can <a href="https://github.com/byorgey/typed-combinators">find the complete working source code and blog post on GitHub</a>. I’m always happy to receive comments, fixes, or suggestions for improvement.
</p>
<h2 id="but-first-a-message-from-our-sponsors">
But First, A Message From Our Sponsors
</h2>
<p>
So many yummy language extensions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE ConstraintKinds #-}</span>
<span style="color: green">{-# LANGUAGE DataKinds #-}</span>
<span style="color: green">{-# LANGUAGE ExplicitForAll #-}</span>
<span style="color: green">{-# LANGUAGE FlexibleContexts #-}</span>
<span style="color: green">{-# LANGUAGE GADTs #-}</span>
<span style="color: green">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span style="color: green">{-# LANGUAGE InstanceSigs #-}</span>
<span style="color: green">{-# LANGUAGE KindSignatures #-}</span>
<span style="color: green">{-# LANGUAGE LambdaCase #-}</span>
<span style="color: green">{-# LANGUAGE OverloadedStrings #-}</span>
<span style="color: green">{-# LANGUAGE PatternSynonyms #-}</span>
<span style="color: green">{-# LANGUAGE RankNTypes #-}</span>
<span style="color: green">{-# LANGUAGE StandaloneDeriving #-}</span>
<span style="color: green">{-# LANGUAGE TypeApplications #-}</span>
<span style="color: green">{-# LANGUAGE TypeFamilies #-}</span>
<span style="color: green">{-# LANGUAGE TypeOperators #-}</span>
<span style="color: green">{-# LANGUAGE UnicodeSyntax #-}</span>
<span style="color: green">{-# LANGUAGE ViewPatterns #-}</span>

<span style="color: blue;font-weight: bold">module</span> <span>TypedCombinators</span> <span style="color: blue;font-weight: bold">where</span>

<span style="color: blue;font-weight: bold">import</span> <span>Control.Monad.Combinators.Expr</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Functor.Const</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>F</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Void</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Text</span> <span style="color: red">(</span> <span>Text</span> <span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Text</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>T</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Kind</span> <span style="color: red">(</span><span>Type</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Type.Equality</span> <span style="color: red">(</span> <span style="color: blue;font-weight: bold">type</span> <span style="color: red">(</span><span>:~:</span><span style="color: red">)</span><span style="color: red">(</span><span>Refl</span><span style="color: red">)</span><span style="color: red">,</span> <span>TestEquality</span><span style="color: red">(</span><span style="color: red">..</span><span style="color: red">)</span> <span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec.Char</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec.Char.Lexer</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>L</span>
<span style="color: blue;font-weight: bold">import</span> <span>Witch</span> <span style="color: red">(</span><span>into</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Prelude</span> <span>hiding</span> <span style="color: red">(</span><span>lookup</span><span style="color: red">)</span></code></pre>
<h2 id="raw-terms-and-types">
Raw terms and types
</h2>
<p>
Here’s an algebraic data type to represent raw terms of our DSL, something which might come directly out of a parser. The exact language we use here isn’t all that important; I’ve put in just enough features to make it nontrivial, but not much beyond that. We have integer literals, variables, lambdas, application, <code>let</code> and <code>if</code> expressions, addition, and comparison with <code>&gt;</code>. Of course, it would be easy to add more types, constants, and language features.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Term</span> <span style="color: blue;font-weight: bold">where</span>
  <span>Lit</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Var</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Lam</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>App</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Let</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>If</span>  <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Add</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Gt</span>  <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span></code></pre>
<p>
A few things to note:
</p>
<ul>
<li>
<p>
In order to keep things simple, notice that lambdas must be annotated with the type of the argument. There are other choices we could make, but this is the simplest for now. I’ll have more to say about other choices later.
</p>
</li>
<li>
<p>
I included <code>if</code> not only because it gives us something to do with Booleans, but also because it is <em>polymorphic</em>, which adds an interesting twist to our typechecking.
</p>
</li>
<li>
<p>
I included <code>&gt;</code>, not only because it gives us a way to produce Boolean values, but also because it uses <em>ad-hoc</em> polymorphism, that is, we can compare at any type which is an instance of <code>Ord</code>. This is an even more interesting twist.
</p>
</li>
</ul>
<p>
Here are our types: integers, booleans, and functions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Ty</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TyInt</span>  <span style="color: red">::</span> <span>Ty</span>
  <span>TyBool</span> <span style="color: red">::</span> <span>Ty</span>
  <span>TyFun</span>  <span style="color: red">::</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Ty</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span></code></pre>
<p>
Finally, here’s an example term that uses all the features of our language (I’ve included a simple parser in an appendix at the end of this post):
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>example</span> <span style="color: red">::</span> <span>Term</span>
<span>example</span> <span style="color: red">=</span> <span>readTerm</span> <span>$</span> <span>T.unlines</span>
  <span style="color: red">[</span> <span style="color: teal">"let twice = \\f:Int -&gt; Int. \\x:Int. f (f x) in"</span>
  <span style="color: red">,</span> <span style="color: teal">"let z = 1 in"</span>
  <span style="color: red">,</span> <span style="color: teal">"if 7 &gt; twice (\\x:Int. x + 3) z then z else z + 1"</span>
  <span style="color: red">]</span></code></pre>
<p>
Since 7 is not, in fact, strictly greater than 1 + 3 + 3, this should evaluate to 2.
</p>
<h2 id="type-indexed-constants">
Type-indexed constants
</h2>
<p>
That was the end of our raw, untyped representations—from now on, everything is going to be type-indexed! First of all, we’ll declare an enumeration of constants, with each constant indexed by its corresponding host language type. These will include both any special language built-ins (like <code>if</code>, <code>+</code>, and <code>&gt;</code>) as well as a set of <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinators</a> which we’ll be using as a compilation target—more on these later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Const</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CInt</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>Int</span>
  <span>CIf</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>CAdd</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>Int</span> <span style="color: red">-&gt;</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Int</span><span style="color: red">)</span>
  <span>CGt</span> <span style="color: red">::</span> <span>Ord</span> <span>α</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Bool</span><span style="color: red">)</span>
  <span>I</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>K</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>S</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
  <span>B</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span>     <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
  <span>C</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span>       <span>b</span>  <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>Const</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
The polymorphism of <code>if</code> (and the combinators <code>I</code>, <code>K</code>, <em>etc.</em>, for that matter) poses no real problems. If we really wanted the type of <code>CIf</code> to be indexed by the exact type of <code>if</code>, it would be something like
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>CIf</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
but this would require <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/impredicative_types.html">impredicative types</a> which can be something of a minefield. However, what we actually get is
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>CIf</span> <span style="color: red">::</span> <span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>Const</span> <span style="color: red">(</span><span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
which is unproblematic and works just as well for our purposes.
</p>
<p>
The type of <code>CGt</code> is more interesting: it includes an <code>Ord α</code> constraint. That means that at the time we construct a <code>CGt</code> value, we must have in scope an <code>Ord</code> instance for whatever type <code>α</code> is; conversely, when we pattern-match on <code>CGt</code>, we will bring that instance into scope. We will see how to deal with this later.
</p>
<p>
For convenience, we make a type class <code>HasConst</code> for type-indexed things that can contain embedded constants (we will end up with several instances of this class).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">class</span> <span>HasConst</span> <span>t</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span></code></pre>
<p>
Also for convenience, here’s a type class for type-indexed things that support some kind of application operation. (Note that we don’t necessarily want to require <code>t</code> to support a <code>pure :: a -&gt; t a</code> operation, or even be a <code>Functor</code>, so using <code>Applicative</code> would not be appropriate, even though <code>$$</code> has the same type as <code>&lt;*&gt;</code>.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>&#36;&#36;</span>
<span style="color: blue;font-weight: bold">class</span> <span>Applicable</span> <span>t</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span>t</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span></code></pre>
<p>
Note that, unlike the standard <code>$</code> operator, <code>$$</code> is <em>left</em>-associative, so, for example, <code>f $$ x $$ y</code> should be read just like <code>f x y</code>, that is, <code>f $$ x $$ y = (f $$ x) $$ y</code>.
</p>
<p>
Finally, we’ll spend a bunch of time applying constants to things, or applying things to constants, so here are a few convenience operators for combining <code>$$</code> and <code>embed</code>:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>.&#36;&#36;</span>
<span style="color: red">(</span><span>.&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>c</span> <span>.&#36;&#36;</span> <span>t</span> <span style="color: red">=</span> <span>embed</span> <span>c</span> <span>&#36;&#36;</span> <span>t</span>

<span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>&#36;&#36;.</span>
<span style="color: red">(</span><span>&#36;&#36;.</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>t</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>t</span> <span>&#36;&#36;.</span> <span>c</span> <span style="color: red">=</span> <span>t</span> <span>&#36;&#36;</span> <span>embed</span> <span>c</span>

<span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>.&#36;&#36;.</span>
<span style="color: red">(</span><span>.&#36;&#36;.</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>c1</span> <span>.&#36;&#36;.</span> <span>c2</span> <span style="color: red">=</span> <span>embed</span> <span>c1</span> <span>&#36;&#36;</span> <span>embed</span> <span>c2</span></code></pre>
<h2 id="type-indexed-types-and-terms">
Type-indexed types and terms
</h2>
<p>
Now let’s build up our type-indexed core language. First, we’ll need a data type for type-indexed de Bruijn indices. A value of type <code>Idx γ α</code> is a variable with type <code>α</code> in the context <code>γ</code> (represented as a type-level list of types). For example, <code>Idx [Int,Bool,Int] Int</code> would represent a variable of type <code>Int</code> (and hence must either be variable 0 or 2).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Idx</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>VZ</span> <span style="color: red">::</span> <span>Idx</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>
  <span>VS</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Idx</span> <span style="color: red">(</span><span>β</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
Now we can build our type-indexed terms. Just like variables, terms are indexed by a typing context and a type; <code>t : TTerm γ α</code> can be read as “<code>t</code> is a term with type <code>α</code>, possibly containing variables whose types are described by the context <code>γ</code>”. Our core language has only variables, constants, lambdas, and application. Note we’re not just making a type-indexed version of our original term language; for simplicity, we’re going to simultaneously typecheck and elaborate down to this much simpler core language. (Of course, it would also be entirely possible to introduce another intermediate data type for type-indexed terms, and separate the typechecking and elaboration phases.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>TTerm</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TVar</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span>
  <span>TConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span>
  <span>TLam</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>
  <span>TApp</span> <span style="color: red">::</span> <span>TTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>β</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">=</span> <span>TApp</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>TConst</span></code></pre>
<p>
Now for some type-indexed types!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>TTy</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TTyInt</span> <span style="color: red">::</span> <span>TTy</span> <span>Int</span>
  <span>TTyBool</span> <span style="color: red">::</span> <span>TTy</span> <span>Bool</span>
  <span style="color: red">(</span><span>:-&gt;:</span><span style="color: red">)</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>β</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>TTy</span> <span>ty</span><span style="color: red">)</span></code></pre>
<p>
<code>TTy</code> is a term-level representation of our DSL’s types, indexed by corresponding host language types. In other words, <code>TTy</code> is a <em>singleton</em>: for a given type <code>α</code> there is a single value of type <code>TTy α</code>. Put another way, pattern-matching on a value of type <code>TTy α</code> lets us learn what the type <code>α</code> is. (See <span class="citation">(Le, 2017)</span> for a <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">nice introduction to the idea of singleton types</a>.)
</p>
<p>
We will need to be able to test two value-level type representations for equality and have that reflected at the level of type indices; the <code>TestEquality</code> class from <code>Data.Type.Equality</code> is perfect for this. The <code>testEquality</code> function takes two type-indexed things and returns a type equality proof wrapped in <code>Maybe</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">instance</span> <span>TestEquality</span> <span>TTy</span> <span style="color: blue;font-weight: bold">where</span>
  <span>testEquality</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>β</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>α</span> <span>:~:</span> <span>β</span><span style="color: red">)</span>
  <span>testEquality</span> <span>TTyInt</span> <span>TTyInt</span> <span style="color: red">=</span> <span>Just</span> <span>Refl</span>
  <span>testEquality</span> <span>TTyBool</span> <span>TTyBool</span> <span style="color: red">=</span> <span>Just</span> <span>Refl</span>
  <span>testEquality</span> <span style="color: red">(</span><span>α₁</span> <span>:-&gt;:</span> <span>β₁</span><span style="color: red">)</span> <span style="color: red">(</span><span>α₂</span> <span>:-&gt;:</span> <span>β₂</span><span style="color: red">)</span> <span style="color: red">=</span>
    <span style="color: blue;font-weight: bold">case</span> <span style="color: red">(</span><span>testEquality</span> <span>α₁</span> <span>α₂</span><span style="color: red">,</span> <span>testEquality</span> <span>β₁</span> <span>β₂</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
      <span style="color: red">(</span><span>Just</span> <span>Refl</span><span style="color: red">,</span> <span>Just</span> <span>Refl</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Just</span> <span>Refl</span>
      <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
  <span>testEquality</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>Nothing</span></code></pre>
<p>
Recall that the <code>CGt</code> constant requires an <code>Ord</code> instance; the <code>checkOrd</code> function pattern-matches on a <code>TTy</code> and witnesses the fact that the corresponding host-language type has an <code>Ord</code> instance (if, in fact, it does).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>checkOrd</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>Ord</span> <span>α</span> <span style="color: red">=&gt;</span> <span>r</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>r</span>
<span>checkOrd</span> <span>TTyInt</span> <span>r</span> <span style="color: red">=</span> <span>Just</span> <span>r</span>
<span>checkOrd</span> <span>TTyBool</span> <span>r</span> <span style="color: red">=</span> <span>Just</span> <span>r</span>
<span>checkOrd</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>Nothing</span></code></pre>
<p>
As a quick aside, for simplicity’s sake, I am going to use <code>Maybe</code> throughout the rest of this post to indicate possible failure. In a real implementation, one would of course want to return more information about any error(s) that occur.
</p>
<h2 id="existential-wrappers">
Existential wrappers
</h2>
<p>
Sometimes we will need to wrap type-indexed things inside an existential wrapper to hide the type index. For example, when converting from a <code>Ty</code> to a <code>TTy</code>, or when running type inference, we can’t know in advance which type we’re going to get. So we create the <code>Some</code> data type which wraps up a type-indexed thing along with a corresponding <code>TTy</code>. Pattern-matching on the singleton <code>TTy</code> will allow us to recover the type information later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Some</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>Some</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>t</span>

<span>mapSome</span> <span style="color: red">::</span> <span style="color: red">(</span><span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>s</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>s</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>t</span>
<span>mapSome</span> <span>f</span> <span style="color: red">(</span><span>Some</span> <span>α</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>f</span> <span>t</span><span style="color: red">)</span></code></pre>
<p>
The first instantiation we’ll create is an existentially wrapped type, where the <code>TTy</code> itself is the only thing we care about, and the corresponding <code>t</code> will just be the constant unit type functor. It would be annoying to keep writing <code>F.Const ()</code> everywhere so we create some type and pattern synonyms for convenience.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>SomeTy</span> <span style="color: red">=</span> <span>Some</span> <span style="color: red">(</span><span>F.Const</span> <span>()</span><span style="color: red">)</span>

<span>pattern</span> <span>SomeTy</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>SomeTy</span>
<span>pattern</span> <span>SomeTy</span> <span>α</span> <span style="color: red">=</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>F.Const</span> <span>()</span><span style="color: red">)</span>
<span style="color: green">{-# COMPLETE SomeTy #-}</span></code></pre>
<p>
The <code>someType</code> function converts from a raw <code>Ty</code> to a type-indexed <code>TTy</code>, wrapped up in an existential wrapper.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>someType</span> <span style="color: red">::</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>SomeTy</span>
<span>someType</span> <span>TyInt</span> <span style="color: red">=</span> <span>SomeTy</span> <span>TTyInt</span>
<span>someType</span> <span>TyBool</span> <span style="color: red">=</span> <span>SomeTy</span> <span>TTyBool</span>
<span>someType</span> <span style="color: red">(</span><span>TyFun</span> <span>a</span> <span>b</span><span style="color: red">)</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span style="color: red">(</span><span>someType</span> <span>a</span><span style="color: red">,</span> <span>someType</span> <span>b</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
  <span style="color: red">(</span><span>SomeTy</span> <span>α</span><span style="color: red">,</span> <span>SomeTy</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>SomeTy</span> <span style="color: red">(</span><span>α</span> <span>:-&gt;:</span> <span>β</span><span style="color: red">)</span></code></pre>
<h2 id="type-inference-and-elaboration">
Type inference and elaboration
</h2>
<p>
Now that we have our type-indexed core language all set, it’s time to do type inference, that is, translate from untyped terms to type-indexed ones! First, let’s define type contexts, <em>i.e.</em> mappings from variables to their types. We store contexts simply as a (fancy, type-indexed) list of variable names paired with their types. This is inefficient—it takes linear time to do a lookup—but we don’t care, because this is an intermediate representation used only during typechecking. By the time we actually get around to running terms, variables won’t even exist any more.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Ctx</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>

  <span style="color: green">-- CNil represents an empty context.</span>
  <span>CNil</span> <span style="color: red">::</span> <span>Ctx</span> <span style="color: teal">'</span><span>[]</span>

  <span style="color: green">-- A cons stores a variable name and its type,</span>
  <span style="color: green">-- and then the rest of the context.</span>
  <span style="color: red">(</span><span>:::</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Text</span><span style="color: red">,</span> <span>TTy</span> <span>α</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span></code></pre>
<p>
Now we can define the <code>lookup</code> function, which takes a variable name and a context and tries to return a corresponding de Bruijn index into the context. When looking up a variable name in the context, we can’t know in advance what index we will get and what type it will have, so we wrap the returned <code>Idx</code> in <code>Some</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>lookup</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Some</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span><span style="color: red">)</span><span style="color: red">)</span>
<span>lookup</span> <span style="color: blue;font-weight: bold">_</span> <span>CNil</span> <span style="color: red">=</span> <span>Nothing</span>
<span>lookup</span> <span>x</span> <span style="color: red">(</span><span style="color: red">(</span><span>y</span><span style="color: red">,</span> <span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span>
  <span style="color: red">|</span> <span>x</span> <span>==</span> <span>y</span> <span style="color: red">=</span> <span>Just</span> <span style="color: red">(</span><span>Some</span> <span>α</span> <span>VZ</span><span style="color: red">)</span>
  <span style="color: red">|</span> <span>otherwise</span> <span style="color: red">=</span> <span>mapSome</span> <span>VS</span> <span>&lt;$&gt;</span> <span>lookup</span> <span>x</span> <span>ctx</span></code></pre>
<p>
Now we’re finally ready to define the <code>infer</code> function! It takes a type context and a raw term, and tries to compute a corresponding type-indexed term. Note that there’s no particular guarantee that the term we return corresponds to the input term—we will just have to be careful—but at least the Haskell type system guarantees that we can’t return a type-incorrect term, which is especially important when we have some nontrivial elaboration to do. Of course, just as with variable lookups, when inferring the type of a term we can’t know in advance what type it will have, so we will need to return an existential wrapper around a type-indexed term.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>infer</span> <span style="color: red">::</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Some</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span><span style="color: red">)</span>
<span>infer</span> <span>ctx</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span></code></pre>
<p>
To infer the type of a literal integer value, just return <code>TTyInt</code> with a literal integer constant.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Lit</span> <span>i</span> <span style="color: red">-&gt;</span> <span>return</span> <span>$</span> <span>Some</span> <span>TTyInt</span> <span style="color: red">(</span><span>embed</span> <span style="color: red">(</span><span>CInt</span> <span>i</span><span style="color: red">)</span><span style="color: red">)</span></code></pre>
<p>
To infer the type of a variable, look it up in the context and wrap the result in <code>TVar</code>. Notice how we are allowed to pattern-match on the <code>Some</code> returned from <code>lookup</code> (revealing the existentially quantified type inside) since we immediately wrap it back up in another <code>Some</code> when returning the <code>TVar</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Var</span> <span>x</span> <span style="color: red">-&gt;</span> <span>mapSome</span> <span>TVar</span> <span>&lt;$&gt;</span> <span>lookup</span> <span>x</span> <span>ctx</span></code></pre>
<p>
To infer the type of a lambda, we convert the argument type annotation to a type-indexed type, infer the type of the body under an extended context, and then return a lambda with an appropriate function type. (If lambdas weren’t required to have type annotations, then we would either have to move the lambda case to the <code>check</code> function, or else use unification variables and solve type equality constraints. The former would be straightforward, but I don’t know how to do the latter in a type-indexed way—sounds like a fun problem for later.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Lam</span> <span>x</span> <span>a</span> <span>t</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span style="color: blue;font-weight: bold">case</span> <span>someType</span> <span>a</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Some</span> <span>α</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
        <span>Some</span> <span>β</span> <span>t'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span style="color: red">(</span><span style="color: red">(</span><span>x</span><span style="color: red">,</span><span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span> <span>t</span>
        <span>return</span> <span>$</span> <span>Some</span> <span style="color: red">(</span><span>α</span> <span>:-&gt;:</span> <span>β</span><span style="color: red">)</span> <span style="color: red">(</span><span>TLam</span> <span>t'</span><span style="color: red">)</span></code></pre>
<p>
To infer the type of an application, we infer the type of the left-hand side, ensure it is a function type, and <code>check</code> that the right-hand side has the correct type. We will see the <code>check</code> function later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>App</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>τ</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span style="color: blue;font-weight: bold">case</span> <span>τ</span> <span style="color: blue;font-weight: bold">of</span>
      <span>α</span> <span>:-&gt;:</span> <span>β</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
        <span>t2'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>α</span> <span>t2</span>
        <span>return</span> <span>$</span> <span>Some</span> <span>β</span> <span style="color: red">(</span><span>TApp</span> <span>t1'</span> <span>t2'</span><span style="color: red">)</span>
      <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>Nothing</span></code></pre>
<p>
To infer the type of a <code>let</code>-expression, we infer the type of the definition, infer the type of the body under an extended context, and then desugar it into an application of a lambda. That is, <code>let x = t1 in t2</code> desugars to <code>(\x.t2) t1</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Let</span> <span>x</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>α</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span>Some</span> <span>β</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span style="color: red">(</span><span style="color: red">(</span><span>x</span><span style="color: red">,</span> <span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span> <span>t2</span>
    <span>return</span> <span>$</span> <span>Some</span> <span>β</span> <span style="color: red">(</span><span>TApp</span> <span style="color: red">(</span><span>TLam</span> <span>t2'</span><span style="color: red">)</span> <span>t1'</span><span style="color: red">)</span></code></pre>
<p>
Note again that we can’t accidentally get mixed up here—for example, if we incorrectly desugar to <code>(\x.t1) t2</code> we get a Haskell type error, like this:
</p>
<pre><code>    • Couldn't match type ‘γ’ with ‘α : γ’
      Expected: TTerm γ α1
        Actual: TTerm (α : γ) α1</code></pre>
<p>
To infer an <code>if</code>-expression, we can check that the test has type <code>Bool</code>, infer the types of the two branches, and ensure that they are the same. If so, we return the <code>CIf</code> constant applied to the three arguments. The reason this typechecks is that pattern-matching on the <code>Refl</code> from the <code>testEquality</code> call brings into scope the fact that the types of <code>t2</code> and <code>t3</code> are equal, so we can apply <code>CIf</code> which requires them to be so.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>If</span> <span>t1</span> <span>t2</span> <span>t3</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>t1'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyBool</span> <span>t1</span>
    <span>Some</span> <span>α</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t2</span>
    <span>Some</span> <span>β</span> <span>t3'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t3</span>
    <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
      <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span>return</span> <span>$</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>CIf</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span> <span>&#36;&#36;</span> <span>t3'</span><span style="color: red">)</span></code></pre>
<p>
Addition is simple; we just check that both arguments have type <code>Int</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Add</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>t1'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyInt</span> <span>t1</span>
    <span>t2'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyInt</span> <span>t2</span>
    <span>return</span> <span>$</span> <span>Some</span> <span>TTyInt</span> <span style="color: red">(</span><span>CAdd</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span><span style="color: red">)</span></code></pre>
<p>
“Greater than” is a bit interesting because we allow it to be used at both <code>Int</code> and <code>Bool</code>. So, just as with <code>if</code>, we must infer the types of the arguments and check that they match. But then we must also use the <code>checkOrd</code> function to ensure that the argument types are an instance of <code>Ord</code>. In particular, we wrap <code>CGt</code> (which requires an <code>Ord</code> constraint) in a call to <code>checkOrd α</code> (which provides one).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Gt</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>α</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span>Some</span> <span>β</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t2</span>
    <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
      <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span style="color: red">\</span><span>c</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>TTyBool</span> <span style="color: red">(</span><span>c</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span><span style="color: red">)</span><span style="color: red">)</span> <span>&lt;$&gt;</span> <span>checkOrd</span> <span>α</span> <span>CGt</span></code></pre>
<p>
Finally, here’s the <code>check</code> function: to check that an expression has an expected type, just infer its type and make sure it’s the one we expected. (With more interesting languages we might also have more cases here for terms which can be checked but not inferred.) Notice how this also allows us to return the type-indexed term without using an existential wrapper, since the expected type is an input.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>check</span> <span style="color: red">::</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span>
<span>check</span> <span>ctx</span> <span>α</span> <span>t</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">do</span>
  <span>Some</span> <span>β</span> <span>t'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t</span>
  <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
    <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
    <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span>Just</span> <span>t'</span></code></pre>
<p>
Putting this all together so far, we can check that the <code>example</code> term has type <code>Int</code> and see what it elaborates to (I’ve included a simple pretty-printer for <code>TTerm</code> in an appendix):
</p>
<pre><code>λ&gt; putStrLn . pretty . fromJust . check CNil TTyInt $ example
(λ. (λ. if (gt 7 (x1 (λ. plus x0 3) x0)) x0 (plus x0 1)) 1) (λ. λ. x1 (x1 x0))</code></pre>
<h2 id="an-aside-a-typed-interpreter">
An aside: a typed interpreter
</h2>
<p>
We can now easily write an interpreter. However, this is pretty inefficient (it has to carry around an environment and do linear-time variable lookups), and later we’re going to compile our terms directly to host language terms. So this interpreter is just a nice aside, for fun and testing.
</p>
<p>
With that said, given a closed term, we can interpret it directly to a value of its corresponding host language type. We need typed environments and a indexing function (note that for some reason GHC can’t see that the last case of the indexing function is impossible; if we tried implementing it in, say, Agda, we wouldn’t have to write that case).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Env</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>ENil</span> <span style="color: red">::</span> <span>Env</span> <span style="color: teal">'</span><span>[]</span>
  <span>ECons</span> <span style="color: red">::</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Env</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span>

<span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span style="color: red">::</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span style="color: red">(</span><span>ECons</span> <span>x</span> <span style="color: blue;font-weight: bold">_</span><span style="color: red">)</span> <span>!</span> <span>VZ</span> <span style="color: red">=</span> <span>x</span>
<span style="color: red">(</span><span>ECons</span> <span style="color: blue;font-weight: bold">_</span> <span>e</span><span style="color: red">)</span> <span>!</span> <span style="color: red">(</span><span>VS</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span>e</span> <span>!</span> <span>x</span>
<span>ENil</span> <span>!</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>error</span> <span style="color: teal">"GHC can't tell this is impossible"</span></code></pre>
<p>
Now the interpreter is straightforward. Look how beautifully everything works out with the type indexing.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>interpTTerm</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: teal">'</span><span>[]</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>interpTTerm</span> <span style="color: red">=</span> <span>go</span> <span>ENil</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>go</span> <span style="color: red">::</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
    <span>go</span> <span>e</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
      <span>TVar</span> <span>x</span> <span style="color: red">-&gt;</span> <span>e</span> <span>!</span> <span>x</span>
      <span>TLam</span> <span>body</span> <span style="color: red">-&gt;</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>go</span> <span style="color: red">(</span><span>ECons</span> <span>x</span> <span>e</span><span style="color: red">)</span> <span>body</span>
      <span>TApp</span> <span>f</span> <span>x</span> <span style="color: red">-&gt;</span> <span>go</span> <span>e</span> <span>f</span> <span style="color: red">(</span><span>go</span> <span>e</span> <span>x</span><span style="color: red">)</span>
      <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>interpConst</span> <span>c</span>

<span>interpConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>interpConst</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span>CInt</span> <span>i</span> <span style="color: red">-&gt;</span> <span>i</span>
  <span>CIf</span> <span style="color: red">-&gt;</span> <span style="color: red">\</span><span>b</span> <span>t</span> <span>e</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">if</span> <span>b</span> <span style="color: blue;font-weight: bold">then</span> <span>t</span> <span style="color: blue;font-weight: bold">else</span> <span>e</span>
  <span>CAdd</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>+</span><span style="color: red">)</span>
  <span>CGt</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>&gt;</span><span style="color: red">)</span>
  <span>K</span> <span style="color: red">-&gt;</span> <span>const</span>
  <span>S</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>&lt;*&gt;</span><span style="color: red">)</span>
  <span>I</span> <span style="color: red">-&gt;</span> <span>id</span>
  <span>B</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>.</span><span style="color: red">)</span>
  <span>C</span> <span style="color: red">-&gt;</span> <span>flip</span></code></pre>
<pre><code>λ&gt; interpTTerm . fromJust . check CNil TTyInt $ example
2</code></pre>
<h2 id="compiling-to-combinators-type-indexed-bracket-abstraction">
Compiling to combinators: type-indexed bracket abstraction
</h2>
<p>
Now, on with the main attraction! It’s well-known that certain sets of <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinators</a> are Turing-complete: for example, <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">SKI is the most well-known complete set</a> (or just SK if you’re trying to be minimal). There are well-known algorithms for compiling lambda calculus terms into combinators, known generally as <em>bracket abstraction</em> (for further reading about bracket abstraction in general, see <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">Diller</a> <span class="citation">(2014)</span>; for some in-depth history along with illustrative Haskell code, see <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">Ben Lynn’s page on Combinatory Logic</a> <span class="citation">(2022)</span>; for nice example implementations in Haskell, see blog posts by <a href="gratzer2015bracket">Gratzer</a> <span class="citation">(2015)</span>, <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Seo</a> <span class="citation">(2016)</span>, and <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">Mahler</a> <span class="citation">(2021)</span>.)
</p>
<p>
So the idea is to compile our typed core language down to combinators. The resulting terms will have <em>no</em> lambdas or variables—only constants and application! The point is that by making environments implicit, with a few more tricks we can make use of the host language runtime’s ability to do beta reduction, which will be <em>much</em> more efficient than our interpreter.
</p>
<p>
The <code>BTerm</code> type below will be the compilation target. Again for illustration and/or debugging we can easily write a direct interpreter for <code>BTerm</code>—but this still isn’t the intended code path. There will still be one more step to convert <code>BTerm</code>s directly into host language terms.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>BTerm</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>BApp</span> <span style="color: red">::</span> <span>BTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>β</span>
  <span>BConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>BTerm</span> <span>ty</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span>BTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">=</span> <span>BApp</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span>BTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>BConst</span>

<span>interpBTerm</span> <span style="color: red">::</span> <span>BTerm</span> <span>ty</span> <span style="color: red">-&gt;</span> <span>ty</span>
<span>interpBTerm</span> <span style="color: red">(</span><span>BApp</span> <span>f</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span>interpBTerm</span> <span>f</span> <span style="color: red">(</span><span>interpBTerm</span> <span>x</span><span style="color: red">)</span>
<span>interpBTerm</span> <span style="color: red">(</span><span>BConst</span> <span>c</span><span style="color: red">)</span> <span style="color: red">=</span> <span>interpConst</span> <span>c</span></code></pre>
<p>
We will use the usual SKI combinators as well as <code>B</code> and <code>C</code>, which are like special-case variants of <code>S</code>:
</p>
<ul>
<li>
<code>S x y z = x z (y z)</code>
</li>
<li>
<code>B x y z = x (y z)</code>
</li>
<li>
<code>C x y z = x z (y )</code>
</li>
</ul>
<p>
<code>S</code> handles the application of <code>x</code> to <code>y</code> in the case where they both need access to a shared parameter <code>z</code>; <code>B</code> and <code>C</code> are similar, but <code>B</code> is used when only <code>y</code>, and not <code>x</code>, needs access to <code>z</code>, and <code>C</code> is for when only <code>x</code> needs access to <code>z</code>. Using <code>B</code> and <code>C</code> will allow for more efficient encodings than would be possible with <code>S</code> alone. If you want to compile a language with recursion you can also easily add the usual <code>Y</code> combinator (“<code>SICKBY</code>”), although the example language in this post has no recursion so we won’t use it.
</p>
<p>
Bracket abstraction is often presented in an untyped way, but I found this <a href="http://okmij.org/ftp/tagless-final/ski.pdf">really cool paper by Oleg Kiselyov</a> <span class="citation">(2018)</span> where he shows how to do bracket abstraction in a completely compositional, type-indexed way. I found the paper a bit hard to understand, but fortunately it came with <a href="http://okmij.org/ftp/tagless-final/skconv.ml">working OCaml code</a>! Translating it to Haskell was straightforward. Much later, after writing most of this blog post, I found a <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">a nice explanation of Kiselyov’s paper</a> by <span class="citation">Lynn (2022)</span> which helped me make more sense of the paper.
</p>
<p>
First, a data type for open terms, which represent an intermediate stage in the bracket abstraction algorithm, where some parts have been converted to closed combinator terms (the <code>E</code> constructor embeds <code>BTerm</code> values), and some parts still have not. This corresponds to Kiselyov’s eta-optimized version (section 4.1 of the paper). A simplified version that does not include <code>V</code> is possible, but results in longer combinator expressions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>OTerm</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>

  <span style="color: green">-- E contains embedded closed (i.e. already abstracted) terms.</span>
  <span>E</span> <span style="color: red">::</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span>

  <span style="color: green">-- V represents a reference to the innermost/top environment</span>
  <span style="color: green">-- variable, i.e. Z</span>
  <span>V</span> <span style="color: red">::</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>

  <span style="color: green">-- N represents internalizing the innermost bound variable as a</span>
  <span style="color: green">-- function argument. In other words, we can represent an open</span>
  <span style="color: green">-- term referring to a certain variable as a function which</span>
  <span style="color: green">-- takes that variable as an argument.</span>
  <span>N</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span>

  <span style="color: green">-- For efficiency, there is also a special variant of N for the</span>
  <span style="color: green">-- case where the term does not refer to the topmost variable at</span>
  <span style="color: green">-- all.</span>
  <span>W</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span>β</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span style="color: red">(</span><span>OTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>E</span> <span>.</span> <span>embed</span></code></pre>
<p>
Now for the bracket abstraction algorithm. First, a function to do type- and environment-preserving conversion from <code>TTerm</code> to <code>OTerm</code>. The <code>conv</code> function handles the variable, lambda, and constant cases. The application case is handled by the <code>Applicable</code> instance.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>conv</span> <span style="color: red">::</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span>
<span>conv</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span>TVar</span> <span>VZ</span> <span style="color: red">-&gt;</span> <span>V</span>
  <span>TVar</span> <span style="color: red">(</span><span>VS</span> <span>x</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>W</span> <span style="color: red">(</span><span>conv</span> <span style="color: red">(</span><span>TVar</span> <span>x</span><span style="color: red">)</span><span style="color: red">)</span>
  <span>TLam</span> <span>t</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">case</span> <span>conv</span> <span>t</span> <span style="color: blue;font-weight: bold">of</span>
    <span>V</span> <span style="color: red">-&gt;</span> <span>E</span> <span style="color: red">(</span><span>embed</span> <span>I</span><span style="color: red">)</span>
    <span>E</span> <span>d</span> <span style="color: red">-&gt;</span> <span>E</span> <span style="color: red">(</span><span>K</span> <span>.&#36;&#36;</span> <span>d</span><span style="color: red">)</span>
    <span>N</span> <span>e</span> <span style="color: red">-&gt;</span> <span>e</span>
    <span>W</span> <span>e</span> <span style="color: red">-&gt;</span> <span>K</span> <span>.&#36;&#36;</span> <span>e</span>
  <span>TApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>conv</span> <span>t1</span> <span>&#36;&#36;</span> <span>conv</span> <span>t2</span>
  <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>embed</span> <span>c</span></code></pre>
<p>
The <code>Applicable</code> instance for <code>OTerm</code> has 15 cases—one for each combination of <code>OTerm</code> constructors. Why not 16, you ask? Because the <code>V $$ V</code> case is impossible (exercise for the reader: why?). The cool thing is that GHC can tell that case would be ill-typed, and agrees that this definition is total—that is, it does not give a non-exhaustive pattern match warning. This is a lot of code, but understanding each individual case is not too hard if you understand the meaning of the constructors <code>E</code>, <code>V</code>, <code>N</code>, and <code>W</code>. For example, if we have one term that ignores the innermost bound variable being applied to another term that also ignores the innermost bound variable (<code>W e1 $$ W e2</code>), we can apply one term to the other and wrap the result in <code>W</code> again (<code>W (e1 $$ e2)</code>). Other cases use the combinators <code>B</code>, <code>C</code>, <code>S</code> to route the input to the proper places in an application.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span style="color: red">(</span><span>OTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>β</span>
  <span>W</span> <span>e1</span> <span>&#36;&#36;</span> <span>W</span> <span>e2</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>W</span> <span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>W</span> <span>e</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>W</span> <span>e</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span>e</span>
  <span>V</span> <span>&#36;&#36;</span> <span>W</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>I</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>W</span> <span>e1</span> <span>&#36;&#36;</span> <span>N</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>B</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e1</span> <span>&#36;&#36;</span> <span>W</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e1</span> <span>&#36;&#36;</span> <span>N</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;</span> <span>e</span> <span>&#36;&#36;.</span> <span>I</span><span style="color: red">)</span>
  <span>V</span> <span>&#36;&#36;</span> <span>N</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;.</span> <span>I</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>N</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>B</span> <span>.&#36;&#36;</span> <span>d</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span>d</span><span style="color: red">)</span>
  <span>V</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>I</span> <span>&#36;&#36;</span> <span>d</span><span style="color: red">)</span><span style="color: red">)</span>
  <span>N</span> <span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>C</span> <span>&#36;&#36;</span> <span>d</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d1</span> <span>&#36;&#36;</span> <span>E</span> <span>d2</span> <span style="color: red">=</span> <span>E</span> <span style="color: red">(</span><span>d1</span> <span>&#36;&#36;</span> <span>d2</span><span style="color: red">)</span></code></pre>
<p>
The final bracket abstraction algorithm consists of calling <code>conv</code> on a closed <code>TTerm</code>—this must result in a term of type <code>OTerm ’[] α</code>, and the only constructor which could possibly produce such a type is <code>E</code>, containing an embedded <code>BTerm</code>. So we can just extract that <code>BTerm</code>, and GHC can see that this is total.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>bracket</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: teal">'</span><span>[]</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span>
<span>bracket</span> <span>t</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span>conv</span> <span>t</span> <span style="color: blue;font-weight: bold">of</span> <span style="color: red">{</span> <span>E</span> <span>t'</span> <span style="color: red">-&gt;</span> <span>t'</span> <span style="color: red">}</span></code></pre>
<p>
Let’s apply this to our <code>example</code> term and see what we get:
</p>
<pre><code>λ&gt; putStrLn . pretty . bracket . fromJust . check CNil TTyInt $ example
C C 1 (C C (C C 1 plus) (B S (C C I (B S (B (B if) (B (B (gt 7)) (C I (C C 3 plus)))))))) (S B I)
λ&gt; interpBTerm . bracket . fromJust . check CNil TTyInt $ example
2</code></pre>
<p>
Neat! This is not too much longer than the original term, which is the point of using the optimized version. Interestingly, this example happens to not use <code>K</code> at all, but a more complex term certainly would.
</p>
<p>
Kiselyov also presents an even better algorithm using <span class="math inline">\(n\)</span>-ary combinators which uses guaranteed linear time and space. For simplicity, he presents it in an untyped way and claims in passing that it “can be backported to the typed case”, though I am not aware of anyone who has actually done this yet (perhaps I will, later). <span class="citation">Lynn (2022)</span> has <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">a nice explanation of Kiselyov’s paper</a>, including a section that explores several alternatives to Kiselyov’s linear-time algorithm.
</p>
<h2 id="compiling-type-indexed-combinators-to-haskell">
Compiling type-indexed combinators to Haskell
</h2>
<p>
So at this point we can take a <code>Term</code>, typecheck it to produce a <code>TTerm</code>, then use bracket abstraction to convert that to a <code>BTerm</code>. We have an interpreter for <code>BTerm</code>s, but we’re instead going to do one more compilation step, to turn <code>BTerm</code>s directly into native Haskell values. This idea originates with <span class="citation">Naylor (2008)</span> and is well-explained in blog posts by <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Seo</a> <span class="citation">(2016)</span> and <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">Mahler</a> <span class="citation">(2022)</span>. This still feels a little like black magic to me, and I am actually unclear on whether it is really faster than calling <code>interpBTerm</code>; some benchmarking would be needed. In any case I include it here for completeness.
</p>
<p>
Our target for this final compilation step is the following <code>CTerm</code> type, which has only functions, represented by <code>CFun</code>, and constants. Note, however, that <code>CConst</code> is intended to be used only for non-function types, <em>i.e.</em> base types, although there’s no nice way (that I know of, at least) to use the Haskell type system to enforce this.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>CTerm</span> <span>α</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CFun</span> <span style="color: red">::</span> <span style="color: red">(</span><span>CTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>
  <span>CConst</span> <span style="color: red">::</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span> <span style="color: green">-- CConst invariant: α is not a function type</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span>CTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CFun</span> <span>f</span> <span>&#36;&#36;</span> <span>x</span> <span style="color: red">=</span> <span>f</span> <span>x</span>
  <span>CConst</span> <span style="color: blue;font-weight: bold">_</span> <span>&#36;&#36;</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>error</span> <span style="color: teal">"CConst should never contain a function!"</span>

<span>compile</span> <span style="color: red">::</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span>
<span>compile</span> <span style="color: red">(</span><span>BApp</span> <span>b1</span> <span>b2</span><span style="color: red">)</span> <span style="color: red">=</span> <span>compile</span> <span>b1</span> <span>&#36;&#36;</span> <span>compile</span> <span>b2</span>
<span>compile</span> <span style="color: red">(</span><span>BConst</span> <span>c</span><span style="color: red">)</span> <span style="color: red">=</span> <span>compileConst</span> <span>c</span>

<span>compileConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span>
<span>compileConst</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span style="color: red">(</span><span>CInt</span> <span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CConst</span> <span>i</span>
  <span>CIf</span>      <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>t</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>e</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">if</span> <span>b</span> <span style="color: blue;font-weight: bold">then</span> <span>t</span> <span style="color: blue;font-weight: bold">else</span> <span>e</span>
  <span>CAdd</span>     <span style="color: red">-&gt;</span> <span>binary</span> <span style="color: red">(</span><span>+</span><span style="color: red">)</span>
  <span>CGt</span>      <span style="color: red">-&gt;</span> <span>binary</span> <span style="color: red">(</span><span>&gt;</span><span style="color: red">)</span>
  <span>K</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>x</span>
  <span>S</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>g</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span>x</span> <span>&#36;&#36;</span> <span style="color: red">(</span><span>g</span> <span>&#36;&#36;</span> <span>x</span><span style="color: red">)</span>
  <span>I</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>id</span>
  <span>B</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>g</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span style="color: red">(</span><span>g</span> <span>&#36;&#36;</span> <span>x</span><span style="color: red">)</span>
  <span>C</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>y</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span>y</span> <span>&#36;&#36;</span> <span>x</span>

<span>binary</span> <span style="color: red">::</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
<span>binary</span> <span>op</span> <span style="color: red">=</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>x</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>y</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CConst</span> <span style="color: red">(</span><span>op</span> <span>x</span> <span>y</span><span style="color: red">)</span></code></pre>
<p>
Finally, we can “run” a <code>CTerm α</code> to extract a value of type <code>α</code>. Typically, if <code>α</code> is some kind of base type like <code>Int</code>, <code>runCTerm</code> doesn’t actually do any work—all the work is done by the Haskell runtime itself. However, for completeness, I include a case for <code>CFun</code> as well.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>runCTerm</span> <span style="color: red">::</span> <span>CTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>runCTerm</span> <span style="color: red">(</span><span>CConst</span> <span>a</span><span style="color: red">)</span> <span style="color: red">=</span> <span>a</span>
<span>runCTerm</span> <span style="color: red">(</span><span>CFun</span> <span>f</span><span style="color: red">)</span> <span style="color: red">=</span> <span>runCTerm</span> <span>.</span> <span>f</span> <span>.</span> <span>CConst</span></code></pre>
<p>
We can put this all together into our final pipeline:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>evalInt</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>Int</span>
<span>evalInt</span> <span style="color: red">=</span> <span>fmap</span> <span style="color: red">(</span><span>runCTerm</span> <span>.</span> <span>compile</span> <span>.</span> <span>bracket</span><span style="color: red">)</span> <span>.</span> <span>check</span> <span>CNil</span> <span>TTyInt</span></code></pre>
<pre><code>λ&gt; evalInt example
Just 2</code></pre>
<h1 id="appendices">
Appendices
</h1>
<p>
There’s nothing interesting to see here—unless you’ve never written a parser or pretty-printer before, in which case perhaps it is very interesting! If you want to learn how to write parsers, see <a href="https://markkarpov.com/tutorial/megaparsec.html">this very nice Megaparsec tutorial</a>. And <a href="https://hendrix-cs.github.io/csci360/modules/05-pretty-parse.html">see here for some help writing a basic pretty-printer</a>.
</p>
<h2 id="parsing">
Parsing
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>Parser</span> <span style="color: red">=</span> <span>Parsec</span> <span>Void</span> <span>Text</span>
<span style="color: blue;font-weight: bold">type</span> <span>ParserError</span> <span style="color: red">=</span> <span>ParseErrorBundle</span> <span>Text</span> <span>Void</span>

<span>reservedWords</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Text</span><span style="color: red">]</span>
<span>reservedWords</span> <span style="color: red">=</span> <span style="color: red">[</span><span style="color: teal">"let"</span><span style="color: red">,</span> <span style="color: teal">"in"</span><span style="color: red">,</span> <span style="color: teal">"if"</span><span style="color: red">,</span> <span style="color: teal">"then"</span><span style="color: red">,</span> <span style="color: teal">"else"</span><span style="color: red">,</span> <span style="color: teal">"Int"</span><span style="color: red">,</span> <span style="color: teal">"Bool"</span><span style="color: red">]</span>

<span>sc</span> <span style="color: red">::</span> <span>Parser</span> <span>()</span>
<span>sc</span> <span style="color: red">=</span> <span>L.space</span> <span>space1</span> <span style="color: red">(</span><span>L.skipLineComment</span> <span style="color: teal">"--"</span><span style="color: red">)</span> <span>empty</span>

<span>lexeme</span> <span style="color: red">::</span> <span>Parser</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>a</span>
<span>lexeme</span> <span style="color: red">=</span> <span>L.lexeme</span> <span>sc</span>

<span>symbol</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>Text</span>
<span>symbol</span> <span style="color: red">=</span> <span>L.symbol</span> <span>sc</span>

<span>reserved</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>()</span>
<span>reserved</span> <span>w</span> <span style="color: red">=</span> <span style="color: red">(</span><span>lexeme</span> <span>.</span> <span>try</span><span style="color: red">)</span> <span>$</span> <span>string'</span> <span>w</span> <span>*&gt;</span> <span>notFollowedBy</span> <span>alphaNumChar</span>

<span>identifier</span> <span style="color: red">::</span> <span>Parser</span> <span>Text</span>
<span>identifier</span> <span style="color: red">=</span> <span style="color: red">(</span><span>lexeme</span> <span>.</span> <span>try</span><span style="color: red">)</span> <span style="color: red">(</span><span>p</span> <span>&gt;&gt;=</span> <span>nonReserved</span><span style="color: red">)</span> <span>&lt;?&gt;</span> <span style="color: teal">"variable name"</span>
 <span style="color: blue;font-weight: bold">where</span>
  <span>p</span> <span style="color: red">=</span> <span style="color: red">(</span><span>:</span><span style="color: red">)</span> <span>&lt;$&gt;</span> <span>letterChar</span> <span>&lt;*&gt;</span> <span>many</span> <span>alphaNumChar</span>
  <span>nonReserved</span> <span style="color: red">(</span><span>into</span> <span style="color: red">@</span><span>Text</span> <span style="color: red">-&gt;</span> <span>t</span><span style="color: red">)</span>
    <span style="color: red">|</span> <span>t</span> <span>`elem`</span> <span>reservedWords</span> <span style="color: red">=</span>
        <span>fail</span> <span>.</span> <span>into</span> <span style="color: red">@</span><span>String</span> <span>$</span>
          <span>T.concat</span> <span style="color: red">[</span><span style="color: teal">"reserved word '"</span><span style="color: red">,</span> <span>t</span><span style="color: red">,</span> <span style="color: teal">"' cannot be used as variable name"</span><span style="color: red">]</span>
    <span style="color: red">|</span> <span>otherwise</span> <span style="color: red">=</span> <span>return</span> <span>t</span>

<span>integer</span> <span style="color: red">::</span> <span>Parser</span> <span>Int</span>
<span>integer</span> <span style="color: red">=</span> <span>lexeme</span> <span>L.decimal</span>

<span>parens</span> <span style="color: red">::</span> <span>Parser</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>a</span>
<span>parens</span> <span style="color: red">=</span> <span>between</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"("</span><span style="color: red">)</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">")"</span><span style="color: red">)</span>

<span>parseTermAtom</span> <span style="color: red">::</span> <span>Parser</span> <span>Term</span>
<span>parseTermAtom</span> <span style="color: red">=</span>
      <span>Lit</span> <span>&lt;$&gt;</span> <span>integer</span>
  <span>&lt;|&gt;</span> <span>Var</span> <span>&lt;$&gt;</span> <span>identifier</span>
  <span>&lt;|&gt;</span> <span>Lam</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"\\"</span> <span>*&gt;</span> <span>identifier</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">":"</span> <span>*&gt;</span> <span>parseType</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"."</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>Let</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"let"</span> <span>*&gt;</span> <span>identifier</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"="</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"in"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>If</span>  <span>&lt;$&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"if"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"then"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"else"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>parens</span> <span>parseTerm</span>

<span>parseTerm</span> <span style="color: red">::</span> <span>Parser</span> <span>Term</span>
<span>parseTerm</span> <span style="color: red">=</span> <span>makeExprParser</span> <span>parseTermAtom</span>
  <span style="color: red">[</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>App</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">""</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">,</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>Add</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"+"</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">,</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>Gt</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"&gt;"</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">]</span>

<span>parseTypeAtom</span> <span style="color: red">::</span> <span>Parser</span> <span>Ty</span>
<span>parseTypeAtom</span> <span style="color: red">=</span>
  <span>TyInt</span> <span>&lt;$</span> <span>reserved</span> <span style="color: teal">"Int"</span>
  <span>&lt;|&gt;</span> <span>TyBool</span> <span>&lt;$</span> <span>reserved</span> <span style="color: teal">"Bool"</span>
  <span>&lt;|&gt;</span> <span>parens</span> <span>parseType</span>

<span>parseType</span> <span style="color: red">::</span> <span>Parser</span> <span>Ty</span>
<span>parseType</span> <span style="color: red">=</span> <span>makeExprParser</span> <span>parseTypeAtom</span>
  <span style="color: red">[</span> <span style="color: red">[</span><span>InfixR</span> <span style="color: red">(</span><span>TyFun</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"-&gt;"</span><span style="color: red">)</span><span style="color: red">]</span> <span style="color: red">]</span>

<span>readTerm</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span>
<span>readTerm</span> <span style="color: red">=</span> <span>either</span> <span>undefined</span> <span>id</span> <span>.</span> <span>runParser</span> <span>parseTerm</span> <span style="color: teal">""</span></code></pre>
<h2 id="pretty-printing">
Pretty-printing
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>Prec</span> <span style="color: red">=</span> <span>Int</span>

<span style="color: blue;font-weight: bold">class</span> <span>Pretty</span> <span>p</span> <span style="color: blue;font-weight: bold">where</span>
  <span>pretty</span> <span style="color: red">::</span> <span>p</span> <span style="color: red">-&gt;</span> <span>String</span>
  <span>pretty</span> <span style="color: red">=</span> <span>prettyPrec</span> <span class="hs-num">0</span>

  <span>prettyPrec</span> <span style="color: red">::</span> <span>Prec</span> <span style="color: red">-&gt;</span> <span>p</span> <span style="color: red">-&gt;</span> <span>String</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>pretty</span>

<span>mparens</span> <span style="color: red">::</span> <span>Bool</span> <span style="color: red">-&gt;</span> <span>String</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>mparens</span> <span>True</span>  <span style="color: red">=</span> <span style="color: red">(</span><span style="color: teal">"("</span><span>++</span><span style="color: red">)</span> <span>.</span> <span style="color: red">(</span><span>++</span><span style="color: teal">")"</span><span style="color: red">)</span>
<span>mparens</span> <span>False</span> <span style="color: red">=</span> <span>id</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>Const</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>CInt</span> <span>i</span> <span style="color: red">-&gt;</span> <span>show</span> <span>i</span>
    <span>CIf</span> <span style="color: red">-&gt;</span> <span style="color: teal">"if"</span>
    <span>CAdd</span> <span style="color: red">-&gt;</span> <span style="color: teal">"plus"</span>
    <span>CGt</span>  <span style="color: red">-&gt;</span> <span style="color: teal">"gt"</span>
    <span>c</span> <span style="color: red">-&gt;</span> <span>show</span> <span>c</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span style="color: red">(</span><span style="color: teal">"x"</span> <span>++</span><span style="color: red">)</span> <span>.</span> <span>show</span> <span>.</span> <span>toNat</span>
    <span style="color: blue;font-weight: bold">where</span>
      <span>toNat</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Int</span>
      <span>toNat</span> <span>VZ</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span>toNat</span> <span style="color: red">(</span><span>VS</span> <span>i</span><span style="color: red">)</span> <span style="color: red">=</span> <span class="hs-num">1</span> <span>+</span> <span>toNat</span> <span>i</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span>p</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>TVar</span> <span>x</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>x</span>
    <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>c</span>
    <span>TLam</span> <span>t</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">0</span><span style="color: red">)</span> <span>$</span> <span style="color: teal">"λ. "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">0</span> <span>t</span>
    <span>TApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">1</span><span style="color: red">)</span> <span>$</span>
      <span>prettyPrec</span> <span class="hs-num">1</span> <span>t1</span> <span>++</span> <span style="color: teal">" "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">2</span> <span>t2</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>BTerm</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span>p</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>BConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>c</span>
    <span>BApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">0</span><span style="color: red">)</span> <span>$</span>
      <span>prettyPrec</span> <span class="hs-num">0</span> <span>t1</span> <span>++</span> <span style="color: teal">" "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">1</span> <span>t2</span></code></pre>
<h1 class="unnumbered" id="references">
References
</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-augustsson1986small" class="csl-entry" role="doc-biblioentry">
Augustsson, L. (1986) <em>SMALL: A small interactive functional system</em>. Chalmers Tekniska H<span>ö</span>gskola/G<span>ö</span>teborgs Universitet. Programming Methodology Group.
</div>
<div id="ref-diller1988compiling" class="csl-entry" role="doc-biblioentry">
Diller, A. (1988) <em>Compiling functional languages</em>. John Wiley &amp; Sons, Inc.
</div>
<div id="ref-diller2014bracket" class="csl-entry" role="doc-biblioentry">
Diller, A. (2014) <em><span class="nocase">Bracket abstraction algorithms</span></em>. Available at: <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">https://www.cantab.net/users/antoni.diller/brackets/intro.html</a>.
</div>
<div id="ref-elliott2017compiling" class="csl-entry" role="doc-biblioentry">
Elliott, C. (2017) <span>‘Compiling to categories’</span>, <em>Proceedings of the ACM on Programming Languages</em>, 1(ICFP), pp. 1–27.
</div>
<div id="ref-gratzer2015bracket" class="csl-entry" role="doc-biblioentry">
Gratzer, D. (2015) <em><span class="nocase">Bracket Abstraction: The Smallest PL You’ve Ever Seen</span></em>. Available at: <a href="https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html">https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html</a>.
</div>
<div id="ref-spj1987implementation" class="csl-entry" role="doc-biblioentry">
Jones, S.L.P. (1987) <em><span class="nocase">The Implementation of Functional Programming Languages</span></em>. Prentice-Hall, Inc.
</div>
<div id="ref-kiselyov2018lambda" class="csl-entry" role="doc-biblioentry">
Kiselyov, O. (2018) <span>‘<span class="math inline"><em>λ</em></span> to ski, semantically: Declarative pearl’</span>, in <em>International symposium on functional and logic programming</em>. Springer, pp. 33–50.
</div>
<div id="ref-le2017singletons" class="csl-entry" role="doc-biblioentry">
Le, J. (2017) <em><span class="nocase">Introduction to Singletons (Part 1)</span></em>. Available at: <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">https://blog.jle.im/entry/introduction-to-singletons-1.html</a>.
</div>
<div id="ref-lynncompiler" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2017) <em><span>A Combinatory Compiler</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">https://crypto.stanford.edu/~blynn/lambda/sk.html</a>.
</div>
<div id="ref-lynncl" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2022) <em><span>Combinatory Logic</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">https://crypto.stanford.edu/~blynn/lambda/cl.html</a>.
</div>
<div id="ref-lynnkiselyov" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2022) <em><span>Kiselyov Combinator Translation</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">https://crypto.stanford.edu/~blynn/lambda/kiselyov.html</a>.
</div>
<div id="ref-mahler2021graph" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2021) <em><span class="nocase">Implementing a Functional Language with Graph Reduction</span></em>. Available at: <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html</a>.
</div>
<div id="ref-mahler2021ccc" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2021) <em><span class="nocase">λ-Calculus, Combinatory Logic and Cartesian Closed Categories</span></em>. Available at: <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html</a>.
</div>
<div id="ref-mahler2022evaluating" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2022) <em><span class="nocase">Evaluating SKI combinators as native Haskell functions</span></em>. Available at: <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html</a>.
</div>
<div id="ref-naylor2008evaluating" class="csl-entry" role="doc-biblioentry">
Naylor, M. (2008) <span>‘<span class="nocase">Evaluating Haskell in Haskell</span>’</span>, <em>The Monad.Reader</em>. Edited by W. Swierstra, Issue 10.
</div>
<div id="ref-seo2016interpreter" class="csl-entry" role="doc-biblioentry">
Seo, K.Y. (2016) <em><span class="nocase">Write you an interpreter</span></em>. Available at: <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html</a>.
</div>
<div id="ref-turner1979new" class="csl-entry" role="doc-biblioentry">
Turner, D.A. (1979) <span>‘A new implementation technique for applicative languages’</span>, <em>Software: Practice and Experience</em>, 9(1), pp. 31–49.
</div>
</div>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Compiling to Intrinsically Typed Combinators" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-07-13T20:55:18Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/07/13/compiling-to-intrinsically-typed-combinators.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: two more DP challenges</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: two more DP challenges</h1>

<div class="info">
  Posted on June 20, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
Continuing the <a href="https://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html">series on dynamic programming</a>, I just have a couple challenge problems for you today. I have indeed solved both of these problems in Haskell, but I don’t yet know how to write <strong>elegant</strong> solutions! There is a reason that the techniques covered in my <a href="https://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html">previous posts</a> aren’t quite good enough.
</p>
<ul>
<li>
<a href="https://open.kattis.com/problems/honi">Honi</a>
</li>
<li>
<a href="https://open.kattis.com/problems/assassins">Assassins</a>
</li>
</ul>
<p>
Feel free to discuss in the comments! I’m hoping that I can learn some new approaches from some of my readers. I will probably post some hints in the comments towards the right recurrences, so don’t look at the comments if you don’t want any spoilers.
</p>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread"  data-title="Competitive Programming in Haskell: two more DP challenges" >
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>

]]></description>
    <pubDate>2023-06-20T20:42:24Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>

    </channel>
</rss>
