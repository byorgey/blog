<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>blog :: Brent -> [String]</title>
        <link>http://byorgey.github.io/blog</link>
        <description><![CDATA[Brent Yorgey's academic blog]]></description>
        <atom:link href="http://byorgey.github.io/blog/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 22 Aug 2023 17:37:34 UT</lastBuildDate>
        <item>
    <title>Swarm 0.4 release</title>
    <link>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</link>
    <description><![CDATA[
<h1>Swarm 0.4 release</h1>

<div class="info">
  Posted on August 22, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;game&#39;." href="/tag/game.html" rel="tag">game</a>, <a title="All pages tagged &#39;programming&#39;." href="/tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged &#39;resource&#39;." href="/tag/resource.html" rel="tag">resource</a>, <a title="All pages tagged &#39;robot&#39;." href="/tag/robot.html" rel="tag">robot</a>, <a title="All pages tagged &#39;Swarm&#39;." href="/tag/Swarm.html" rel="tag">Swarm</a>
  
</div>

<section>
<p>
The <a href="https://github.com/swarm-game/swarm/">Swarm</a> development team is very proud to announce the latest release of the game. This should still be considered a development/preview release—you still can’t <a href="https://github.com/swarm-game/swarm/issues/50">save your games</a>—but it’s made some remarkable progress and there are lots of fun things to try.
</p>
<h2 id="what-is-it">
What is it?
</h2>
<p>
As a reminder, Swarm is a 2D, open-world programming and resource gathering game with a strongly-typed, functional programming language and a unique upgrade system. Unlocking language features is tied to collecting resources, making it an interesting challenge to bootstrap your way into the use of the full language. It has also become a flexible and powerful platform for constructing programming challenges.
</p>
<p>
A few of the most significant new features are highlighted below; for full details, see the <a href="https://github.com/swarm-game/swarm/releases/tag/0.4.0.0">release notes</a>. If you just want to try it out, see the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>.
</p>
<h2 id="expanded-design-possibilities">
Expanded design possibilities
</h2>
<p>
The default play mode is the open-world, resource-gathering scenario—but Swarm also supports “challenge scenarios”, where you have to complete one or more specific objectives with given resources on a custom map. There are currently 58 scenarios and counting—some are silly proofs of concept, but many are quite fun and challenging! I especially recommend checking out the <code>Ranching</code> and <code>Sokoban</code> scenarios, as well as <code>A Frivolous Excursion</code> (pictured below). And creating new scenarios is a great way you can contribute to Swarm even if you don’t know Haskell, or aren’t comfortable hacking on the codebase.
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/excursion.png" />
</p>
</div>
<p>
Recently, a large amount of work has gone into expanding the possibilities for scenario design:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1332">Structure templates</a> allow you to design map tiles and then reuse them multiple times within a scenario.
</li>
<li>
<a href="https://github.com/swarm-game/swarm/pull/1356">Waypoints and portals</a> provide a mechanism for automatically navigating and teleporting around the world.
</li>
<li>
Scenarios can have multiple <a href="https://github.com/swarm-game/swarm/pull/1353">subworlds</a> besides the main “overworld”, connected by portals. For example you could go “into a building” and have a separate map for the building interior.
</li>
<li>
There are a slew of new robot commands, many to do with different sensing modalities: <code>stride</code>, <code>detect</code>, <code>sniff</code>, <code>chirp,</code> <code>resonate</code>, <code>watch</code>, <code>surveil</code>, <code>scout</code>, <code>instant</code>, <code>push</code>, <code>density</code>, <code>use</code>, <code>halt</code>, and <code>backup</code>.
</li>
<li>
A <a href="https://github.com/swarm-game/swarm/pull/1376">new domain-specific language</a> for describing procedurally generated worlds. The default procedurally generated world used to be hardcoded, but now it is described externally via the new DSL, and you can design your own procedurally generated worlds without editing the Swarm source code.
</li>
<li>
The <a href="https://github.com/swarm-game/swarm/pull/1214">key input handler</a> feature allows you to program robots to respond to keyboard input, so you can <em>e.g.</em> drive them around manually, or interactively trigger more complex behaviors. This makes it possible to design “arcade-style” challenges, where the player needs to guide a robot and react to obstacles in real time—but they get to program the robot to respond to their commands first!
</li>
<li>
A new prototype <a href="https://github.com/swarm-game/swarm/pull/873">integrated world editor</a> lets you design worlds interactively.
</li>
</ul>
<h2 id="ui-improvements">
UI improvements
</h2>
<p>
In the past, entity and goal descriptions were simply plain text; recently, we switched to actually parsing Markdown. Partly, this is just to make things look nice, since we can highlight code snippets, entity names, etc.:
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/crafting.png" />
</p>
</div>
<p>
But it also means that we can now validate all code examples and entity names, and even test that the tutorial is pedagogically sound: any command used in a tutorial solution must be mentioned in a previous tutorial, or else our CI fails!
</p>
<p>
There are also a number of other small UI enhancements, such as improved type error messages, inventory search, and a collapsible REPL panel, among others.
</p>
<h2 id="scoring-metrics">
Scoring metrics
</h2>
<p>
We now keep track of a number of metrics related to challenge scenario solutions, such as total time, total game ticks, and code size. These metrics are tracked and saved across runs, so you can compete with yourself, and with others. For now, see these wiki pages:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Speedrunning">Swarm speedrunning</a>
</li>
<li>
<a href="https://github.com/swarm-game/swarm/wiki/Code-golf">Swarm code golf</a>
</li>
</ul>
<p>
In the future, perhaps there will eventually be some kind of <a href="https://github.com/swarm-game/swarm/issues/1259">social website</a> with leaderboards and user-uploaded scenarios.
</p>
<h2 id="debugging">
Debugging
</h2>
<p>
Last but not least, we now have an <a href="https://github.com/swarm-game/swarm/pull/1081">integrated single-stepping and debugging mode</a> (enabled by the <code>tweezers</code> device).
</p>
<div style="text-align: center">
<p>
<img src="http://byorgey.files.wordpress.com/2023/08/debugger.png" />
</p>
</div>
<h2 id="give-it-a-try">
Give it a try!
</h2>
<p>
To install, check out the <a href="https://github.com/swarm-game/swarm#installing">installation instructions</a>: you can download a <a href="https://github.com/swarm-game/swarm/releases">binary release</a> (for now, Linux only, but MacOS binaries should be on the horizon), or <a href="https://hackage.haskell.org/package/swarm">install from Hackage</a>. Give it a try and send us your feedback, either <a href="https://github.com/swarm-game/swarm/issues/new/choose">via a github issue</a> or <a href="https://web.libera.chat/?channels=#swarm">IRC</a>!
</p>
<h2 id="future-plans-getting-involved">
Future plans &amp; getting involved
</h2>
<p>
We’re still hard at work on the game. Fun upcoming things include:
</p>
<ul>
<li>
<a href="https://github.com/swarm-game/swarm/issues/50">Saving and loading games</a>
</li>
<li>
New world features like aliens and <a href="https://github.com/swarm-game/swarm/issues/112">cities</a>
</li>
<li>
New language features like <a href="https://github.com/swarm-game/swarm/issues/154">recursive types</a>, <a href="https://github.com/swarm-game/swarm/issues/98">arrays</a>, <a href="https://github.com/swarm-game/swarm/issues/94">inter-robot communication</a>, and <a href="https://github.com/swarm-game/swarm/issues/495">a proper <code>import</code> construct</a>
</li>
</ul>
<p>
Of course, there are also <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">tons of small things that need fixing and polishing</a> too! If you’re interested in getting involved, check out our <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">contribution guide</a>, come <a href="https://web.libera.chat/?channels=#swarm">join us on IRC</a> (<code>#swarm</code> on Libera.Chat), or take a look at the list of <a href="https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+label%3A%22C-Low+Hanging+Fruit%22">issues marked “low-hanging fruit”</a>.
</p>
<p>
Brought to you by the Swarm development team:
</p>
<ul>
<li>
Brent Yorgey
</li>
<li>
Karl Ostmo
</li>
<li>
Ondřej Šebek
</li>
</ul>
<p>
With contributions from:
</p>
<ul>
<li>
Alexander Block
</li>
<li>
Brian Wignall
</li>
<li>
Chris Casinghino
</li>
<li>
Daniel Díaz Carrete
</li>
<li>
Huw Campbell
</li>
<li>
Ishan Bhanuka
</li>
<li>
Jacob
</li>
<li>
Jens Petersen
</li>
<li>
José Rafael Vieira
</li>
<li>
Joshua Price
</li>
<li>
lsmor
</li>
<li>
Noah Yorgey
</li>
<li>
Norbert Dzikowski
</li>
<li>
Paul Brauner
</li>
<li>
Ryan Yates
</li>
<li>
Sam Tay
</li>
<li>
Steven Garcia
</li>
<li>
Tamas Zsar
</li>
<li>
Tristan de Cacqueray
</li>
<li>
Valentin Golev
</li>
</ul>
<p>
…not to mention many others who gave valuable suggestions and feedback. Want to see your name listed here in the next release? <a href="https://github.com/swarm-game/swarm/blob/main/CONTRIBUTING.md">See how you can contribute!</a>
</p>

]]></description>
    <pubDate>2023-08-22T17:37:34Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/08/22/swarm-0-4-release.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Compiling to Intrinsically Typed Combinators</title>
    <link>http://byorgey.github.io/blog/posts/2023/07/13/compiling-to-intrinsically-typed-combinators.html</link>
    <description><![CDATA[
<h1>Compiling to Intrinsically Typed Combinators</h1>

<div class="info">
  Posted on July 13, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;bracket&#39;." href="/tag/bracket.html" rel="tag">bracket</a>, <a title="All pages tagged &#39;combinators&#39;." href="/tag/combinators.html" rel="tag">combinators</a>, <a title="All pages tagged &#39;compile&#39;." href="/tag/compile.html" rel="tag">compile</a>, <a title="All pages tagged &#39;DSL&#39;." href="/tag/DSL.html" rel="tag">DSL</a>, <a title="All pages tagged &#39;indexed&#39;." href="/tag/indexed.html" rel="tag">indexed</a>, <a title="All pages tagged &#39;typed&#39;." href="/tag/typed.html" rel="tag">typed</a>
  
</div>

<section>
<p>
<strong>tl;dr</strong>: <em>How to compile a functional language via combinators (and evaluate via the Haskell runtime) while keeping the entire process type-indexed, with a bibliography and lots of references for further reading</em>
</p>
<p>
There is a long history, starting with Schönfinkel and Curry, of abstracting away variable names from lambda calculus terms by converting to combinators, aka <em>bracket abstraction</em>. This was popular in the 80’s as a compilation technique for functional languages <span class="citation">(Turner, 1979; Augustsson, 1986; Jones, 1987; Diller, 1988)</span>, then apparently abandoned. More recently, however, it has been making a bit of a comeback. For example, see <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=f801c21b2630df3094c9c800c18ebc1e969865da">Naylor</a> <span class="citation">(2008)</span>, <a href="https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html">Gratzer</a> <span class="citation">(2015)</span>, <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">Lynn</a> <span class="citation">(2017)</span>, and <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">Mahler</a> <span class="citation">(2021)</span>. Bracket abstraction is intimately related to compiling to cartesian closed categories <span class="citation">(Elliott, 2017; Mahler, 2021)</span>, and also enables cool tricks like doing evaluation via the Haskell runtime system <span class="citation">(Naylor, 2008; Seo, 2016; Mahler, 2022)</span>.
</p>
<p>
However, it always bothered me that the conversion to combinators was invariably described in an untyped way. Partly to gain some assurance that we are doing things correctly, but mostly for fun, I wondered if it would be possible to do the whole pipeline in an explicitly type-indexed way. I eventually found <a href="http://okmij.org/ftp/tagless-final/ski.pdf">a nice paper by Oleg Kiselyov</a> <span class="citation">(2018)</span> which explains exactly how to do it (it even came with <a href="http://okmij.org/ftp/tagless-final/skconv.ml">OCaml code</a> that I was easily able to port to Haskell!).
</p>
<p>
In this blog post, I:
</p>
<ul>
<li>
Show an example of typechecking and elaboration for a functional language into explicitly type-indexed terms, such that it is impossible to write down ill-typed terms
</li>
<li>
Demonstrate a Haskell port of Oleg Kiselyov’s typed bracket abstraction algorithm
</li>
<li>
Demonstrate type-indexed evaluation of terms via the Haskell runtime
</li>
<li>
Put together an extensive bibliography with references for further reading
</li>
</ul>
<p>
This blog post is rendered automatically from a literate Haskell file; you can <a href="https://github.com/byorgey/typed-combinators">find the complete working source code and blog post on GitHub</a>. I’m always happy to receive comments, fixes, or suggestions for improvement.
</p>
<h2 id="but-first-a-message-from-our-sponsors">
But First, A Message From Our Sponsors
</h2>
<p>
So many yummy language extensions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE ConstraintKinds #-}</span>
<span style="color: green">{-# LANGUAGE DataKinds #-}</span>
<span style="color: green">{-# LANGUAGE ExplicitForAll #-}</span>
<span style="color: green">{-# LANGUAGE FlexibleContexts #-}</span>
<span style="color: green">{-# LANGUAGE GADTs #-}</span>
<span style="color: green">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span style="color: green">{-# LANGUAGE InstanceSigs #-}</span>
<span style="color: green">{-# LANGUAGE KindSignatures #-}</span>
<span style="color: green">{-# LANGUAGE LambdaCase #-}</span>
<span style="color: green">{-# LANGUAGE OverloadedStrings #-}</span>
<span style="color: green">{-# LANGUAGE PatternSynonyms #-}</span>
<span style="color: green">{-# LANGUAGE RankNTypes #-}</span>
<span style="color: green">{-# LANGUAGE StandaloneDeriving #-}</span>
<span style="color: green">{-# LANGUAGE TypeApplications #-}</span>
<span style="color: green">{-# LANGUAGE TypeFamilies #-}</span>
<span style="color: green">{-# LANGUAGE TypeOperators #-}</span>
<span style="color: green">{-# LANGUAGE UnicodeSyntax #-}</span>
<span style="color: green">{-# LANGUAGE ViewPatterns #-}</span>

<span style="color: blue;font-weight: bold">module</span> <span>TypedCombinators</span> <span style="color: blue;font-weight: bold">where</span>

<span style="color: blue;font-weight: bold">import</span> <span>Control.Monad.Combinators.Expr</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Functor.Const</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>F</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Void</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Text</span> <span style="color: red">(</span> <span>Text</span> <span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Text</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>T</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Kind</span> <span style="color: red">(</span><span>Type</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Type.Equality</span> <span style="color: red">(</span> <span style="color: blue;font-weight: bold">type</span> <span style="color: red">(</span><span>:~:</span><span style="color: red">)</span><span style="color: red">(</span><span>Refl</span><span style="color: red">)</span><span style="color: red">,</span> <span>TestEquality</span><span style="color: red">(</span><span style="color: red">..</span><span style="color: red">)</span> <span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec.Char</span>
<span style="color: blue;font-weight: bold">import</span> <span>Text.Megaparsec.Char.Lexer</span> <span style="color: blue;font-weight: bold">qualified</span> <span style="color: blue;font-weight: bold">as</span> <span>L</span>
<span style="color: blue;font-weight: bold">import</span> <span>Witch</span> <span style="color: red">(</span><span>into</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>Prelude</span> <span>hiding</span> <span style="color: red">(</span><span>lookup</span><span style="color: red">)</span></code></pre>
<h2 id="raw-terms-and-types">
Raw terms and types
</h2>
<p>
Here’s an algebraic data type to represent raw terms of our DSL, something which might come directly out of a parser. The exact language we use here isn’t all that important; I’ve put in just enough features to make it nontrivial, but not much beyond that. We have integer literals, variables, lambdas, application, <code>let</code> and <code>if</code> expressions, addition, and comparison with <code>&gt;</code>. Of course, it would be easy to add more types, constants, and language features.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Term</span> <span style="color: blue;font-weight: bold">where</span>
  <span>Lit</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Var</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Lam</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>App</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Let</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>If</span>  <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Add</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span>Gt</span>  <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Term</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span></code></pre>
<p>
A few things to note:
</p>
<ul>
<li>
<p>
In order to keep things simple, notice that lambdas must be annotated with the type of the argument. There are other choices we could make, but this is the simplest for now. I’ll have more to say about other choices later.
</p>
</li>
<li>
<p>
I included <code>if</code> not only because it gives us something to do with Booleans, but also because it is <em>polymorphic</em>, which adds an interesting twist to our typechecking.
</p>
</li>
<li>
<p>
I included <code>&gt;</code>, not only because it gives us a way to produce Boolean values, but also because it uses <em>ad-hoc</em> polymorphism, that is, we can compare at any type which is an instance of <code>Ord</code>. This is an even more interesting twist.
</p>
</li>
</ul>
<p>
Here are our types: integers, booleans, and functions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Ty</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TyInt</span>  <span style="color: red">::</span> <span>Ty</span>
  <span>TyBool</span> <span style="color: red">::</span> <span>Ty</span>
  <span>TyFun</span>  <span style="color: red">::</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>Ty</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span></code></pre>
<p>
Finally, here’s an example term that uses all the features of our language (I’ve included a simple parser in an appendix at the end of this post):
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>example</span> <span style="color: red">::</span> <span>Term</span>
<span>example</span> <span style="color: red">=</span> <span>readTerm</span> <span>$</span> <span>T.unlines</span>
  <span style="color: red">[</span> <span style="color: teal">"let twice = \\f:Int -&gt; Int. \\x:Int. f (f x) in"</span>
  <span style="color: red">,</span> <span style="color: teal">"let z = 1 in"</span>
  <span style="color: red">,</span> <span style="color: teal">"if 7 &gt; twice (\\x:Int. x + 3) z then z else z + 1"</span>
  <span style="color: red">]</span></code></pre>
<p>
Since 7 is not, in fact, strictly greater than 1 + 3 + 3, this should evaluate to 2.
</p>
<h2 id="type-indexed-constants">
Type-indexed constants
</h2>
<p>
That was the end of our raw, untyped representations—from now on, everything is going to be type-indexed! First of all, we’ll declare an enumeration of constants, with each constant indexed by its corresponding host language type. These will include both any special language built-ins (like <code>if</code>, <code>+</code>, and <code>&gt;</code>) as well as a set of <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinators</a> which we’ll be using as a compilation target—more on these later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Const</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CInt</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>Int</span>
  <span>CIf</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>CAdd</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>Int</span> <span style="color: red">-&gt;</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Int</span><span style="color: red">)</span>
  <span>CGt</span> <span style="color: red">::</span> <span>Ord</span> <span>α</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Bool</span><span style="color: red">)</span>
  <span>I</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>K</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span>
  <span>S</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
  <span>B</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span>     <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
  <span>C</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span>       <span>b</span>  <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>Const</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
The polymorphism of <code>if</code> (and the combinators <code>I</code>, <code>K</code>, <em>etc.</em>, for that matter) poses no real problems. If we really wanted the type of <code>CIf</code> to be indexed by the exact type of <code>if</code>, it would be something like
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>CIf</span> <span style="color: red">::</span> <span>Const</span> <span style="color: red">(</span><span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
but this would require <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/impredicative_types.html">impredicative types</a> which can be something of a minefield. However, what we actually get is
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>CIf</span> <span style="color: red">::</span> <span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>Const</span> <span style="color: red">(</span><span>Bool</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
which is unproblematic and works just as well for our purposes.
</p>
<p>
The type of <code>CGt</code> is more interesting: it includes an <code>Ord α</code> constraint. That means that at the time we construct a <code>CGt</code> value, we must have in scope an <code>Ord</code> instance for whatever type <code>α</code> is; conversely, when we pattern-match on <code>CGt</code>, we will bring that instance into scope. We will see how to deal with this later.
</p>
<p>
For convenience, we make a type class <code>HasConst</code> for type-indexed things that can contain embedded constants (we will end up with several instances of this class).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">class</span> <span>HasConst</span> <span>t</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span></code></pre>
<p>
Also for convenience, here’s a type class for type-indexed things that support some kind of application operation. (Note that we don’t necessarily want to require <code>t</code> to support a <code>pure :: a -&gt; t a</code> operation, or even be a <code>Functor</code>, so using <code>Applicative</code> would not be appropriate, even though <code>$$</code> has the same type as <code>&lt;*&gt;</code>.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>&#36;&#36;</span>
<span style="color: blue;font-weight: bold">class</span> <span>Applicable</span> <span>t</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span>t</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span></code></pre>
<p>
Note that, unlike the standard <code>$</code> operator, <code>$$</code> is <em>left</em>-associative, so, for example, <code>f $$ x $$ y</code> should be read just like <code>f x y</code>, that is, <code>f $$ x $$ y = (f $$ x) $$ y</code>.
</p>
<p>
Finally, we’ll spend a bunch of time applying constants to things, or applying things to constants, so here are a few convenience operators for combining <code>$$</code> and <code>embed</code>:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>.&#36;&#36;</span>
<span style="color: red">(</span><span>.&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>c</span> <span>.&#36;&#36;</span> <span>t</span> <span style="color: red">=</span> <span>embed</span> <span>c</span> <span>&#36;&#36;</span> <span>t</span>

<span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>&#36;&#36;.</span>
<span style="color: red">(</span><span>&#36;&#36;.</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>t</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>t</span> <span>&#36;&#36;.</span> <span>c</span> <span style="color: red">=</span> <span>t</span> <span>&#36;&#36;</span> <span>embed</span> <span>c</span>

<span style="color: blue;font-weight: bold">infixl</span> <span class="hs-num">1</span> <span>.&#36;&#36;.</span>
<span style="color: red">(</span><span>.&#36;&#36;.</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>HasConst</span> <span>t</span><span style="color: red">,</span> <span>Applicable</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=&gt;</span> <span>Const</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>β</span>
<span>c1</span> <span>.&#36;&#36;.</span> <span>c2</span> <span style="color: red">=</span> <span>embed</span> <span>c1</span> <span>&#36;&#36;</span> <span>embed</span> <span>c2</span></code></pre>
<h2 id="type-indexed-types-and-terms">
Type-indexed types and terms
</h2>
<p>
Now let’s build up our type-indexed core language. First, we’ll need a data type for type-indexed de Bruijn indices. A value of type <code>Idx γ α</code> is a variable with type <code>α</code> in the context <code>γ</code> (represented as a type-level list of types). For example, <code>Idx [Int,Bool,Int] Int</code> would represent a variable of type <code>Int</code> (and hence must either be variable 0 or 2).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Idx</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>VZ</span> <span style="color: red">::</span> <span>Idx</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>
  <span>VS</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Idx</span> <span style="color: red">(</span><span>β</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span> <span>α</span><span style="color: red">)</span></code></pre>
<p>
Now we can build our type-indexed terms. Just like variables, terms are indexed by a typing context and a type; <code>t : TTerm γ α</code> can be read as “<code>t</code> is a term with type <code>α</code>, possibly containing variables whose types are described by the context <code>γ</code>”. Our core language has only variables, constants, lambdas, and application. Note we’re not just making a type-indexed version of our original term language; for simplicity, we’re going to simultaneously typecheck and elaborate down to this much simpler core language. (Of course, it would also be entirely possible to introduce another intermediate data type for type-indexed terms, and separate the typechecking and elaboration phases.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>TTerm</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TVar</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span>
  <span>TConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span>
  <span>TLam</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>
  <span>TApp</span> <span style="color: red">::</span> <span>TTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>β</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">=</span> <span>TApp</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>TConst</span></code></pre>
<p>
Now for some type-indexed types!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>TTy</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>TTyInt</span> <span style="color: red">::</span> <span>TTy</span> <span>Int</span>
  <span>TTyBool</span> <span style="color: red">::</span> <span>TTy</span> <span>Bool</span>
  <span style="color: red">(</span><span>:-&gt;:</span><span style="color: red">)</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>β</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>TTy</span> <span>ty</span><span style="color: red">)</span></code></pre>
<p>
<code>TTy</code> is a term-level representation of our DSL’s types, indexed by corresponding host language types. In other words, <code>TTy</code> is a <em>singleton</em>: for a given type <code>α</code> there is a single value of type <code>TTy α</code>. Put another way, pattern-matching on a value of type <code>TTy α</code> lets us learn what the type <code>α</code> is. (See <span class="citation">(Le, 2017)</span> for a <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">nice introduction to the idea of singleton types</a>.)
</p>
<p>
We will need to be able to test two value-level type representations for equality and have that reflected at the level of type indices; the <code>TestEquality</code> class from <code>Data.Type.Equality</code> is perfect for this. The <code>testEquality</code> function takes two type-indexed things and returns a type equality proof wrapped in <code>Maybe</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">instance</span> <span>TestEquality</span> <span>TTy</span> <span style="color: blue;font-weight: bold">where</span>
  <span>testEquality</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>β</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>α</span> <span>:~:</span> <span>β</span><span style="color: red">)</span>
  <span>testEquality</span> <span>TTyInt</span> <span>TTyInt</span> <span style="color: red">=</span> <span>Just</span> <span>Refl</span>
  <span>testEquality</span> <span>TTyBool</span> <span>TTyBool</span> <span style="color: red">=</span> <span>Just</span> <span>Refl</span>
  <span>testEquality</span> <span style="color: red">(</span><span>α₁</span> <span>:-&gt;:</span> <span>β₁</span><span style="color: red">)</span> <span style="color: red">(</span><span>α₂</span> <span>:-&gt;:</span> <span>β₂</span><span style="color: red">)</span> <span style="color: red">=</span>
    <span style="color: blue;font-weight: bold">case</span> <span style="color: red">(</span><span>testEquality</span> <span>α₁</span> <span>α₂</span><span style="color: red">,</span> <span>testEquality</span> <span>β₁</span> <span>β₂</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
      <span style="color: red">(</span><span>Just</span> <span>Refl</span><span style="color: red">,</span> <span>Just</span> <span>Refl</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Just</span> <span>Refl</span>
      <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
  <span>testEquality</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>Nothing</span></code></pre>
<p>
Recall that the <code>CGt</code> constant requires an <code>Ord</code> instance; the <code>checkOrd</code> function pattern-matches on a <code>TTy</code> and witnesses the fact that the corresponding host-language type has an <code>Ord</code> instance (if, in fact, it does).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>checkOrd</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>Ord</span> <span>α</span> <span style="color: red">=&gt;</span> <span>r</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>r</span>
<span>checkOrd</span> <span>TTyInt</span> <span>r</span> <span style="color: red">=</span> <span>Just</span> <span>r</span>
<span>checkOrd</span> <span>TTyBool</span> <span>r</span> <span style="color: red">=</span> <span>Just</span> <span>r</span>
<span>checkOrd</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>Nothing</span></code></pre>
<p>
As a quick aside, for simplicity’s sake, I am going to use <code>Maybe</code> throughout the rest of this post to indicate possible failure. In a real implementation, one would of course want to return more information about any error(s) that occur.
</p>
<h2 id="existential-wrappers">
Existential wrappers
</h2>
<p>
Sometimes we will need to wrap type-indexed things inside an existential wrapper to hide the type index. For example, when converting from a <code>Ty</code> to a <code>TTy</code>, or when running type inference, we can’t know in advance which type we’re going to get. So we create the <code>Some</code> data type which wraps up a type-indexed thing along with a corresponding <code>TTy</code>. Pattern-matching on the singleton <code>TTy</code> will allow us to recover the type information later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Some</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>Some</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>t</span>

<span>mapSome</span> <span style="color: red">::</span> <span style="color: red">(</span><span class="hs-sel">∀</span> <span>α</span><span>.</span> <span>s</span> <span>α</span> <span style="color: red">-&gt;</span> <span>t</span> <span>α</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>s</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>t</span>
<span>mapSome</span> <span>f</span> <span style="color: red">(</span><span>Some</span> <span>α</span> <span>t</span><span style="color: red">)</span> <span style="color: red">=</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>f</span> <span>t</span><span style="color: red">)</span></code></pre>
<p>
The first instantiation we’ll create is an existentially wrapped type, where the <code>TTy</code> itself is the only thing we care about, and the corresponding <code>t</code> will just be the constant unit type functor. It would be annoying to keep writing <code>F.Const ()</code> everywhere so we create some type and pattern synonyms for convenience.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>SomeTy</span> <span style="color: red">=</span> <span>Some</span> <span style="color: red">(</span><span>F.Const</span> <span>()</span><span style="color: red">)</span>

<span>pattern</span> <span>SomeTy</span> <span style="color: red">::</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>SomeTy</span>
<span>pattern</span> <span>SomeTy</span> <span>α</span> <span style="color: red">=</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>F.Const</span> <span>()</span><span style="color: red">)</span>
<span style="color: green">{-# COMPLETE SomeTy #-}</span></code></pre>
<p>
The <code>someType</code> function converts from a raw <code>Ty</code> to a type-indexed <code>TTy</code>, wrapped up in an existential wrapper.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>someType</span> <span style="color: red">::</span> <span>Ty</span> <span style="color: red">-&gt;</span> <span>SomeTy</span>
<span>someType</span> <span>TyInt</span> <span style="color: red">=</span> <span>SomeTy</span> <span>TTyInt</span>
<span>someType</span> <span>TyBool</span> <span style="color: red">=</span> <span>SomeTy</span> <span>TTyBool</span>
<span>someType</span> <span style="color: red">(</span><span>TyFun</span> <span>a</span> <span>b</span><span style="color: red">)</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span style="color: red">(</span><span>someType</span> <span>a</span><span style="color: red">,</span> <span>someType</span> <span>b</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
  <span style="color: red">(</span><span>SomeTy</span> <span>α</span><span style="color: red">,</span> <span>SomeTy</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>SomeTy</span> <span style="color: red">(</span><span>α</span> <span>:-&gt;:</span> <span>β</span><span style="color: red">)</span></code></pre>
<h2 id="type-inference-and-elaboration">
Type inference and elaboration
</h2>
<p>
Now that we have our type-indexed core language all set, it’s time to do type inference, that is, translate from untyped terms to type-indexed ones! First, let’s define type contexts, <em>i.e.</em> mappings from variables to their types. We store contexts simply as a (fancy, type-indexed) list of variable names paired with their types. This is inefficient—it takes linear time to do a lookup—but we don’t care, because this is an intermediate representation used only during typechecking. By the time we actually get around to running terms, variables won’t even exist any more.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Ctx</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>

  <span style="color: green">-- CNil represents an empty context.</span>
  <span>CNil</span> <span style="color: red">::</span> <span>Ctx</span> <span style="color: teal">'</span><span>[]</span>

  <span style="color: green">-- A cons stores a variable name and its type,</span>
  <span style="color: green">-- and then the rest of the context.</span>
  <span style="color: red">(</span><span>:::</span><span style="color: red">)</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Text</span><span style="color: red">,</span> <span>TTy</span> <span>α</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span></code></pre>
<p>
Now we can define the <code>lookup</code> function, which takes a variable name and a context and tries to return a corresponding de Bruijn index into the context. When looking up a variable name in the context, we can’t know in advance what index we will get and what type it will have, so we wrap the returned <code>Idx</code> in <code>Some</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>lookup</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Some</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span><span style="color: red">)</span><span style="color: red">)</span>
<span>lookup</span> <span style="color: blue;font-weight: bold">_</span> <span>CNil</span> <span style="color: red">=</span> <span>Nothing</span>
<span>lookup</span> <span>x</span> <span style="color: red">(</span><span style="color: red">(</span><span>y</span><span style="color: red">,</span> <span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span>
  <span style="color: red">|</span> <span>x</span> <span>==</span> <span>y</span> <span style="color: red">=</span> <span>Just</span> <span style="color: red">(</span><span>Some</span> <span>α</span> <span>VZ</span><span style="color: red">)</span>
  <span style="color: red">|</span> <span>otherwise</span> <span style="color: red">=</span> <span>mapSome</span> <span>VS</span> <span>&lt;$&gt;</span> <span>lookup</span> <span>x</span> <span>ctx</span></code></pre>
<p>
Now we’re finally ready to define the <code>infer</code> function! It takes a type context and a raw term, and tries to compute a corresponding type-indexed term. Note that there’s no particular guarantee that the term we return corresponds to the input term—we will just have to be careful—but at least the Haskell type system guarantees that we can’t return a type-incorrect term, which is especially important when we have some nontrivial elaboration to do. Of course, just as with variable lookups, when inferring the type of a term we can’t know in advance what type it will have, so we will need to return an existential wrapper around a type-indexed term.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>infer</span> <span style="color: red">::</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Some</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span><span style="color: red">)</span><span style="color: red">)</span>
<span>infer</span> <span>ctx</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span></code></pre>
<p>
To infer the type of a literal integer value, just return <code>TTyInt</code> with a literal integer constant.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Lit</span> <span>i</span> <span style="color: red">-&gt;</span> <span>return</span> <span>$</span> <span>Some</span> <span>TTyInt</span> <span style="color: red">(</span><span>embed</span> <span style="color: red">(</span><span>CInt</span> <span>i</span><span style="color: red">)</span><span style="color: red">)</span></code></pre>
<p>
To infer the type of a variable, look it up in the context and wrap the result in <code>TVar</code>. Notice how we are allowed to pattern-match on the <code>Some</code> returned from <code>lookup</code> (revealing the existentially quantified type inside) since we immediately wrap it back up in another <code>Some</code> when returning the <code>TVar</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Var</span> <span>x</span> <span style="color: red">-&gt;</span> <span>mapSome</span> <span>TVar</span> <span>&lt;$&gt;</span> <span>lookup</span> <span>x</span> <span>ctx</span></code></pre>
<p>
To infer the type of a lambda, we convert the argument type annotation to a type-indexed type, infer the type of the body under an extended context, and then return a lambda with an appropriate function type. (If lambdas weren’t required to have type annotations, then we would either have to move the lambda case to the <code>check</code> function, or else use unification variables and solve type equality constraints. The former would be straightforward, but I don’t know how to do the latter in a type-indexed way—sounds like a fun problem for later.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Lam</span> <span>x</span> <span>a</span> <span>t</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span style="color: blue;font-weight: bold">case</span> <span>someType</span> <span>a</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Some</span> <span>α</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
        <span>Some</span> <span>β</span> <span>t'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span style="color: red">(</span><span style="color: red">(</span><span>x</span><span style="color: red">,</span><span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span> <span>t</span>
        <span>return</span> <span>$</span> <span>Some</span> <span style="color: red">(</span><span>α</span> <span>:-&gt;:</span> <span>β</span><span style="color: red">)</span> <span style="color: red">(</span><span>TLam</span> <span>t'</span><span style="color: red">)</span></code></pre>
<p>
To infer the type of an application, we infer the type of the left-hand side, ensure it is a function type, and <code>check</code> that the right-hand side has the correct type. We will see the <code>check</code> function later.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>App</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>τ</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span style="color: blue;font-weight: bold">case</span> <span>τ</span> <span style="color: blue;font-weight: bold">of</span>
      <span>α</span> <span>:-&gt;:</span> <span>β</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
        <span>t2'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>α</span> <span>t2</span>
        <span>return</span> <span>$</span> <span>Some</span> <span>β</span> <span style="color: red">(</span><span>TApp</span> <span>t1'</span> <span>t2'</span><span style="color: red">)</span>
      <span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>Nothing</span></code></pre>
<p>
To infer the type of a <code>let</code>-expression, we infer the type of the definition, infer the type of the body under an extended context, and then desugar it into an application of a lambda. That is, <code>let x = t1 in t2</code> desugars to <code>(\x.t2) t1</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Let</span> <span>x</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>α</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span>Some</span> <span>β</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span style="color: red">(</span><span style="color: red">(</span><span>x</span><span style="color: red">,</span> <span>α</span><span style="color: red">)</span> <span>:::</span> <span>ctx</span><span style="color: red">)</span> <span>t2</span>
    <span>return</span> <span>$</span> <span>Some</span> <span>β</span> <span style="color: red">(</span><span>TApp</span> <span style="color: red">(</span><span>TLam</span> <span>t2'</span><span style="color: red">)</span> <span>t1'</span><span style="color: red">)</span></code></pre>
<p>
Note again that we can’t accidentally get mixed up here—for example, if we incorrectly desugar to <code>(\x.t1) t2</code> we get a Haskell type error, like this:
</p>
<pre><code>    • Couldn't match type ‘γ’ with ‘α : γ’
      Expected: TTerm γ α1
        Actual: TTerm (α : γ) α1</code></pre>
<p>
To infer an <code>if</code>-expression, we can check that the test has type <code>Bool</code>, infer the types of the two branches, and ensure that they are the same. If so, we return the <code>CIf</code> constant applied to the three arguments. The reason this typechecks is that pattern-matching on the <code>Refl</code> from the <code>testEquality</code> call brings into scope the fact that the types of <code>t2</code> and <code>t3</code> are equal, so we can apply <code>CIf</code> which requires them to be so.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>If</span> <span>t1</span> <span>t2</span> <span>t3</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>t1'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyBool</span> <span>t1</span>
    <span>Some</span> <span>α</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t2</span>
    <span>Some</span> <span>β</span> <span>t3'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t3</span>
    <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
      <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span>return</span> <span>$</span> <span>Some</span> <span>α</span> <span style="color: red">(</span><span>CIf</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span> <span>&#36;&#36;</span> <span>t3'</span><span style="color: red">)</span></code></pre>
<p>
Addition is simple; we just check that both arguments have type <code>Int</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Add</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>t1'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyInt</span> <span>t1</span>
    <span>t2'</span> <span style="color: red">&lt;-</span> <span>check</span> <span>ctx</span> <span>TTyInt</span> <span>t2</span>
    <span>return</span> <span>$</span> <span>Some</span> <span>TTyInt</span> <span style="color: red">(</span><span>CAdd</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span><span style="color: red">)</span></code></pre>
<p>
“Greater than” is a bit interesting because we allow it to be used at both <code>Int</code> and <code>Bool</code>. So, just as with <code>if</code>, we must infer the types of the arguments and check that they match. But then we must also use the <code>checkOrd</code> function to ensure that the argument types are an instance of <code>Ord</code>. In particular, we wrap <code>CGt</code> (which requires an <code>Ord</code> constraint) in a call to <code>checkOrd α</code> (which provides one).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span>Gt</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">do</span>
    <span>Some</span> <span>α</span> <span>t1'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t1</span>
    <span>Some</span> <span>β</span> <span>t2'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t2</span>
    <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
      <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
      <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span style="color: red">\</span><span>c</span> <span style="color: red">-&gt;</span> <span>Some</span> <span>TTyBool</span> <span style="color: red">(</span><span>c</span> <span>.&#36;&#36;</span> <span>t1'</span> <span>&#36;&#36;</span> <span>t2'</span><span style="color: red">)</span><span style="color: red">)</span> <span>&lt;$&gt;</span> <span>checkOrd</span> <span>α</span> <span>CGt</span></code></pre>
<p>
Finally, here’s the <code>check</code> function: to check that an expression has an expected type, just infer its type and make sure it’s the one we expected. (With more interesting languages we might also have more cases here for terms which can be checked but not inferred.) Notice how this also allows us to return the type-indexed term without using an existential wrapper, since the expected type is an input.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>check</span> <span style="color: red">::</span> <span>Ctx</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>TTy</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span>
<span>check</span> <span>ctx</span> <span>α</span> <span>t</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">do</span>
  <span>Some</span> <span>β</span> <span>t'</span> <span style="color: red">&lt;-</span> <span>infer</span> <span>ctx</span> <span>t</span>
  <span style="color: blue;font-weight: bold">case</span> <span>testEquality</span> <span>α</span> <span>β</span> <span style="color: blue;font-weight: bold">of</span>
    <span>Nothing</span> <span style="color: red">-&gt;</span> <span>Nothing</span>
    <span>Just</span> <span>Refl</span> <span style="color: red">-&gt;</span> <span>Just</span> <span>t'</span></code></pre>
<p>
Putting this all together so far, we can check that the <code>example</code> term has type <code>Int</code> and see what it elaborates to (I’ve included a simple pretty-printer for <code>TTerm</code> in an appendix):
</p>
<pre><code>λ&gt; putStrLn . pretty . fromJust . check CNil TTyInt $ example
(λ. (λ. if (gt 7 (x1 (λ. plus x0 3) x0)) x0 (plus x0 1)) 1) (λ. λ. x1 (x1 x0))</code></pre>
<h2 id="an-aside-a-typed-interpreter">
An aside: a typed interpreter
</h2>
<p>
We can now easily write an interpreter. However, this is pretty inefficient (it has to carry around an environment and do linear-time variable lookups), and later we’re going to compile our terms directly to host language terms. So this interpreter is just a nice aside, for fun and testing.
</p>
<p>
With that said, given a closed term, we can interpret it directly to a value of its corresponding host language type. We need typed environments and a indexing function (note that for some reason GHC can’t see that the last case of the indexing function is impossible; if we tried implementing it in, say, Agda, we wouldn’t have to write that case).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>Env</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>ENil</span> <span style="color: red">::</span> <span>Env</span> <span style="color: teal">'</span><span>[]</span>
  <span>ECons</span> <span style="color: red">::</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Env</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span>

<span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span style="color: red">::</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span style="color: red">(</span><span>ECons</span> <span>x</span> <span style="color: blue;font-weight: bold">_</span><span style="color: red">)</span> <span>!</span> <span>VZ</span> <span style="color: red">=</span> <span>x</span>
<span style="color: red">(</span><span>ECons</span> <span style="color: blue;font-weight: bold">_</span> <span>e</span><span style="color: red">)</span> <span>!</span> <span style="color: red">(</span><span>VS</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span>e</span> <span>!</span> <span>x</span>
<span>ENil</span> <span>!</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>error</span> <span style="color: teal">"GHC can't tell this is impossible"</span></code></pre>
<p>
Now the interpreter is straightforward. Look how beautifully everything works out with the type indexing.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>interpTTerm</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: teal">'</span><span>[]</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>interpTTerm</span> <span style="color: red">=</span> <span>go</span> <span>ENil</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>go</span> <span style="color: red">::</span> <span>Env</span> <span>γ</span> <span style="color: red">-&gt;</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
    <span>go</span> <span>e</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
      <span>TVar</span> <span>x</span> <span style="color: red">-&gt;</span> <span>e</span> <span>!</span> <span>x</span>
      <span>TLam</span> <span>body</span> <span style="color: red">-&gt;</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>go</span> <span style="color: red">(</span><span>ECons</span> <span>x</span> <span>e</span><span style="color: red">)</span> <span>body</span>
      <span>TApp</span> <span>f</span> <span>x</span> <span style="color: red">-&gt;</span> <span>go</span> <span>e</span> <span>f</span> <span style="color: red">(</span><span>go</span> <span>e</span> <span>x</span><span style="color: red">)</span>
      <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>interpConst</span> <span>c</span>

<span>interpConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>interpConst</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span>CInt</span> <span>i</span> <span style="color: red">-&gt;</span> <span>i</span>
  <span>CIf</span> <span style="color: red">-&gt;</span> <span style="color: red">\</span><span>b</span> <span>t</span> <span>e</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">if</span> <span>b</span> <span style="color: blue;font-weight: bold">then</span> <span>t</span> <span style="color: blue;font-weight: bold">else</span> <span>e</span>
  <span>CAdd</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>+</span><span style="color: red">)</span>
  <span>CGt</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>&gt;</span><span style="color: red">)</span>
  <span>K</span> <span style="color: red">-&gt;</span> <span>const</span>
  <span>S</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>&lt;*&gt;</span><span style="color: red">)</span>
  <span>I</span> <span style="color: red">-&gt;</span> <span>id</span>
  <span>B</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>.</span><span style="color: red">)</span>
  <span>C</span> <span style="color: red">-&gt;</span> <span>flip</span></code></pre>
<pre><code>λ&gt; interpTTerm . fromJust . check CNil TTyInt $ example
2</code></pre>
<h2 id="compiling-to-combinators-type-indexed-bracket-abstraction">
Compiling to combinators: type-indexed bracket abstraction
</h2>
<p>
Now, on with the main attraction! It’s well-known that certain sets of <a href="https://en.wikipedia.org/wiki/Combinatory_logic">combinators</a> are Turing-complete: for example, <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">SKI is the most well-known complete set</a> (or just SK if you’re trying to be minimal). There are well-known algorithms for compiling lambda calculus terms into combinators, known generally as <em>bracket abstraction</em> (for further reading about bracket abstraction in general, see <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">Diller</a> <span class="citation">(2014)</span>; for some in-depth history along with illustrative Haskell code, see <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">Ben Lynn’s page on Combinatory Logic</a> <span class="citation">(2022)</span>; for nice example implementations in Haskell, see blog posts by <a href="gratzer2015bracket">Gratzer</a> <span class="citation">(2015)</span>, <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Seo</a> <span class="citation">(2016)</span>, and <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">Mahler</a> <span class="citation">(2021)</span>.)
</p>
<p>
So the idea is to compile our typed core language down to combinators. The resulting terms will have <em>no</em> lambdas or variables—only constants and application! The point is that by making environments implicit, with a few more tricks we can make use of the host language runtime’s ability to do beta reduction, which will be <em>much</em> more efficient than our interpreter.
</p>
<p>
The <code>BTerm</code> type below will be the compilation target. Again for illustration and/or debugging we can easily write a direct interpreter for <code>BTerm</code>—but this still isn’t the intended code path. There will still be one more step to convert <code>BTerm</code>s directly into host language terms.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>BTerm</span> <span style="color: red">::</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>
  <span>BApp</span> <span style="color: red">::</span> <span>BTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>β</span>
  <span>BConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span>

<span style="color: blue;font-weight: bold">deriving</span> <span style="color: blue;font-weight: bold">instance</span> <span>Show</span> <span style="color: red">(</span><span>BTerm</span> <span>ty</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span>BTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">=</span> <span>BApp</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span>BTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>BConst</span>

<span>interpBTerm</span> <span style="color: red">::</span> <span>BTerm</span> <span>ty</span> <span style="color: red">-&gt;</span> <span>ty</span>
<span>interpBTerm</span> <span style="color: red">(</span><span>BApp</span> <span>f</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span>interpBTerm</span> <span>f</span> <span style="color: red">(</span><span>interpBTerm</span> <span>x</span><span style="color: red">)</span>
<span>interpBTerm</span> <span style="color: red">(</span><span>BConst</span> <span>c</span><span style="color: red">)</span> <span style="color: red">=</span> <span>interpConst</span> <span>c</span></code></pre>
<p>
We will use the usual SKI combinators as well as <code>B</code> and <code>C</code>, which are like special-case variants of <code>S</code>:
</p>
<ul>
<li>
<code>S x y z = x z (y z)</code>
</li>
<li>
<code>B x y z = x (y z)</code>
</li>
<li>
<code>C x y z = x z (y )</code>
</li>
</ul>
<p>
<code>S</code> handles the application of <code>x</code> to <code>y</code> in the case where they both need access to a shared parameter <code>z</code>; <code>B</code> and <code>C</code> are similar, but <code>B</code> is used when only <code>y</code>, and not <code>x</code>, needs access to <code>z</code>, and <code>C</code> is for when only <code>x</code> needs access to <code>z</code>. Using <code>B</code> and <code>C</code> will allow for more efficient encodings than would be possible with <code>S</code> alone. If you want to compile a language with recursion you can also easily add the usual <code>Y</code> combinator (“<code>SICKBY</code>”), although the example language in this post has no recursion so we won’t use it.
</p>
<p>
Bracket abstraction is often presented in an untyped way, but I found this <a href="http://okmij.org/ftp/tagless-final/ski.pdf">really cool paper by Oleg Kiselyov</a> <span class="citation">(2018)</span> where he shows how to do bracket abstraction in a completely compositional, type-indexed way. I found the paper a bit hard to understand, but fortunately it came with <a href="http://okmij.org/ftp/tagless-final/skconv.ml">working OCaml code</a>! Translating it to Haskell was straightforward. Much later, after writing most of this blog post, I found a <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">a nice explanation of Kiselyov’s paper</a> by <span class="citation">Lynn (2022)</span> which helped me make more sense of the paper.
</p>
<p>
First, a data type for open terms, which represent an intermediate stage in the bracket abstraction algorithm, where some parts have been converted to closed combinator terms (the <code>E</code> constructor embeds <code>BTerm</code> values), and some parts still have not. This corresponds to Kiselyov’s eta-optimized version (section 4.1 of the paper). A simplified version that does not include <code>V</code> is possible, but results in longer combinator expressions.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>OTerm</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Type</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: red">-&gt;</span> <span>Type</span> <span style="color: blue;font-weight: bold">where</span>

  <span style="color: green">-- E contains embedded closed (i.e. already abstracted) terms.</span>
  <span>E</span> <span style="color: red">::</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span>

  <span style="color: green">-- V represents a reference to the innermost/top environment</span>
  <span style="color: green">-- variable, i.e. Z</span>
  <span>V</span> <span style="color: red">::</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>α</span>

  <span style="color: green">-- N represents internalizing the innermost bound variable as a</span>
  <span style="color: green">-- function argument. In other words, we can represent an open</span>
  <span style="color: green">-- term referring to a certain variable as a function which</span>
  <span style="color: green">-- takes that variable as an argument.</span>
  <span>N</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span>

  <span style="color: green">-- For efficiency, there is also a special variant of N for the</span>
  <span style="color: green">-- case where the term does not refer to the topmost variable at</span>
  <span style="color: green">-- all.</span>
  <span>W</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span>β</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: teal">'</span><span>:</span> <span>γ</span><span style="color: red">)</span> <span>β</span>

<span style="color: blue;font-weight: bold">instance</span> <span>HasConst</span> <span style="color: red">(</span><span>OTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>embed</span> <span style="color: red">=</span> <span>E</span> <span>.</span> <span>embed</span></code></pre>
<p>
Now for the bracket abstraction algorithm. First, a function to do type- and environment-preserving conversion from <code>TTerm</code> to <code>OTerm</code>. The <code>conv</code> function handles the variable, lambda, and constant cases. The application case is handled by the <code>Applicable</code> instance.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>conv</span> <span style="color: red">::</span> <span>TTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span>
<span>conv</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span>TVar</span> <span>VZ</span> <span style="color: red">-&gt;</span> <span>V</span>
  <span>TVar</span> <span style="color: red">(</span><span>VS</span> <span>x</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>W</span> <span style="color: red">(</span><span>conv</span> <span style="color: red">(</span><span>TVar</span> <span>x</span><span style="color: red">)</span><span style="color: red">)</span>
  <span>TLam</span> <span>t</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">case</span> <span>conv</span> <span>t</span> <span style="color: blue;font-weight: bold">of</span>
    <span>V</span> <span style="color: red">-&gt;</span> <span>E</span> <span style="color: red">(</span><span>embed</span> <span>I</span><span style="color: red">)</span>
    <span>E</span> <span>d</span> <span style="color: red">-&gt;</span> <span>E</span> <span style="color: red">(</span><span>K</span> <span>.&#36;&#36;</span> <span>d</span><span style="color: red">)</span>
    <span>N</span> <span>e</span> <span style="color: red">-&gt;</span> <span>e</span>
    <span>W</span> <span>e</span> <span style="color: red">-&gt;</span> <span>K</span> <span>.&#36;&#36;</span> <span>e</span>
  <span>TApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>conv</span> <span>t1</span> <span>&#36;&#36;</span> <span>conv</span> <span>t2</span>
  <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>embed</span> <span>c</span></code></pre>
<p>
The <code>Applicable</code> instance for <code>OTerm</code> has 15 cases—one for each combination of <code>OTerm</code> constructors. Why not 16, you ask? Because the <code>V $$ V</code> case is impossible (exercise for the reader: why?). The cool thing is that GHC can tell that case would be ill-typed, and agrees that this definition is total—that is, it does not give a non-exhaustive pattern match warning. This is a lot of code, but understanding each individual case is not too hard if you understand the meaning of the constructors <code>E</code>, <code>V</code>, <code>N</code>, and <code>W</code>. For example, if we have one term that ignores the innermost bound variable being applied to another term that also ignores the innermost bound variable (<code>W e1 $$ W e2</code>), we can apply one term to the other and wrap the result in <code>W</code> again (<code>W (e1 $$ e2)</code>). Other cases use the combinators <code>B</code>, <code>C</code>, <code>S</code> to route the input to the proper places in an application.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span style="color: red">(</span><span>OTerm</span> <span>γ</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span style="color: red">(</span><span>&#36;&#36;</span><span style="color: red">)</span> <span style="color: red">::</span> <span>OTerm</span> <span>γ</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>OTerm</span> <span>γ</span> <span>β</span>
  <span>W</span> <span>e1</span> <span>&#36;&#36;</span> <span>W</span> <span>e2</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>W</span> <span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>W</span> <span>e</span> <span style="color: red">=</span> <span>W</span> <span style="color: red">(</span><span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>W</span> <span>e</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span>e</span>
  <span>V</span> <span>&#36;&#36;</span> <span>W</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>I</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>W</span> <span>e1</span> <span>&#36;&#36;</span> <span>N</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>B</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e1</span> <span>&#36;&#36;</span> <span>W</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e1</span> <span>&#36;&#36;</span> <span>N</span> <span>e2</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;</span> <span>e1</span> <span>&#36;&#36;</span> <span>e2</span><span style="color: red">)</span>
  <span>N</span> <span>e</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;</span> <span>e</span> <span>&#36;&#36;.</span> <span>I</span><span style="color: red">)</span>
  <span>V</span> <span>&#36;&#36;</span> <span>N</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>S</span> <span>.&#36;&#36;.</span> <span>I</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>N</span> <span>e</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>B</span> <span>.&#36;&#36;</span> <span>d</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d</span> <span>&#36;&#36;</span> <span>V</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span>d</span><span style="color: red">)</span>
  <span>V</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>I</span> <span>&#36;&#36;</span> <span>d</span><span style="color: red">)</span><span style="color: red">)</span>
  <span>N</span> <span>e</span> <span>&#36;&#36;</span> <span>E</span> <span>d</span> <span style="color: red">=</span> <span>N</span> <span style="color: red">(</span><span>E</span> <span style="color: red">(</span><span>C</span> <span>.&#36;&#36;.</span> <span>C</span> <span>&#36;&#36;</span> <span>d</span><span style="color: red">)</span> <span>&#36;&#36;</span> <span>e</span><span style="color: red">)</span>
  <span>E</span> <span>d1</span> <span>&#36;&#36;</span> <span>E</span> <span>d2</span> <span style="color: red">=</span> <span>E</span> <span style="color: red">(</span><span>d1</span> <span>&#36;&#36;</span> <span>d2</span><span style="color: red">)</span></code></pre>
<p>
The final bracket abstraction algorithm consists of calling <code>conv</code> on a closed <code>TTerm</code>—this must result in a term of type <code>OTerm ’[] α</code>, and the only constructor which could possibly produce such a type is <code>E</code>, containing an embedded <code>BTerm</code>. So we can just extract that <code>BTerm</code>, and GHC can see that this is total.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>bracket</span> <span style="color: red">::</span> <span>TTerm</span> <span style="color: teal">'</span><span>[]</span> <span>α</span> <span style="color: red">-&gt;</span> <span>BTerm</span> <span>α</span>
<span>bracket</span> <span>t</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span>conv</span> <span>t</span> <span style="color: blue;font-weight: bold">of</span> <span style="color: red">{</span> <span>E</span> <span>t'</span> <span style="color: red">-&gt;</span> <span>t'</span> <span style="color: red">}</span></code></pre>
<p>
Let’s apply this to our <code>example</code> term and see what we get:
</p>
<pre><code>λ&gt; putStrLn . pretty . bracket . fromJust . check CNil TTyInt $ example
C C 1 (C C (C C 1 plus) (B S (C C I (B S (B (B if) (B (B (gt 7)) (C I (C C 3 plus)))))))) (S B I)
λ&gt; interpBTerm . bracket . fromJust . check CNil TTyInt $ example
2</code></pre>
<p>
Neat! This is not too much longer than the original term, which is the point of using the optimized version. Interestingly, this example happens to not use <code>K</code> at all, but a more complex term certainly would.
</p>
<p>
Kiselyov also presents an even better algorithm using <span class="math inline">\(n\)</span>-ary combinators which uses guaranteed linear time and space. For simplicity, he presents it in an untyped way and claims in passing that it “can be backported to the typed case”, though I am not aware of anyone who has actually done this yet (perhaps I will, later). <span class="citation">Lynn (2022)</span> has <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">a nice explanation of Kiselyov’s paper</a>, including a section that explores several alternatives to Kiselyov’s linear-time algorithm.
</p>
<h2 id="compiling-type-indexed-combinators-to-haskell">
Compiling type-indexed combinators to Haskell
</h2>
<p>
So at this point we can take a <code>Term</code>, typecheck it to produce a <code>TTerm</code>, then use bracket abstraction to convert that to a <code>BTerm</code>. We have an interpreter for <code>BTerm</code>s, but we’re instead going to do one more compilation step, to turn <code>BTerm</code>s directly into native Haskell values. This idea originates with <span class="citation">Naylor (2008)</span> and is well-explained in blog posts by <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Seo</a> <span class="citation">(2016)</span> and <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">Mahler</a> <span class="citation">(2022)</span>. This still feels a little like black magic to me, and I am actually unclear on whether it is really faster than calling <code>interpBTerm</code>; some benchmarking would be needed. In any case I include it here for completeness.
</p>
<p>
Our target for this final compilation step is the following <code>CTerm</code> type, which has only functions, represented by <code>CFun</code>, and constants. Note, however, that <code>CConst</code> is intended to be used only for non-function types, <em>i.e.</em> base types, although there’s no nice way (that I know of, at least) to use the Haskell type system to enforce this.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>CTerm</span> <span>α</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CFun</span> <span style="color: red">::</span> <span style="color: red">(</span><span>CTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>β</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>β</span><span style="color: red">)</span>
  <span>CConst</span> <span style="color: red">::</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span> <span style="color: green">-- CConst invariant: α is not a function type</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Applicable</span> <span>CTerm</span> <span style="color: blue;font-weight: bold">where</span>
  <span>CFun</span> <span>f</span> <span>&#36;&#36;</span> <span>x</span> <span style="color: red">=</span> <span>f</span> <span>x</span>
  <span>CConst</span> <span style="color: blue;font-weight: bold">_</span> <span>&#36;&#36;</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>error</span> <span style="color: teal">"CConst should never contain a function!"</span>

<span>compile</span> <span style="color: red">::</span> <span>BTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span>
<span>compile</span> <span style="color: red">(</span><span>BApp</span> <span>b1</span> <span>b2</span><span style="color: red">)</span> <span style="color: red">=</span> <span>compile</span> <span>b1</span> <span>&#36;&#36;</span> <span>compile</span> <span>b2</span>
<span>compile</span> <span style="color: red">(</span><span>BConst</span> <span>c</span><span style="color: red">)</span> <span style="color: red">=</span> <span>compileConst</span> <span>c</span>

<span>compileConst</span> <span style="color: red">::</span> <span>Const</span> <span>α</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span>α</span>
<span>compileConst</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span style="color: red">(</span><span>CInt</span> <span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CConst</span> <span>i</span>
  <span>CIf</span>      <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>b</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>t</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>e</span> <span style="color: red">-&gt;</span> <span style="color: blue;font-weight: bold">if</span> <span>b</span> <span style="color: blue;font-weight: bold">then</span> <span>t</span> <span style="color: blue;font-weight: bold">else</span> <span>e</span>
  <span>CAdd</span>     <span style="color: red">-&gt;</span> <span>binary</span> <span style="color: red">(</span><span>+</span><span style="color: red">)</span>
  <span>CGt</span>      <span style="color: red">-&gt;</span> <span>binary</span> <span style="color: red">(</span><span>&gt;</span><span style="color: red">)</span>
  <span>K</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">_</span> <span style="color: red">-&gt;</span> <span>x</span>
  <span>S</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>g</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span>x</span> <span>&#36;&#36;</span> <span style="color: red">(</span><span>g</span> <span>&#36;&#36;</span> <span>x</span><span style="color: red">)</span>
  <span>I</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>id</span>
  <span>B</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>g</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span style="color: red">(</span><span>g</span> <span>&#36;&#36;</span> <span>x</span><span style="color: red">)</span>
  <span>C</span>        <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>f</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>x</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span>y</span> <span style="color: red">-&gt;</span> <span>f</span> <span>&#36;&#36;</span> <span>y</span> <span>&#36;&#36;</span> <span>x</span>

<span>binary</span> <span style="color: red">::</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CTerm</span> <span style="color: red">(</span><span>α</span> <span style="color: red">-&gt;</span> <span>b</span> <span style="color: red">-&gt;</span> <span>c</span><span style="color: red">)</span>
<span>binary</span> <span>op</span> <span style="color: red">=</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>x</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CFun</span> <span>$</span> <span style="color: red">\</span><span style="color: red">(</span><span>CConst</span> <span>y</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>CConst</span> <span style="color: red">(</span><span>op</span> <span>x</span> <span>y</span><span style="color: red">)</span></code></pre>
<p>
Finally, we can “run” a <code>CTerm α</code> to extract a value of type <code>α</code>. Typically, if <code>α</code> is some kind of base type like <code>Int</code>, <code>runCTerm</code> doesn’t actually do any work—all the work is done by the Haskell runtime itself. However, for completeness, I include a case for <code>CFun</code> as well.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>runCTerm</span> <span style="color: red">::</span> <span>CTerm</span> <span>α</span> <span style="color: red">-&gt;</span> <span>α</span>
<span>runCTerm</span> <span style="color: red">(</span><span>CConst</span> <span>a</span><span style="color: red">)</span> <span style="color: red">=</span> <span>a</span>
<span>runCTerm</span> <span style="color: red">(</span><span>CFun</span> <span>f</span><span style="color: red">)</span> <span style="color: red">=</span> <span>runCTerm</span> <span>.</span> <span>f</span> <span>.</span> <span>CConst</span></code></pre>
<p>
We can put this all together into our final pipeline:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>evalInt</span> <span style="color: red">::</span> <span>Term</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>Int</span>
<span>evalInt</span> <span style="color: red">=</span> <span>fmap</span> <span style="color: red">(</span><span>runCTerm</span> <span>.</span> <span>compile</span> <span>.</span> <span>bracket</span><span style="color: red">)</span> <span>.</span> <span>check</span> <span>CNil</span> <span>TTyInt</span></code></pre>
<pre><code>λ&gt; evalInt example
Just 2</code></pre>
<h1 id="appendices">
Appendices
</h1>
<p>
There’s nothing interesting to see here—unless you’ve never written a parser or pretty-printer before, in which case perhaps it is very interesting! If you want to learn how to write parsers, see <a href="https://markkarpov.com/tutorial/megaparsec.html">this very nice Megaparsec tutorial</a>. And <a href="https://hendrix-cs.github.io/csci360/modules/05-pretty-parse.html">see here for some help writing a basic pretty-printer</a>.
</p>
<h2 id="parsing">
Parsing
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>Parser</span> <span style="color: red">=</span> <span>Parsec</span> <span>Void</span> <span>Text</span>
<span style="color: blue;font-weight: bold">type</span> <span>ParserError</span> <span style="color: red">=</span> <span>ParseErrorBundle</span> <span>Text</span> <span>Void</span>

<span>reservedWords</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Text</span><span style="color: red">]</span>
<span>reservedWords</span> <span style="color: red">=</span> <span style="color: red">[</span><span style="color: teal">"let"</span><span style="color: red">,</span> <span style="color: teal">"in"</span><span style="color: red">,</span> <span style="color: teal">"if"</span><span style="color: red">,</span> <span style="color: teal">"then"</span><span style="color: red">,</span> <span style="color: teal">"else"</span><span style="color: red">,</span> <span style="color: teal">"Int"</span><span style="color: red">,</span> <span style="color: teal">"Bool"</span><span style="color: red">]</span>

<span>sc</span> <span style="color: red">::</span> <span>Parser</span> <span>()</span>
<span>sc</span> <span style="color: red">=</span> <span>L.space</span> <span>space1</span> <span style="color: red">(</span><span>L.skipLineComment</span> <span style="color: teal">"--"</span><span style="color: red">)</span> <span>empty</span>

<span>lexeme</span> <span style="color: red">::</span> <span>Parser</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>a</span>
<span>lexeme</span> <span style="color: red">=</span> <span>L.lexeme</span> <span>sc</span>

<span>symbol</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>Text</span>
<span>symbol</span> <span style="color: red">=</span> <span>L.symbol</span> <span>sc</span>

<span>reserved</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>()</span>
<span>reserved</span> <span>w</span> <span style="color: red">=</span> <span style="color: red">(</span><span>lexeme</span> <span>.</span> <span>try</span><span style="color: red">)</span> <span>$</span> <span>string'</span> <span>w</span> <span>*&gt;</span> <span>notFollowedBy</span> <span>alphaNumChar</span>

<span>identifier</span> <span style="color: red">::</span> <span>Parser</span> <span>Text</span>
<span>identifier</span> <span style="color: red">=</span> <span style="color: red">(</span><span>lexeme</span> <span>.</span> <span>try</span><span style="color: red">)</span> <span style="color: red">(</span><span>p</span> <span>&gt;&gt;=</span> <span>nonReserved</span><span style="color: red">)</span> <span>&lt;?&gt;</span> <span style="color: teal">"variable name"</span>
 <span style="color: blue;font-weight: bold">where</span>
  <span>p</span> <span style="color: red">=</span> <span style="color: red">(</span><span>:</span><span style="color: red">)</span> <span>&lt;$&gt;</span> <span>letterChar</span> <span>&lt;*&gt;</span> <span>many</span> <span>alphaNumChar</span>
  <span>nonReserved</span> <span style="color: red">(</span><span>into</span> <span style="color: red">@</span><span>Text</span> <span style="color: red">-&gt;</span> <span>t</span><span style="color: red">)</span>
    <span style="color: red">|</span> <span>t</span> <span>`elem`</span> <span>reservedWords</span> <span style="color: red">=</span>
        <span>fail</span> <span>.</span> <span>into</span> <span style="color: red">@</span><span>String</span> <span>$</span>
          <span>T.concat</span> <span style="color: red">[</span><span style="color: teal">"reserved word '"</span><span style="color: red">,</span> <span>t</span><span style="color: red">,</span> <span style="color: teal">"' cannot be used as variable name"</span><span style="color: red">]</span>
    <span style="color: red">|</span> <span>otherwise</span> <span style="color: red">=</span> <span>return</span> <span>t</span>

<span>integer</span> <span style="color: red">::</span> <span>Parser</span> <span>Int</span>
<span>integer</span> <span style="color: red">=</span> <span>lexeme</span> <span>L.decimal</span>

<span>parens</span> <span style="color: red">::</span> <span>Parser</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Parser</span> <span>a</span>
<span>parens</span> <span style="color: red">=</span> <span>between</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"("</span><span style="color: red">)</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">")"</span><span style="color: red">)</span>

<span>parseTermAtom</span> <span style="color: red">::</span> <span>Parser</span> <span>Term</span>
<span>parseTermAtom</span> <span style="color: red">=</span>
      <span>Lit</span> <span>&lt;$&gt;</span> <span>integer</span>
  <span>&lt;|&gt;</span> <span>Var</span> <span>&lt;$&gt;</span> <span>identifier</span>
  <span>&lt;|&gt;</span> <span>Lam</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"\\"</span> <span>*&gt;</span> <span>identifier</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">":"</span> <span>*&gt;</span> <span>parseType</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"."</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>Let</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"let"</span> <span>*&gt;</span> <span>identifier</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>symbol</span> <span style="color: teal">"="</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"in"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>If</span>  <span>&lt;$&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"if"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"then"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
          <span>&lt;*&gt;</span> <span style="color: red">(</span><span>reserved</span> <span style="color: teal">"else"</span> <span>*&gt;</span> <span>parseTerm</span><span style="color: red">)</span>
  <span>&lt;|&gt;</span> <span>parens</span> <span>parseTerm</span>

<span>parseTerm</span> <span style="color: red">::</span> <span>Parser</span> <span>Term</span>
<span>parseTerm</span> <span style="color: red">=</span> <span>makeExprParser</span> <span>parseTermAtom</span>
  <span style="color: red">[</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>App</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">""</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">,</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>Add</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"+"</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">,</span> <span style="color: red">[</span><span>InfixL</span> <span style="color: red">(</span><span>Gt</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"&gt;"</span><span style="color: red">)</span><span style="color: red">]</span>
  <span style="color: red">]</span>

<span>parseTypeAtom</span> <span style="color: red">::</span> <span>Parser</span> <span>Ty</span>
<span>parseTypeAtom</span> <span style="color: red">=</span>
  <span>TyInt</span> <span>&lt;$</span> <span>reserved</span> <span style="color: teal">"Int"</span>
  <span>&lt;|&gt;</span> <span>TyBool</span> <span>&lt;$</span> <span>reserved</span> <span style="color: teal">"Bool"</span>
  <span>&lt;|&gt;</span> <span>parens</span> <span>parseType</span>

<span>parseType</span> <span style="color: red">::</span> <span>Parser</span> <span>Ty</span>
<span>parseType</span> <span style="color: red">=</span> <span>makeExprParser</span> <span>parseTypeAtom</span>
  <span style="color: red">[</span> <span style="color: red">[</span><span>InfixR</span> <span style="color: red">(</span><span>TyFun</span> <span>&lt;$</span> <span>symbol</span> <span style="color: teal">"-&gt;"</span><span style="color: red">)</span><span style="color: red">]</span> <span style="color: red">]</span>

<span>readTerm</span> <span style="color: red">::</span> <span>Text</span> <span style="color: red">-&gt;</span> <span>Term</span>
<span>readTerm</span> <span style="color: red">=</span> <span>either</span> <span>undefined</span> <span>id</span> <span>.</span> <span>runParser</span> <span>parseTerm</span> <span style="color: teal">""</span></code></pre>
<h2 id="pretty-printing">
Pretty-printing
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">type</span> <span>Prec</span> <span style="color: red">=</span> <span>Int</span>

<span style="color: blue;font-weight: bold">class</span> <span>Pretty</span> <span>p</span> <span style="color: blue;font-weight: bold">where</span>
  <span>pretty</span> <span style="color: red">::</span> <span>p</span> <span style="color: red">-&gt;</span> <span>String</span>
  <span>pretty</span> <span style="color: red">=</span> <span>prettyPrec</span> <span class="hs-num">0</span>

  <span>prettyPrec</span> <span style="color: red">::</span> <span>Prec</span> <span style="color: red">-&gt;</span> <span>p</span> <span style="color: red">-&gt;</span> <span>String</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span>pretty</span>

<span>mparens</span> <span style="color: red">::</span> <span>Bool</span> <span style="color: red">-&gt;</span> <span>String</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>mparens</span> <span>True</span>  <span style="color: red">=</span> <span style="color: red">(</span><span style="color: teal">"("</span><span>++</span><span style="color: red">)</span> <span>.</span> <span style="color: red">(</span><span>++</span><span style="color: teal">")"</span><span style="color: red">)</span>
<span>mparens</span> <span>False</span> <span style="color: red">=</span> <span>id</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>Const</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>CInt</span> <span>i</span> <span style="color: red">-&gt;</span> <span>show</span> <span>i</span>
    <span>CIf</span> <span style="color: red">-&gt;</span> <span style="color: teal">"if"</span>
    <span>CAdd</span> <span style="color: red">-&gt;</span> <span style="color: teal">"plus"</span>
    <span>CGt</span>  <span style="color: red">-&gt;</span> <span style="color: teal">"gt"</span>
    <span>c</span> <span style="color: red">-&gt;</span> <span>show</span> <span>c</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>Idx</span> <span>γ</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: red">=</span> <span style="color: red">(</span><span style="color: teal">"x"</span> <span>++</span><span style="color: red">)</span> <span>.</span> <span>show</span> <span>.</span> <span>toNat</span>
    <span style="color: blue;font-weight: bold">where</span>
      <span>toNat</span> <span style="color: red">::</span> <span>Idx</span> <span>γ</span> <span>α</span> <span style="color: red">-&gt;</span> <span>Int</span>
      <span>toNat</span> <span>VZ</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span>toNat</span> <span style="color: red">(</span><span>VS</span> <span>i</span><span style="color: red">)</span> <span style="color: red">=</span> <span class="hs-num">1</span> <span>+</span> <span>toNat</span> <span>i</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>TTerm</span> <span>γ</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span>p</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>TVar</span> <span>x</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>x</span>
    <span>TConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>c</span>
    <span>TLam</span> <span>t</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">0</span><span style="color: red">)</span> <span>$</span> <span style="color: teal">"λ. "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">0</span> <span>t</span>
    <span>TApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">1</span><span style="color: red">)</span> <span>$</span>
      <span>prettyPrec</span> <span class="hs-num">1</span> <span>t1</span> <span>++</span> <span style="color: teal">" "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">2</span> <span>t2</span>

<span style="color: blue;font-weight: bold">instance</span> <span>Pretty</span> <span style="color: red">(</span><span>BTerm</span> <span>α</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">where</span>
  <span>prettyPrec</span> <span>p</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
    <span>BConst</span> <span>c</span> <span style="color: red">-&gt;</span> <span>pretty</span> <span>c</span>
    <span>BApp</span> <span>t1</span> <span>t2</span> <span style="color: red">-&gt;</span> <span>mparens</span> <span style="color: red">(</span><span>p</span><span>&gt;</span><span class="hs-num">0</span><span style="color: red">)</span> <span>$</span>
      <span>prettyPrec</span> <span class="hs-num">0</span> <span>t1</span> <span>++</span> <span style="color: teal">" "</span> <span>++</span> <span>prettyPrec</span> <span class="hs-num">1</span> <span>t2</span></code></pre>
<h1 class="unnumbered" id="references">
References
</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-augustsson1986small" class="csl-entry" role="doc-biblioentry">
Augustsson, L. (1986) <em>SMALL: A small interactive functional system</em>. Chalmers Tekniska H<span>ö</span>gskola/G<span>ö</span>teborgs Universitet. Programming Methodology Group.
</div>
<div id="ref-diller1988compiling" class="csl-entry" role="doc-biblioentry">
Diller, A. (1988) <em>Compiling functional languages</em>. John Wiley &amp; Sons, Inc.
</div>
<div id="ref-diller2014bracket" class="csl-entry" role="doc-biblioentry">
Diller, A. (2014) <em><span class="nocase">Bracket abstraction algorithms</span></em>. Available at: <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">https://www.cantab.net/users/antoni.diller/brackets/intro.html</a>.
</div>
<div id="ref-elliott2017compiling" class="csl-entry" role="doc-biblioentry">
Elliott, C. (2017) <span>‘Compiling to categories’</span>, <em>Proceedings of the ACM on Programming Languages</em>, 1(ICFP), pp. 1–27.
</div>
<div id="ref-gratzer2015bracket" class="csl-entry" role="doc-biblioentry">
Gratzer, D. (2015) <em><span class="nocase">Bracket Abstraction: The Smallest PL You’ve Ever Seen</span></em>. Available at: <a href="https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html">https://jozefg.bitbucket.io/posts/2015-05-01-brackets.html</a>.
</div>
<div id="ref-spj1987implementation" class="csl-entry" role="doc-biblioentry">
Jones, S.L.P. (1987) <em><span class="nocase">The Implementation of Functional Programming Languages</span></em>. Prentice-Hall, Inc.
</div>
<div id="ref-kiselyov2018lambda" class="csl-entry" role="doc-biblioentry">
Kiselyov, O. (2018) <span>‘<span class="math inline"><em>λ</em></span> to ski, semantically: Declarative pearl’</span>, in <em>International symposium on functional and logic programming</em>. Springer, pp. 33–50.
</div>
<div id="ref-le2017singletons" class="csl-entry" role="doc-biblioentry">
Le, J. (2017) <em><span class="nocase">Introduction to Singletons (Part 1)</span></em>. Available at: <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">https://blog.jle.im/entry/introduction-to-singletons-1.html</a>.
</div>
<div id="ref-lynncompiler" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2017) <em><span>A Combinatory Compiler</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">https://crypto.stanford.edu/~blynn/lambda/sk.html</a>.
</div>
<div id="ref-lynncl" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2022) <em><span>Combinatory Logic</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">https://crypto.stanford.edu/~blynn/lambda/cl.html</a>.
</div>
<div id="ref-lynnkiselyov" class="csl-entry" role="doc-biblioentry">
Lynn, B. (2022) <em><span>Kiselyov Combinator Translation</span></em>. Available at: <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">https://crypto.stanford.edu/~blynn/lambda/kiselyov.html</a>.
</div>
<div id="ref-mahler2021graph" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2021) <em><span class="nocase">Implementing a Functional Language with Graph Reduction</span></em>. Available at: <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html</a>.
</div>
<div id="ref-mahler2021ccc" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2021) <em><span class="nocase">λ-Calculus, Combinatory Logic and Cartesian Closed Categories</span></em>. Available at: <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html</a>.
</div>
<div id="ref-mahler2022evaluating" class="csl-entry" role="doc-biblioentry">
Mahler, T. (2022) <em><span class="nocase">Evaluating SKI combinators as native Haskell functions</span></em>. Available at: <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html</a>.
</div>
<div id="ref-naylor2008evaluating" class="csl-entry" role="doc-biblioentry">
Naylor, M. (2008) <span>‘<span class="nocase">Evaluating Haskell in Haskell</span>’</span>, <em>The Monad.Reader</em>. Edited by W. Swierstra, Issue 10.
</div>
<div id="ref-seo2016interpreter" class="csl-entry" role="doc-biblioentry">
Seo, K.Y. (2016) <em><span class="nocase">Write you an interpreter</span></em>. Available at: <a href="http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">http://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html</a>.
</div>
<div id="ref-turner1979new" class="csl-entry" role="doc-biblioentry">
Turner, D.A. (1979) <span>‘A new implementation technique for applicative languages’</span>, <em>Software: Practice and Experience</em>, 9(1), pp. 31–49.
</div>
</div>

]]></description>
    <pubDate>2023-07-13T20:55:18Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/07/13/compiling-to-intrinsically-typed-combinators.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive Programming in Haskell: two more DP challenges</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges.html</link>
    <description><![CDATA[
<h1>Competitive Programming in Haskell: two more DP challenges</h1>

<div class="info">
  Posted on June 20, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
Continuing the <a href="https://byorgey.wordpress.com/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming/">series on dynamic programming</a>, I just have a couple challenge problems for you today. I have indeed solved both of these problems in Haskell, but I don’t yet know how to write <strong>elegant</strong> solutions! There is a reason that the techniques covered in my <a href="https://byorgey.wordpress.com/2023/06/06/dynamic-programming-in-haskell-automatic-memoization/">previous posts</a> aren’t quite good enough.
</p>
<ul>
<li>
<a href="https://open.kattis.com/problems/honi">Honi</a>
</li>
<li>
<a href="https://open.kattis.com/problems/assassins">Assassins</a>
</li>
</ul>
<p>
Feel free to discuss in the comments! I’m hoping that I can learn some new approaches from some of my readers. I will probably post some hints in the comments towards the right recurrences, so don’t look at the comments if you don’t want any spoilers.
</p>

]]></description>
    <pubDate>2023-06-20T20:42:24Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Nested folds</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/17/nested-folds.html</link>
    <description><![CDATA[
<h1>Nested folds</h1>

<div class="info">
  Posted on June 17, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;ADH&#39;." href="/tag/ADH.html" rel="tag">ADH</a>, <a title="All pages tagged &#39;fold&#39;." href="/tag/fold.html" rel="tag">fold</a>, <a title="All pages tagged &#39;fusion&#39;." href="/tag/fusion.html" rel="tag">fusion</a>, <a title="All pages tagged &#39;nested&#39;." href="/tag/nested.html" rel="tag">nested</a>
  
</div>

<section>
<p>
I’m finally getting around to reading <a href="https://www.cs.ox.ac.uk/publications/books/adwh/">Algorithm Design with Haskell</a> (hereafter abbreviated as ADH), by Jeremy Gibbons and Richard Bird. I’ve had it for a while, and I have no excuse for waiting this long to read it, but anyway. I’m enjoying it so far, and wanted to share something I (indirectly) learned. I’m sure there are some who already know this, but I didn’t. I’ll share both the fun takeaway and then also the interesting, roundabout path I took to get there.
</p>
<h2 id="composed-folds-are-nested-folds">
Composed folds are nested folds
</h2>
<p>
Here’s the punchline:
</p>
<ul>
<li>
<code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>
</li>
<li>
<code>foldl . foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [[a]] -&gt; b</code>
</li>
<li>
<code>foldl . foldl . foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [[[a]]] -&gt; b</code>
</li>
</ul>
<p>
Actually, it’s a bit more general than this, since <code>foldl</code> works over any <code>Foldable</code>, not just lists: in fact, <code>foldl . foldl . foldl</code> can be used to fold any <code>t1 (t2 (t3 a))</code> as long as <code>t1</code>, <code>t2</code>, and <code>t3</code> are all instances of <code>Foldable</code>. For example, here is how we can add up all the integers contained in a <code>Maybe (Tree [Int])</code>:
</p>
<pre><code>λ&gt; (foldl . foldl . foldl) (+) 0 (Just (Node [1,2,3] [Node [5,6] [], Node [7] [], Node [9,12] [Node [6] []]]))
51</code></pre>
<p>
We can make sense of this if we look at the type of <code>foldl</code>. Its type is
</p>
<pre><code>Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</code></pre>
<p>
and we usually think of it as taking three arguments: a combining function of type <code>b -&gt; a -&gt; b</code>, an initial value of type <code>b</code>, and a structure to fold. But we can also think of it as a one-argument function. That is, it takes a function of type <code>b -&gt; a -&gt; b</code> and transforms it into a function of type <code>b -&gt; t a -&gt; b</code>:
</p>
<pre><code>foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; (b -&gt; t a -&gt; b)</code></pre>
<p>
Due to the magic of currying this is equivalent, and the second set of parentheses above is redundant. However, with this change of perspective it is easy to see what’s going on: the result of <code>foldl</code> is a function of type <code>b -&gt; t a -&gt; b</code>, which has the right shape to be the argument of <code>foldl</code> again, but this time with <code>t a</code> in place of <code>a</code>, yielding
</p>
<pre><code>(b -&gt; t a -&gt; b) -&gt; (b -&gt; t2 (t a) -&gt; b)</code></pre>
<p>
and so on.
</p>
<p>
What about <code>foldr</code>?
</p>
<pre><code>foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; (b -&gt; t a -&gt; b)</code></pre>
<p>
The shapes of the input and output to <code>foldr</code> don’t quite match, but they will if we throw in an extra <code>flip</code>, which switches the arguments of a two-argument function. So we can either do
</p>
<pre><code>foldr . flip :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; (b -&gt; t a -&gt; b)</code></pre>
<p>
if we want to match the type of <code>foldl</code>, or
</p>
<pre><code>flip . foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; (t a -&gt; b -&gt; b)</code></pre>
<p>
In any case, we can now iterate just as with <code>foldl</code>; for example
</p>
<pre><code>foldr . flip . foldr . flip . foldr :: (a -&gt; b -&gt; b) -&gt; (b -&gt; t1 (t2 (t3 a)) -&gt; b)</code></pre>
<p>
(with some appropriate <code>Foldable</code> constraints thrown in as well).
</p>
<h2 id="my-roundabout-journey">
My roundabout journey
</h2>
<p>
So how did I come to realize this? Sometimes the journey is more interesting than the destination. The first chapter of ADH talks about the <em>foldr fusion rule</em>, which says that
</p>
<pre><code>h . foldr f e == foldr g (h e)</code></pre>
<p>
as long as <code>h (f x y) == g x (h y)</code> for all <code>x</code> and <code>y</code>. In other words, if we have a <code>foldr</code> followed by a function <code>h</code>, we can turn this into a single <code>foldr</code> (<em>i.e.</em> “fuse away” the <code>h</code>) as long as we can find an appropriate function <code>g</code> that satisfies the given criterion.
</p>
<p>
One of the exercises asks us to use <code>foldr</code> fusion to simplify
</p>
<pre><code>foldr f e . concat</code></pre>
<p>
which performs a fold over a nested list by first flattening the list and then doing a fold. You may wish to go try it yourself before reading on!
</p>
<h2 id="the-solution">
The solution
</h2>
<p>
We can compute as follows, where <code>g</code> is some function we will need to define appropriately:
</p>
<pre><code>  foldr f e . concat
=                              { definition of concat }
  foldr f e . foldr (++) []
=                              { foldr fusion law, with h = foldr f e }
  foldr g (foldr f e [])
=                              { definition of foldr }
  foldr g e</code></pre>
<p>
According to the fusion condition, we need <code>g</code> to satisfy <code>foldr f e (x ++ y) == g x (foldr f e y)</code>. This was already given as a previous exercise; I actually solved it by thinking about how <code>foldr</code> works and intuiting the right answer, but we can also calculate it using a second round of <code>foldr</code> fusion:
</p>
<pre><code>  g x (foldr f e y)
=
  foldr f e (x ++ y)
=                              { definition of (++) }
  foldr f e (foldr (:) y x)
=                              { foldr fusion }
  foldr f (foldr f e y) x</code></pre>
<p>
The last equation follows since <code>foldr f e (a : b) = f a (foldr f e b)</code> by definition of <code>foldr</code>. Hence, using <code>z</code> in place of <code>foldr f e y</code>, we have <code>g x z = foldr f z x = flip (foldr f) x z</code>, and so <code>g = flip (foldr f)</code>, and we have
</p>
<pre><code>foldr f e . concat = foldr (flip (foldr f)) e</code></pre>
<p>
We can simplify even further: if we define <code>nestedFold f e = foldr f e . concat = foldr (flip (foldr f)) e</code> then we can eta-reduce to get <code>nestedFold = foldr . flip . foldr</code>.
</p>
<p>
When I derived this, my eyes bugged out and I started playing around with it, which is how I ended up figuring out the thing with <code>foldl</code>. Presumably, one could use the similar <code>foldl</code> fusion law to fuse <code>foldl f e . concat</code> and end up deriving the <code>foldl . foldl</code> result; I’ll leave that as an exercise for interested readers.
</p>

]]></description>
    <pubDate>2023-06-17T21:54:56Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/17/nested-folds.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Dynamic programming in Haskell: automatic memoization</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html</link>
    <description><![CDATA[
<h1>Dynamic programming in Haskell: automatic memoization</h1>

<div class="info">
  Posted on June  6, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
This is part 2 of a <a href="https://byorgey.wordpress.com/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming/">promised multi-part series</a> on dynamic programming in Haskell. As a reminder, we’re using <a href="https://open.kattis.com/problems/zapis">Zapis</a> as a sample problem. In this problem, we are given a sequence of opening and closing brackets (parens, square brackets, and curly braces) with question marks, and have to compute the number of different ways in which the question marks could be replaced by brackets to create valid, properly nested bracket sequences.
</p>
<p>
<a href="https://byorgey.wordpress.com/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays/">Last time</a>, we developed some code to efficiently solve this problem using a mutually recursive pair of a function and a lookup table represented by a lazy, immutable array. This solution is pretty good, but it leaves a few things to be desired:
</p>
<ul>
<li>
It requires defining <em>both</em> a function and a lazy, immutable array, and coming up with names for them.
</li>
<li>
When defining the function, we have to remember to index into the array instead of calling the function recursively, and there is nothing that will warn us if we forget.
</li>
</ul>
<h2 id="an-impossible-dream">
An impossible dream
</h2>
<p>
Wouldn’t it be cool if we could <em>just</em> write the recursive function, and then have some generic machinery make it fast for us by automatically generating a memo table?
</p>
<p>
In other words, we’d like a magic memoization function, with a type something like this:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>memo</span> <span style="color: red">::</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span></code></pre>
<p>
Then we could just define our slow, recursive function normally, wave our magic <code>memo</code> wand over it, and get a fast version for free!
</p>
<p>
This sounds lovely, of course, but there are a few problems:
</p>
<ul>
<li>
<p>
Surely this magic <code>memo</code> function won’t be able to work for <em>any</em> type <code>i</code>. Well, OK, we can add something like an <code>Ix i</code> constraint and/or extra arguments to make sure that values of type <code>i</code> can be used as (or <a href="https://byorgey.wordpress.com/2021/11/17/competitive-programming-in-haskell-bfs-part-4-implementation-via-stuarray/">converted to</a>) array indices.
</p>
</li>
<li>
<p>
How can <code>memo</code> possibly know how big of a table to allocate? One simple way to solve this would be to provide the table size as an extra explicit argument to <code>memo</code>. (In my next post we’ll also explore some clever things we can do when we don’t know in advance how big of a table we will need.)
</p>
</li>
<li>
<p>
More fundamentally, though, our dream seems impossible: given a function <code>i -&gt; a</code>, the only thing the <code>memo</code> function can do is call it on some input of type <code>i</code>; if the <code>i -&gt; a</code> function is recursive then it will go off and do its recursive thing without ever consulting a memo table, defeating the entire purpose.
</p>
</li>
</ul>
<h2 id="or-is-it">
… or is it?
</h2>
<p>
For now let’s ignore the fact that our dream seems impossible and think about how we could write <code>memo</code>. The idea is to take the given <code>(i -&gt; a)</code> function and first turn it into a lookup table storing a value of type <code>a</code> for each <code>i</code>; then return a new <code>i -&gt; a</code> function which works by just doing a table lookup.
</p>
<p>
From my <a href="https://byorgey.wordpress.com/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays/">previous post</a> we already have a function to create a table for a given function:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span></code></pre>
<p>
The inverse function, which turns an array back into a function, is just the array indexing operator, with extra parentheses around the <code>i -&gt; a</code> to emphasize the shift in perspective:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span>Array</span> <span>i</span> <span>a</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span></code></pre>
<p>
So we can define <code>memo</code> simply as the composition
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>memo</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span>
<span>memo</span> <span>rng</span> <span style="color: red">=</span> <span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span>.</span> <span>tabulate</span> <span>rng</span></code></pre>
<p>
This is nifty… but as we already saw, it doesn’t help very much… right? For example, let’s define a recursive (slow!) Fibonacci function, and apply <code>memo</code> to it:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE LambdaCase #-}</span>

<span>fib</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>fib</span> <span style="color: red">=</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span class="hs-num">0</span> <span style="color: red">-&gt;</span> <span class="hs-num">0</span>
  <span class="hs-num">1</span> <span style="color: red">-&gt;</span> <span class="hs-num">1</span>
  <span>n</span> <span style="color: red">-&gt;</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>+</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">2</span><span style="color: red">)</span>

<span>fib'</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>fib'</span> <span style="color: red">=</span> <span>memo</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">1000</span><span style="color: red">)</span> <span>fib</span></code></pre>
<p>
As you can see from the following <code>ghci</code> session, calling, say, <code>fib’ 35</code> is still very slow the first time, since it simply calls <code>fib 35</code> which does its usual exponential recursion. However, if we call <code>fib’ 35</code> a second time, we get the answer instantly:
</p>
<pre><code>λ&gt; :set +s
λ&gt; fib' 35
9227465
(4.18 secs, 3,822,432,984 bytes)
λ&gt; fib' 35
9227465
(0.00 secs, 94,104 bytes)</code></pre>
<p>
This is better than nothing, but it’s not really the point. We want it to be fast the <em>first</em> time by looking up <em>intermediate</em> results in the memo table. And trying to call <code>fib’</code> on bigger inputs is still going to be completely hopeless.
</p>
<h2 id="the-punchline">
The punchline
</h2>
<p>
All might seem hopeless at this point, but we actually have everything we need—all we have to do is just <strong>stick the call to <code>memo</code> in the definition of <code>fib</code> itself</strong>!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>fib</span> <span style="color: red">::</span> <span>Int</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>fib</span> <span style="color: red">=</span> <span>memo</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">1000</span><span style="color: red">)</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
  <span class="hs-num">0</span> <span style="color: red">-&gt;</span> <span class="hs-num">0</span>
  <span class="hs-num">1</span> <span style="color: red">-&gt;</span> <span class="hs-num">1</span>
  <span>n</span> <span style="color: red">-&gt;</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>+</span> <span>fib</span> <span style="color: red">(</span><span>n</span><span style="color: green">-</span><span class="hs-num">2</span><span style="color: red">)</span></code></pre>
<p>
Magically, <code>fib</code> is now fast:
</p>
<pre><code>λ&gt; fib 35
9227465
(0.00 secs, 94,096 bytes)
λ&gt; fib 1000
43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
(0.01 secs, 807,560 bytes)</code></pre>
<p>
This solves all our problems. We only have to write a single definition, which is a directly recursive function, so it’s hard to mess it up. The only thing we have to change is to stick a call to <code>memo</code> (with an appropriate index range) on the front; the whole thing is elegant and short.
</p>
<p>
How does this even work, though? At first glance, it might seem like it will generate a new table with every recursive call to <code>fib</code>, which would obviously be a disaster. However, that’s not what happens: there is only a single, top-level definition of <code>fib</code>, and it is defined as the function which looks up its input in a certain table. Every time we call <code>fib</code> we are calling that same, unique top-level function which is defined in terms of its (unique, top-level) table. So this ends up being equivalent to our previous solution—there is a mutually recursive pair of a function and a lookup table—but written in a much nicer, more compact way that doesn’t require us to explicitly name the table.
</p>
<p>
So here’s our final solution for Zapis. As you can see, the extra code we have to write in order to memoize our recurrence boils down to about five lines (two of which are type signatures and could be omitted). This is definitely a technique worth knowing!
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE LambdaCase #-}</span>

<span style="color: blue;font-weight: bold">import</span> <span>Control.Arrow</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Array</span>

<span>main</span> <span style="color: red">=</span> <span>interact</span> <span>$</span> <span>lines</span> <span>&gt;&gt;&gt;</span> <span>last</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>format</span>

<span>format</span> <span style="color: red">::</span> <span>Integer</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>format</span> <span style="color: red">=</span> <span>show</span> <span>&gt;&gt;&gt;</span> <span>reverse</span> <span>&gt;&gt;&gt;</span> <span>take</span> <span class="hs-num">5</span> <span>&gt;&gt;&gt;</span> <span>reverse</span>

<span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span>

<span>memo</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span>
<span>memo</span> <span>rng</span> <span style="color: red">=</span> <span style="color: red">(</span><span>!</span><span style="color: red">)</span> <span>.</span> <span>tabulate</span> <span>rng</span>

<span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>c</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">=</span> <span>memo</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span> <span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>$</span> <span style="color: red">\</span><span style="color: blue;font-weight: bold">case</span>
      <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">-&gt;</span> <span class="hs-num">1</span>
        <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">-&gt;</span> <span class="hs-num">0</span>
        <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">-&gt;</span> <span>sum</span>
          <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>j</span><span style="color: red">)</span>
          <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
          <span style="color: red">]</span>

<span>m</span> <span style="color: teal">'('</span> <span style="color: teal">')'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'['</span> <span style="color: teal">']'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'{'</span> <span style="color: teal">'}'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span style="color: teal">'?'</span>                <span style="color: red">=</span> <span class="hs-num">3</span>
<span>m</span> <span>b</span> <span style="color: teal">'?'</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">"([{"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span>b</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">")]}"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span>                    <span style="color: red">=</span> <span class="hs-num">0</span></code></pre>

]]></description>
    <pubDate>2023-06-06T14:21:04Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/06/dynamic-programming-in-haskell-automatic-memoization.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Dynamic programming in Haskell: lazy immutable arrays</title>
    <link>http://byorgey.github.io/blog/posts/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays.html</link>
    <description><![CDATA[
<h1>Dynamic programming in Haskell: lazy immutable arrays</h1>

<div class="info">
  Posted on June  2, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
This is part 1 of a <a href="https://byorgey.wordpress.com/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming/">promised multi-part series</a> on dynamic programming in Haskell. As a reminder, we’re using <a href="https://open.kattis.com/problems/zapis">Zapis</a> as a sample problem. In this problem, we are given a sequence of opening and closing brackets (parens, square brackets, and curly braces) with question marks, and have to compute the number of different ways in which the question marks could be replaced by brackets to create valid, properly nested bracket sequences.
</p>
<p>
<a href="https://byorgey.wordpress.com/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming/">Last time</a>, we developed a recurrence for this problem and saw some naive, directly recursive Haskell code for computing it. Although this naive version is technically correct, it is much too slow, so our goal is to implement it more efficiently.
</p>
<h2 id="mutable-arrays">
Mutable arrays?
</h2>
<p>
Someone coming from an imperative background might immediately reach for some kind of mutable array, <em>e.g.</em> <code>STUArray</code>. Every time we call the function, we check whether the corresponding array index has already been filled in. If so, we simply return the stored value; if not, we compute the value recursively, and then fill in the array before returning it.
</p>
<p>
This would work, but there is a better way!
</p>
<h2 id="immutable-arrays">
Immutable arrays
</h2>
<p>
While mutable arrays <a href="https://byorgey.wordpress.com/2021/11/17/competitive-programming-in-haskell-bfs-part-4-implementation-via-stuarray/">occasionally have their place</a>, we can surprisingly often get away with <em>immutable</em> arrays, where we completely define the array up front and then only use it for fast lookups afterwards.
</p>
<ul>
<li>
If the type of the array elements is suitable, and we can initialize the array elements all at once from a list using some kind of formula, map, scan, <em>etc.</em>, we should use <code>UArray</code> <a href="https://byorgey.wordpress.com/2023/02/24/competitive-programming-in-haskell-infinite-2d-array-level-4/">since it is much faster</a> than <code>Array</code>.
</li>
<li>
However, <code>UArray</code> is strict in the elements, and the elements must be of a type that can be stored unboxed. If we need a more complex element type, or we need to compute the array recursively (where some elements depend on other elements), we can use <code>Array</code>.
</li>
</ul>
<p>
What about the <a href="http://hackage.haskell.org/package/vector"><code>vector</code> library</a>, you ask? Well, it’s a very nice library, and quite fast, but unfortunately it is not available on many judging platforms, so I tend to stick to <code>array</code> to be safe. However, if you’re doing something like <a href="https://adventofcode.com/">Advent of Code</a> or <a href="https://projecteuler.net/">Project Euler</a> where you get to run the code on your own machine, then you should definitely reach for <code>vector</code>.
</p>
<h2 id="lazy-recursive-immutable-arrays">
Lazy, recursive, immutable arrays
</h2>
<p>
In <a href="https://byorgey.wordpress.com/2023/04/11/competitive-programming-in-haskell-topsort-via-laziness/">my previous post on topsort</a> we already saw the basic idea: since <code>Array</code>s are lazy in their elements, we can define them recursively; the Haskell runtime then takes care of computing the elements in a suitable order. Previously, we saw this applied to automatically compute a topological sort, but more generally, we can use it to fill out a table of values for any recurrence.
</p>
<p>
So, as a first attempt, let’s just replace our recursive <code>c</code> function from <a href="https://byorgey.wordpress.com/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming/">last time</a> with an array. I’ll only show the <code>solve</code> function for now; the rest of the code remains the same. (Spoiler alert: this solution works, but it’s ugly. We’ll develop much better solutions later.)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>c</span><span>!</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>c</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
    <span>c</span> <span style="color: red">=</span> <span>array</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span><span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>$</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span><span style="color: red">,</span> <span class="hs-num">1</span><span style="color: red">)</span> <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span> <span style="color: red">]</span>
      <span>++</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span> <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>j</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">]</span>
      <span>++</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">,</span><span>v</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>j</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span><span style="color: red">..</span><span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>i</span> <span>/=</span> <span>j</span><span style="color: red">,</span> <span>even</span> <span>i</span> <span>==</span> <span>even</span> <span>j</span>
      <span style="color: red">,</span> <span style="color: blue;font-weight: bold">let</span> <span>v</span> <span style="color: red">=</span> <span>sum</span> <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span><span>!</span><span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span><span>!</span><span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span> <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span><span style="color: red">]</span>
      <span style="color: red">]</span></code></pre>
<p>
We use the <code>array</code> function to create an array, which takes first a pair of indices specifying the index range, and then a list of (index, value) pairs. (The <code>listArray</code> function can also be particularly useful, when we have a list of values which are already in index order, as in the definition of <code>s</code>.)
</p>
<p>
This solution is accepted, and it’s quite fast (0.04s for me). However, it’s really ugly, and although it’s <em>conceptually</em> close to our directly recursive function from before, the code is almost unrecognizably different. It’s ugly that we have to repeat conditions like <code>i /= j</code> and <code>even i == even j</code>, and binders like <code>i &lt;- [0..n]</code>; the multiple list comprehensions and nested pairs like <code>((i,j),v)</code> are kind of ugly, and the fact that this is implementing a recurrence is completely obscured.
</p>
<p>
However, I included this solution as a first step because for a long time, after I learned about using lazy immutable arrays to implement dynamic programming in Haskell, this was the kind of solution I wrote! Indeed, if you just think about the idea of creating a recursively defined array, this might be the kind of thing you come up with: we define an array <code>c</code> using the <code>array</code> function, then we have to list all its elements, and we get to refer to <code>c</code> along the way.
</p>
<h2 id="mutual-recursion-to-the-rescue">
Mutual recursion to the rescue
</h2>
<p>
Most of the ugliness comes from losing sight of the fact that there is a <em>function</em> mapping indices to values: we simply listed out all the function’s input/output pairs without getting to use any of Haskell’s very nice facilities for defining functions! So we can clean up the code considerably if we make a <em>mutually recursive</em> pair of an array and a function: the array values are defined using the function, and the function definition can look up values in the array.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>cA</span><span>!</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>cA</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
    <span>cA</span> <span style="color: red">=</span> <span>array</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span><span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>$</span>
      <span style="color: red">[</span> <span style="color: red">(</span><span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">,</span> <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span><span style="color: red">)</span> <span style="color: red">|</span> <span>i</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span> <span style="color: red">..</span> <span>n</span><span style="color: red">]</span><span style="color: red">,</span> <span>j</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span class="hs-num">0</span> <span style="color: red">..</span> <span>n</span><span style="color: red">]</span> <span style="color: red">]</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">=</span> <span class="hs-num">1</span>
      <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">=</span> <span>sum</span>
        <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
        <span style="color: red">]</span></code></pre>
<p>
Much better! The <code>c</code> function looks much the same as our naive version from before, with the one difference that instead of calling itself recursively, it looks up values in the array <code>cA</code>. The array, in turn, is simply defined as a lookup table for the outputs of the function.
</p>
<h2 id="generalized-tabulation">
Generalized tabulation
</h2>
<p>
One nice trick we can use to simplify the code a bit more is to use the <code>range</code> function to generate the list of all valid array indices, and then just <code>map</code> the <code>c</code> function over this. This also allows us to use the <code>listArray</code> function, since we know that the <code>range</code> will generate the indices in the right order.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>cA</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
<span>cA</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span>$</span> <span>map</span> <span>c</span> <span style="color: red">(</span><span>range</span> <span>rng</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>rng</span> <span style="color: red">=</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span> <span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span></code></pre>
<p>
In fact, we can abstract this into a useful little function to create a lookup table for a function:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span></code></pre>
<p>
(We can generalize this even more to make it work for <code>UArray</code> as well as <code>Array</code>, but I’ll stop here for now. And yes, I intentionally named this to echo the <a href="https://hackage.haskell.org/package/adjunctions-4.4.2/docs/Data-Functor-Rep.html#v:tabulate"><code>tabulate</code> function from the <code>adjunctions</code> package</a>; <code>Array i</code> is indeed a representable functor, though it’s not really possible to express without dependent types.)
</p>
<h2 id="the-solution-so-far">
The solution so far
</h2>
<p>
Putting it all together, here’s our complete solution so far. It’s pretty good, and in fact it’s organized in a very similar way to <a href="https://gist.github.com/meooow25/8d5441fa54e645c8f2a48f91a750d360">Soumik Sarkar’s dynamic programming solution</a> to <a href="https://byorgey.wordpress.com/2023/05/24/competitive-programming-in-haskell-parsing-with-an-nfa/">Chemist’s Vows</a>. (However, there’s an even better solution coming in my next post!)
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">import</span> <span>Control.Arrow</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Array</span>

<span>main</span> <span style="color: red">=</span> <span>interact</span> <span>$</span> <span>lines</span> <span>&gt;&gt;&gt;</span> <span>last</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>format</span>

<span>format</span> <span style="color: red">::</span> <span>Integer</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>format</span> <span style="color: red">=</span> <span>show</span> <span>&gt;&gt;&gt;</span> <span>reverse</span> <span>&gt;&gt;&gt;</span> <span>take</span> <span class="hs-num">5</span> <span>&gt;&gt;&gt;</span> <span>reverse</span>

<span>tabulate</span> <span style="color: red">::</span> <span>Ix</span> <span>i</span> <span style="color: red">=&gt;</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>i</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>i</span> <span style="color: red">-&gt;</span> <span>a</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>i</span> <span>a</span>
<span>tabulate</span> <span>rng</span> <span>f</span> <span style="color: red">=</span> <span>listArray</span> <span>rng</span> <span style="color: red">(</span><span>map</span> <span>f</span> <span>$</span> <span>range</span> <span>rng</span><span style="color: red">)</span>

<span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>cA</span><span>!</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>cA</span> <span style="color: red">::</span> <span>Array</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span>Integer</span>
    <span>cA</span> <span style="color: red">=</span> <span>tabulate</span> <span style="color: red">(</span><span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span class="hs-num">0</span><span style="color: red">)</span><span style="color: red">,</span><span style="color: red">(</span><span>n</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span><span style="color: red">)</span> <span>c</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">=</span> <span class="hs-num">1</span>
      <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">=</span> <span>sum</span>
        <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>cA</span> <span>!</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
        <span style="color: red">]</span>

<span>m</span> <span style="color: teal">'('</span> <span style="color: teal">')'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'['</span> <span style="color: teal">']'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'{'</span> <span style="color: teal">'}'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span style="color: teal">'?'</span>                <span style="color: red">=</span> <span class="hs-num">3</span>
<span>m</span> <span>b</span> <span style="color: teal">'?'</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">"([{"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span>b</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">")]}"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span>                    <span style="color: red">=</span> <span class="hs-num">0</span></code></pre>
<h2 id="coming-up-next-automatic-memoization">
Coming up next: automatic memoization!
</h2>
<p>
So what’s not to like about this solution? Well, I still don’t like the fact that we have to define a mutually recursive array and function. Conceptually, I want to name them both <code>c</code> (or whatever) since they are really isomorphic representations of the exact same mathematical function. It’s annoying that I have to make up a name like <code>cA</code> or <code>c’</code> or whatever for one of them. I also don’t like that we have to remember to do array lookups instead of recursive calls in the function—and if we forget, Haskell will not complain! It will just be really slow.
</p>
<p>
Next time, we’ll see how to use some clever ideas from Conal Elliot’s <a href="https://hackage.haskell.org/package/MemoTrie"><code>MemoTrie</code> package</a> (which themselves ultimately came from <a href="https://citeseerx.ist.psu.edu/doc/10.1.1.43.3272">a paper by Ralf Hinze</a>) to solve these remaining issues and end up with some really beautiful code!
</p>

]]></description>
    <pubDate>2023-06-02T16:09:44Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive programming in Haskell: introduction to dynamic programming</title>
    <link>http://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html</link>
    <description><![CDATA[
<h1>Competitive programming in Haskell: introduction to dynamic programming</h1>

<div class="info">
  Posted on May 31, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;dynamic programming&#39;." href="/tag/dynamic%20programming.html" rel="tag">dynamic programming</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>
  
</div>

<section>
<p>
In <a href="https://byorgey.wordpress.com/2023/05/24/competitive-programming-in-haskell-parsing-with-an-nfa/">my previous post</a>, I challenged you to solve <a href="https://open.kattis.com/problems/zapis">Zapis</a>. In this problem, we are given a sequence of opening and closing brackets (parens, square brackets, and curly braces) with question marks, and have to compute the number of different ways in which the question marks could be replaced by brackets to create valid, properly nested bracket sequences.
</p>
<p>
For example, given <code>(??)</code>, the answer is 4: we could replace the question marks with any matched pair (either <code>()</code>, <code>[]</code>, or <code>{}</code>), or we could replace them with <code>)(</code>, resulting in <code>()()</code>.
</p>
<h2 id="an-annoying-aside">
An annoying aside
</h2>
<p>
One very annoying thing to mention about this problem is that it requires us to output the <em>last 5 digits</em> of the answer. At first, I interpreted that to mean “output the answer modulo <span class="math inline">\(10^5\)</span>”, which would be a standard sort of condition for a combinatorics problem, but that’s not quite the same thing, in a very annoying way: for example, if the answer is <span class="math inline">\(2\)</span>, we are supposed to output <code>2</code>; but if the answer is <span class="math inline">\(1000000002\)</span>, we are supposed to output <code>00002</code>, not <code>2</code>! So simply computing the answer modulo <span class="math inline">\(10^5\)</span> is not good enough; if we get a final answer of <span class="math inline">\(2\)</span>, we don’t know whether we are supposed to pad it with zeros. I could imagine keeping track of both the result modulo <span class="math inline">\(10^5\)</span> along with a Boolean flag telling us whether the number has ever overflowed; we have to pad with zeros iff the flag is set at the end. I’m pretty sure this would work. But for this problem, it turns out that the final answer is at most “only” about 100 digits, so we can just compute the answer exactly as an <code>Integer</code> and then literally show the last 5 digits.
</p>
<h2 id="a-recurrence">
A recurrence
</h2>
<p>
Now, how to compute the answer? For this kind of problem the first step is to come up with a recurrence. Let <span class="math inline">\(s[0 \dots n-1]\)</span> be the given string, and let <span class="math inline">\(c(i,j)\)</span> be the number of ways to turn the substring <span class="math inline">\(s[i \dots j-1]\)</span> into a properly nested sequence of brackets, so ultimately we want to compute the value of <span class="math inline">\(c(0,n)\)</span>. (Note we make <span class="math inline">\(c(i,j)\)</span> correspond to the substring which includes <span class="math inline">\(i\)</span> but excludes <span class="math inline">\(j\)</span>, which means, for example, that the length of the substring is <span class="math inline">\(j-i\)</span>.) First, some base cases:
</p>
<ul>
<li>
<span class="math inline">\(c(i,i) = 1\)</span> since the empty string always counts as properly nested.
</li>
<li>
<span class="math inline">\(c(i,j) = 0\)</span> if <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> have different parity, since any properly nested string must have even length.
</li>
</ul>
<p>
Otherwise, <span class="math inline">\(s[i]\)</span> had better be an opening bracket of some kind, and we can try matching it with each of <span class="math inline">\(s[i+1]\)</span>, <span class="math inline">\(s[i+3]\)</span>, <span class="math inline">\(s[i+5]\)</span>, …, <span class="math inline">\(s[j-1]\)</span>. In general, matching <span class="math inline">\(s[i]\)</span> with <span class="math inline">\(s[k]\)</span> can be done in either <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, or <span class="math inline">\(3\)</span> ways depending on whether they are proper opening and closing brackets and whether any question marks are involved; then we have <span class="math inline">\(c(i+1,k)\)</span> ways to make the substring between <span class="math inline">\(s[i]\)</span> and <span class="math inline">\(s[k]\)</span> properly nested, and <span class="math inline">\(c(k+1,j)\)</span> ways for the rest of the string following <span class="math inline">\(s[k]\)</span>. These are all independent, so we multiply them. Overall, we get this:
</p>
<p>
<span class="math inline">\(c(i,j) = \begin{cases} 1 &amp;amp; i = j \\ 0 &amp;amp; i \not \equiv j \pmod 2 \\ \displaystyle \sum_{k \in [i+1, i+3, \dots, j-1]} m(s[i], s[k]) \cdot c(i+1,k) \cdot c(k+1,j) &amp;amp; \text{otherwise} \end{cases}\)</span>
</p>
<p>
where <span class="math inline">\(m(x,y)\)</span> counts the number of ways to make <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> into a matching pair of brackets: it returns 0 if the two characters cannot possibly be a matching open-close pair (either because they do not match or because one of them is the wrong way around); 1 if they match, and at most one of them is a question mark; and 3 if both are question marks.
</p>
<p>
How do we come up with such recurrences in the first place? Unfortunately, Haskell doesn’t really make this any easier—it requires some experience and insight. However, what we can say is that Haskell makes it very easy to directly code a recurrence as a recursive function, to play with it and ensure that it gives correct results for small input values.
</p>
<h2 id="a-naive-solution">
A naive solution
</h2>
<p>
To that end, if we directly code up our recurrence in Haskell, we get the following naive solution:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">import</span> <span>Control.Arrow</span>
<span style="color: blue;font-weight: bold">import</span> <span>Data.Array</span>

<span>main</span> <span style="color: red">=</span> <span>interact</span> <span>$</span> <span>lines</span> <span>&gt;&gt;&gt;</span> <span>last</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>format</span>

<span>format</span> <span style="color: red">::</span> <span>Integer</span> <span style="color: red">-&gt;</span> <span>String</span>
<span>format</span> <span style="color: red">=</span> <span>show</span> <span>&gt;&gt;&gt;</span> <span>reverse</span> <span>&gt;&gt;&gt;</span> <span>take</span> <span class="hs-num">5</span> <span>&gt;&gt;&gt;</span> <span>reverse</span>

<span>solve</span> <span style="color: red">::</span> <span>String</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>str</span> <span style="color: red">=</span> <span>c</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>n</span> <span style="color: red">=</span> <span>length</span> <span>str</span>
    <span>s</span> <span style="color: red">=</span> <span>listArray</span> <span style="color: red">(</span><span class="hs-num">0</span><span style="color: red">,</span><span>n</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">)</span> <span>str</span>

    <span>c</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span><span style="color: red">,</span> <span>Int</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Integer</span>
    <span>c</span> <span style="color: red">(</span><span>i</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
      <span style="color: red">|</span> <span>i</span> <span>==</span> <span>j</span>           <span style="color: red">=</span> <span class="hs-num">1</span>
      <span style="color: red">|</span> <span>even</span> <span>i</span> <span>/=</span> <span>even</span> <span>j</span> <span style="color: red">=</span> <span class="hs-num">0</span>
      <span style="color: red">|</span> <span>otherwise</span>        <span style="color: red">=</span> <span>sum</span>
        <span style="color: red">[</span> <span>m</span> <span style="color: red">(</span><span>s</span><span>!</span><span>i</span><span style="color: red">)</span> <span style="color: red">(</span><span>s</span><span>!</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span> <span style="color: red">(</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>k</span><span style="color: red">)</span> <span>*</span> <span>c</span> <span style="color: red">(</span><span>k</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span><span>j</span><span style="color: red">)</span>
        <span style="color: red">|</span> <span>k</span> <span style="color: red">&lt;-</span> <span style="color: red">[</span><span>i</span><span>+</span><span class="hs-num">1</span><span style="color: red">,</span> <span>i</span><span>+</span><span class="hs-num">3</span> <span style="color: red">..</span> <span>j</span><span style="color: green">-</span><span class="hs-num">1</span><span style="color: red">]</span>
        <span style="color: red">]</span>

<span>m</span> <span style="color: teal">'('</span> <span style="color: teal">')'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'['</span> <span style="color: teal">']'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'{'</span> <span style="color: teal">'}'</span>                <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span style="color: teal">'?'</span>                <span style="color: red">=</span> <span class="hs-num">3</span>
<span>m</span> <span>b</span> <span style="color: teal">'?'</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">"([{"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: teal">'?'</span> <span>b</span> <span style="color: red">|</span> <span>b</span> <span>`elem`</span> <span style="color: teal">")]}"</span> <span style="color: red">=</span> <span class="hs-num">1</span>
<span>m</span> <span style="color: blue;font-weight: bold">_</span> <span style="color: blue;font-weight: bold">_</span>                    <span style="color: red">=</span> <span class="hs-num">0</span></code></pre>
<p>
This solution is correct, but much too slow—it passes the first four test cases but then fails with a <em>Time Limit Exceeded</em> error. In fact, it takes exponential time in the length of the input string, because it has a classic case of <a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">overlapping subproblems</a>. Our goal is to compute the same function, but in a way that is actually efficient.
</p>
<h2 id="dynamic-programming-aka-memoizing-recurrences">
Dynamic programming, aka memoizing recurrences
</h2>
<p>
I hate the name “dynamic programming”—it conveys zero information about the thing that it names, and was essentially <a href="https://www.linkedin.com/pulse/origins-name-dynamic-programming-ashwin-rao/">invented as a marketing gimmick</a>. Dynamic programming is really just memoizing recurrences in order to compute them more efficiently. By <em>memoizing</em> we mean caching some kind of mapping from input to output values, so that we only have to compute a function once for each given input value; on subsequent calls with a repeated input we can just look up the corresponding output. There are many, many variations on the theme, but memoizing recurrences is really the heart of it.
</p>
<p>
In imperative languages, dynamic programming is often carried out by filling in tables via nested loops—the fact that there is a <em>recurrence</em> involved is obscured by the implementation. However, in Haskell, our goal will be to write code that is <em>as close as possible</em> to the above naive recursive version, but still actually efficient. Over the next few posts we will discuss several techniques for doing just that.
</p>
<ul>
<li>
In <a href="https://byorgey.wordpress.com/2023/06/02/dynamic-programming-in-haskell-lazy-immutable-arrays/">part 1</a>, we will explore the basic idea of using lazy, recursive, immutable arrays (which we have <a href="https://byorgey.wordpress.com/2023/04/11/competitive-programming-in-haskell-topsort-via-laziness/">already seen in a previous post</a>).
</li>
<li>
In <a href="https://byorgey.wordpress.com/2023/06/06/dynamic-programming-in-haskell-automatic-memoization/">part 2</a>, we will use ideas from Conal Elliot’s <code>MemoTrie</code> package (and ultimately from <a href="https://citeseerx.ist.psu.edu/doc/10.1.1.43.3272">a paper by Ralf Hinze</a>) to clean up the code and make it a lot closer to the naive version.
</li>
<li>
<a href="https://byorgey.wordpress.com/2023/06/20/competitive-programming-in-haskell-two-more-dp-challenges/">This post</a> contains a couple challenge problems that can’t quite be solved using the techniques in the previous posts.
</li>
<li>
At some point perhaps we’ll discuss how to memoize functions with infinite (or just very large) domains.
</li>
<li>
There may very well end up being more parts… we’ll see where it ends up!
</li>
</ul>
<p>
Along the way I’ll also drop more links to relevant background. This will ultimately end up as a chapter in the book I’m slowly writing, and I’d like to make it into the definitive reference on dynamic programming in Haskell—so any thoughts, comments, links, etc. are most welcome!
</p>

]]></description>
    <pubDate>2023-05-31T14:47:46Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/05/31/competitive-programming-in-haskell-introduction-to-dynamic-programming.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive programming in Haskell: parsing with an NFA</title>
    <link>http://byorgey.github.io/blog/posts/2023/05/24/competitive-programming-in-haskell-parsing-with-an-nfa.html</link>
    <description><![CDATA[
<h1>Competitive programming in Haskell: parsing with an NFA</h1>

<div class="info">
  Posted on May 24, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;NFA&#39;." href="/tag/NFA.html" rel="tag">NFA</a>, <a title="All pages tagged &#39;parsing&#39;." href="/tag/parsing.html" rel="tag">parsing</a>
  
</div>

<section>
<p>
In <a href="https://byorgey.wordpress.com/2023/05/03/competitive-programming-in-haskell-tries/">my previous post</a>, I challenged you to solve <a href="https://open.kattis.com/problems/chemistsvows">Chemist’s Vows</a>. In this problem, we have to decide which words can be made by concatenating atomic element symbols. So this is another parsing problem; but unlike the <a href="https://byorgey.wordpress.com/2023/05/03/competitive-programming-in-haskell-tries/">previous problem</a>, element symbols are not prefix-free. For example, <code>B</code> and <code>Be</code> are both element symbols. So, if we see <code>BE…</code>, we don’t immediately know whether we should parse it as <code>Be</code>, or as <code>B</code> followed by an element that starts with <code>E</code> (such as <code>Er</code>).
</p>
<h2 id="a-first-try">
A first try
</h2>
<p>
A parsing problem, eh? Haskell actually shines in this area because of its nice parser combinator libraries. The Kattis environment does in fact have the <code>parsec</code> package available; and even on platforms that don’t have <code>parsec</code>, we can always use the <code>Text.ParserCombinators.ReadP</code> module that comes in <code>base</code>. So let’s try throwing one of those packages at the problem and see what happens!
</p>
<p>
If we try using <code>parsec</code>, we immediately run into problems; honestly, I don’t even know how to solve the problem using <code>parsec</code>. The problem is that <code>&lt;|&gt;</code> represents <em>left-biased</em> choice. If we parse <code>p1 &lt;|&gt; p2</code> and parser <code>p1</code> succeeds, then we will <em>never consider</em> <code>p2</code>. But for this parsing problem, because the symbols are not prefix-free, sometimes we can’t know which of two options we should have picked until later.
</p>
<p>
<code>ReadP</code>, on the other hand, explicitly has both biased and unbiased choice operators, and can return a <em>list of possible parses</em> instead of just a single parse. That sounds promising! Here’s a simple attempt using <code>ReadP</code>: to parse a single element, we use an unbiased <code>choice</code> over all the element names; then we use <code>many parseElement &lt;* eof</code> to parse each word, and check whether there are any successful parses at all.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE OverloadedStrings #-}</span>

<span style="color: blue;font-weight: bold">import</span>           <span>Control.Arrow</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.Bool</span>
<span style="color: blue;font-weight: bold">import</span> <span style="color: blue;font-weight: bold">qualified</span> <span>Data.ByteString.Lazy.Char8</span>   <span style="color: blue;font-weight: bold">as</span> <span>C</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Text.ParserCombinators.ReadP</span> <span style="color: red">(</span><span>ReadP</span><span style="color: red">,</span> <span>choice</span><span style="color: red">,</span> <span>eof</span><span style="color: red">,</span> <span>many</span><span style="color: red">,</span>
                                               <span>readP_to_S</span><span style="color: red">,</span> <span>string</span><span style="color: red">)</span>

<span>main</span> <span style="color: red">=</span> <span>C.interact</span> <span>$</span>
  <span>C.lines</span> <span>&gt;&gt;&gt;</span> <span>drop</span> <span class="hs-num">1</span> <span>&gt;&gt;&gt;</span> <span>map</span> <span style="color: red">(</span><span>solve</span> <span>&gt;&gt;&gt;</span> <span>bool</span> <span style="color: teal">"NO"</span> <span style="color: teal">"YES"</span><span style="color: red">)</span> <span>&gt;&gt;&gt;</span> <span>C.unlines</span>

<span>solve</span> <span style="color: red">::</span> <span>C.ByteString</span> <span style="color: red">-&gt;</span> <span>Bool</span>
<span>solve</span> <span>s</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">case</span> <span>readP_to_S</span> <span style="color: red">(</span><span>many</span> <span>parseElement</span> <span>&lt;*</span> <span>eof</span><span style="color: red">)</span> <span style="color: red">(</span><span>C.unpack</span> <span>s</span><span style="color: red">)</span> <span style="color: blue;font-weight: bold">of</span>
  <span>[]</span> <span style="color: red">-&gt;</span> <span>False</span>
  <span style="color: blue;font-weight: bold">_</span>  <span style="color: red">-&gt;</span> <span>True</span>

<span>elements</span> <span style="color: red">::</span> <span style="color: red">[</span><span>String</span><span style="color: red">]</span>
<span>elements</span> <span style="color: red">=</span> <span>words</span> <span>$</span>
  <span style="color: teal">"h he li be b c n o f ne na mg al si p s cl ar k ca sc ti v cr mn fe co ni cu zn ga ge as se br kr rb sr y zr nb mo tc ru rh pd ag cd in sn sb te i xe cs ba hf ta w re os ir pt au hg tl pb bi po at rn fr ra rf db sg bh hs mt ds rg cn fl lv la ce pr nd pm sm eu gd tb dy ho er tm yb lu ac th pa u np pu am cm bk cf es fm md no lr"</span>

<span>parseElement</span> <span style="color: red">::</span> <span>ReadP</span> <span>String</span>
<span>parseElement</span> <span style="color: red">=</span> <span>choice</span> <span style="color: red">(</span><span>map</span> <span>string</span> <span>elements</span><span style="color: red">)</span></code></pre>
<p>
Unfortunately, this fails with a <em>Time Limit Exceeded</em> error (it takes longer than the allotted 5 seconds). The problem is that backtracking and trying every possible parse like this is super inefficient. One of the secret test inputs is almost cerainly constructed so that there are an exponential number of ways to parse some <em>prefix</em> of the input, but no way to parse the entire thing. As a simple example, the string <code>crf</code> can be parsed as either <code>c rf</code> (carbon + rutherfordium) or <code>cr f</code> (chromium + fluorine), so by repeating <code>crf</code> <span class="math inline">\(n\)</span> times we can make a string of length <span class="math inline">\(3n\)</span> which has <span class="math inline">\(2^n\)</span> different parses. If we fed this string to the <code>ReadP</code> solution above, it would quickly succeed with more or less the first thing that it tried. However, if we stick a letter on the end that does not occur in any element symbol (such as <code>q</code>), the result will be an unparseable string, and the <code>ReadP</code> solution will spend a very long time backtracking through exponentially many parses that all ultimately fail.
</p>
<h2 id="solution">
Solution
</h2>
<p>
The key insight is that we don’t really care about all the different possible parses; we only care whether the given string is parseable at all. At any given point in the string, there are only two possible states we could be in: we could be finished reading one element symbol and about to start reading the next one, or we could be in the middle of reading a two-letter element symbol. We can just scan through the string and keep track of the set of (at most two) possible states; in other words, we will simulate an <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">NFA</a> which accepts the language of strings composed of element symbols.
</p>
<p>
First, some setup as before.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">{-# LANGUAGE OverloadedStrings #-}</span>

<span style="color: blue;font-weight: bold">import</span>           <span>Control.Arrow</span>              <span style="color: red">(</span><span style="color: red">(</span><span>&gt;&gt;&gt;</span><span style="color: red">)</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.Array</span>                 <span style="color: red">(</span><span>Array</span><span style="color: red">,</span> <span>accumArray</span><span style="color: red">,</span> <span style="color: red">(</span><span>!</span><span style="color: red">)</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.Bool</span>                  <span style="color: red">(</span><span>bool</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span style="color: blue;font-weight: bold">qualified</span> <span>Data.ByteString.Lazy.Char8</span> <span style="color: blue;font-weight: bold">as</span> <span>C</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.List</span>                  <span style="color: red">(</span><span>partition</span><span style="color: red">,</span> <span>nub</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.Set</span>                   <span style="color: red">(</span><span>Set</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span style="color: blue;font-weight: bold">qualified</span> <span>Data.Set</span>                   <span style="color: blue;font-weight: bold">as</span> <span>S</span>

<span>main</span> <span style="color: red">=</span> <span>C.interact</span> <span>$</span>
  <span>C.lines</span> <span>&gt;&gt;&gt;</span> <span>drop</span> <span class="hs-num">1</span> <span>&gt;&gt;&gt;</span> <span>map</span> <span style="color: red">(</span><span>solve</span> <span>&gt;&gt;&gt;</span> <span>bool</span> <span style="color: teal">"NO"</span> <span style="color: teal">"YES"</span><span style="color: red">)</span> <span>&gt;&gt;&gt;</span> <span>C.unlines</span>

<span>elements</span> <span style="color: red">::</span> <span style="color: red">[</span><span>String</span><span style="color: red">]</span>
<span>elements</span> <span style="color: red">=</span> <span>words</span> <span>$</span>
  <span style="color: teal">"h he li be b c n o f ne na mg al si p s cl ar k ca sc ti v cr mn
fe co ni cu zn ga ge as se br kr rb sr y zr nb mo tc ru rh pd ag cd
in sn sb te i xe cs ba hf ta w re os ir pt au hg tl pb bi po at rn
fr ra rf db sg bh hs mt ds rg cn fl lv la ce pr nd pm sm eu gd tb dy
ho er tm yb lu ac th pa u np pu am cm bk cf es fm md no lr"</span></code></pre>
<p>
Now, let’s split the element symbols into one-letter and two-letter symbols:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>singles</span><span style="color: red">,</span> <span>doubles</span> <span style="color: red">::</span> <span style="color: red">[</span><span>String</span><span style="color: red">]</span>
<span style="color: red">(</span><span>singles</span><span style="color: red">,</span> <span>doubles</span><span style="color: red">)</span> <span style="color: red">=</span> <span>partition</span> <span style="color: red">(</span><span style="color: red">(</span><span>==</span><span class="hs-num">1</span><span style="color: red">)</span><span>.</span><span>length</span><span style="color: red">)</span> <span>elements</span></code></pre>
<p>
We can now make boolean lookup arrays that tell us whether a given letter occurs as a single-letter element symbol (<code>single</code>) and whether a given letter occurs as the first letter of a two-letter symbol (<code>lead</code>). We also make a <code>Set</code> of all two-letter element symbols, for fast lookup.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>mkAlphaArray</span> <span style="color: red">::</span> <span style="color: red">[</span><span>Char</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Array</span> <span>Char</span> <span>Bool</span>
<span>mkAlphaArray</span> <span>cs</span> <span style="color: red">=</span> <span>accumArray</span> <span style="color: red">(</span><span>||</span><span style="color: red">)</span> <span>False</span> <span style="color: red">(</span><span style="color: teal">'a'</span><span style="color: red">,</span> <span style="color: teal">'z'</span><span style="color: red">)</span> <span style="color: red">(</span><span>zip</span> <span>cs</span> <span style="color: red">(</span><span>repeat</span> <span>True</span><span style="color: red">)</span><span style="color: red">)</span>

<span>single</span><span style="color: red">,</span> <span>lead</span> <span style="color: red">::</span> <span>Array</span> <span>Char</span> <span>Bool</span>
<span style="color: red">[</span><span>single</span><span style="color: red">,</span> <span>lead</span><span style="color: red">]</span> <span style="color: red">=</span> <span>map</span> <span style="color: red">(</span><span>mkAlphaArray</span> <span>.</span> <span>map</span> <span>head</span><span style="color: red">)</span> <span style="color: red">[</span><span>singles</span><span style="color: red">,</span> <span>doubles</span><span style="color: red">]</span>

<span>doubleSet</span> <span style="color: red">::</span> <span>Set</span> <span>String</span>
<span>doubleSet</span> <span style="color: red">=</span> <span>S.fromList</span> <span>doubles</span></code></pre>
<p>
Now for simulating the NFA itself. There are two states we can be in: <code>START</code> means we are about to start and/or have just finished reading an element symbol; <code>SEEN c</code> means we have seen the first character of some element (<code>c</code>) and are waiting to see another.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">data</span> <span>State</span> <span style="color: red">=</span> <span>START</span> <span style="color: red">|</span> <span>SEEN</span> <span>Char</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span style="color: red">(</span><span>Eq</span><span style="color: red">,</span> <span>Ord</span><span style="color: red">,</span> <span>Show</span><span style="color: red">)</span></code></pre>
<p>
Our transition function takes a character <code>c</code> and a state and returns a set of all possible next states (we just use a list since these sets will be very small). If we are in the <code>START</code> state, we could end up in the <code>START</code> state again if <code>c</code> is a single-letter element symbol; we could also end up in the <code>SEEN c</code> state if <code>c</code> is the first letter of any two-letter element symbol. On the other hand, if we are in the <code>SEEN x</code> state, then we have to check whether <code>xc</code> is a valid element symbol; if so, we return to <code>START</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>delta</span> <span style="color: red">::</span> <span>Char</span> <span style="color: red">-&gt;</span> <span>State</span> <span style="color: red">-&gt;</span> <span style="color: red">[</span><span>State</span><span style="color: red">]</span>
<span>delta</span> <span>c</span> <span>START</span>    <span style="color: red">=</span> <span style="color: red">[</span><span>START</span> <span style="color: red">|</span> <span>single</span><span>!</span><span>c</span><span style="color: red">]</span> <span>++</span> <span style="color: red">[</span><span>SEEN</span> <span>c</span> <span style="color: red">|</span> <span>lead</span><span>!</span><span>c</span><span style="color: red">]</span>
<span>delta</span> <span>c</span> <span style="color: red">(</span><span>SEEN</span> <span>x</span><span style="color: red">)</span> <span style="color: red">=</span> <span style="color: red">[</span><span>START</span> <span style="color: red">|</span> <span style="color: red">[</span><span>x</span><span style="color: red">,</span><span>c</span><span style="color: red">]</span> <span>`S.member`</span> <span>doubleSet</span><span style="color: red">]</span></code></pre>
<p>
We can now extend <code>delta</code> to act on a set of states, giving us the set of all possible resulting states; the <code>drive</code> function then iterates this one-letter transition over an entire input string. Finally, to solve the problem, we start with the singleton set <code>[START]</code>, call <code>drive</code> using the input string, and check whether <code>START</code> (which is also the only accepting state) is an element of the resulting set of states.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>trans</span> <span style="color: red">::</span> <span>Char</span> <span style="color: red">-&gt;</span> <span style="color: red">[</span><span>State</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span style="color: red">[</span><span>State</span><span style="color: red">]</span>
<span>trans</span> <span>c</span> <span>sts</span> <span style="color: red">=</span> <span>nub</span> <span style="color: red">(</span><span>sts</span> <span>&gt;&gt;=</span> <span>delta</span> <span>c</span><span style="color: red">)</span>

<span>drive</span> <span style="color: red">::</span> <span>C.ByteString</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span style="color: red">[</span><span>State</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span style="color: red">[</span><span>State</span><span style="color: red">]</span><span style="color: red">)</span>
<span>drive</span> <span style="color: red">=</span> <span>C.foldr</span> <span style="color: red">(</span><span style="color: red">\</span><span>c</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>trans</span> <span>c</span> <span>&gt;&gt;&gt;</span><span style="color: red">)</span><span style="color: red">)</span> <span>id</span>

<span>solve</span> <span style="color: red">::</span> <span>C.ByteString</span> <span style="color: red">-&gt;</span> <span>Bool</span>
<span>solve</span> <span>s</span> <span style="color: red">=</span> <span>START</span> <span>`elem`</span> <span>drive</span> <span>s</span> <span style="color: red">[</span><span>START</span><span style="color: red">]</span></code></pre>
<p>
And that’s it! This solution is accepted in 0.27 seconds (out of a maximum allowed 5 seconds).
</p>
<h2 id="for-next-time">
For next time
</h2>
<ul>
<li>
If you want to practice the concepts from my past couple posts, give <a href="https://open.kattis.com/problems/haiku">Haiku</a> a try.
</li>
<li>
For my next post, I challenge you to solve <a href="https://open.kattis.com/problems/zapis">Zapis</a>!
</li>
</ul>

]]></description>
    <pubDate>2023-05-24T11:03:02Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/05/24/competitive-programming-in-haskell-parsing-with-an-nfa.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>New ko-fi page: help me attend ICFP!</title>
    <link>http://byorgey.github.io/blog/posts/2023/05/22/new-ko-fi-page-help-me-attend-icfp.html</link>
    <description><![CDATA[
<h1>New ko-fi page: help me attend ICFP!</h1>

<div class="info">
  Posted on May 22, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;community&#39;." href="/tag/community.html" rel="tag">community</a>, <a title="All pages tagged &#39;contribution&#39;." href="/tag/contribution.html" rel="tag">contribution</a>, <a title="All pages tagged &#39;ICFP&#39;." href="/tag/ICFP.html" rel="tag">ICFP</a>, <a title="All pages tagged &#39;ko-fi&#39;." href="/tag/ko-fi.html" rel="tag">ko-fi</a>, <a title="All pages tagged &#39;open-source&#39;." href="/tag/open-source.html" rel="tag">open-source</a>, <a title="All pages tagged &#39;tips&#39;." href="/tag/tips.html" rel="tag">tips</a>
  
</div>

<section>
<p>
<strong>tl;dr</strong>: if you appreciate my past or ongoing contributions to the Haskell community, please consider helping me get to ICFP by <a href="https://ko-fi.com/byorgey">donating via my new ko-fi page</a>!
</p>
<div style="text-align: center">
<p><a href="https://ko-fi.com/I3I5KYUQX"><img src="https://ko-fi.com/img/githubbutton_sm.svg" alt="ko-fi" /></a></p>
</div>
<p>
<br />
</p>
<p>
Working at a <a href="https://www.hendrix.edu/">small liberal arts institution</a> has some tremendous benefits (close interaction with motivated students, freedom to pursue the projects I want rather than jump through a bunch of hoops to get tenure, fantastic colleagues), and I love my job. But there are also downsides; the biggest ones for me are the difficulty of securing enough travel funding, and, relatedly, the difficulty of cultivating and maintaining collaborations.
</p>
<p>
I would really like to be able to attend <a href="https://icfp23.sigplan.org/">ICFP in Seattle this September</a>; the last time I was able to attend ICFP in person was 2019 in Berlin. With transportation, lodging, food, and registration fees, it will probably come to about $3000. I can get a grant from my instutition to pay for up to $1200, but that still leaves a big gap.
</p>
<p>
As I was brainstorming other sources of funding, it dawned on me that there are probably many people who have been positively impacted by my contributions to the Haskell community (<em>e.g.</em> <a href="https://www.cis.upenn.edu/~cis1940/spring13/">CIS 194</a>, the <a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>, <a href="https://diagrams.github.io/">diagrams</a>, <a href="https://hackage.haskell.org/package/split">split</a>, <a href="https://hackage.haskell.org/package/MonadRandom">MonadRandom</a>, <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">burrito metaphors</a>…) and/or would like to support my ongoing work (<a href="https://byorgey.wordpress.com/category/competitive-programming/">competitive programming in Haskell</a>, <a href="https://github.com/swarm-game/swarm/#readme">swarm</a>, <a href="https://github.com/disco-lang/disco/#readme">disco</a>, <a href="https://hackage.haskell.org/user/BrentYorgey">ongoing package maintenance</a>…) and would be happy to donate a bit.
</p>
<p>
So, to that end, I have set up a <a href="https://ko-fi.com/byorgey">ko-fi page</a>.
</p>
<ul>
<li>
<p>
If you have been positively impacted by my contributions and would like to help me get to ICFP this fall, one-time donations — even very small amounts — are greatly appreciated! I’m not going to promise any particular rewards, but if you’re at ICFP I will definitely find you to say thanks!
</p>
</li>
<li>
<p>
Thinking beyond this fall, ideally this could even become a reliable source of funding to help me travel to ICFP or other collaboration opportunities every year. To that end, if you’re willing to sign up for a recurring monthly donation, that would be amazing — think of it as supporting my ongoing work: <a href="https://byorgey.wordpress.com/category/competitive-programming/">blog posts</a> (and <a href="https://github.com/byorgey/cpih">book</a>) on competitive programming in Haskell, <a href="https://github.com/swarm-game/swarm/#readme">Swarm</a> and <a href="https://github.com/disco-lang/disco/#readme">Disco</a> development, and <a href="https://hackage.haskell.org/user/BrentYorgey">ongoing package maintenance</a>. I will <a href="https://ko-fi.com/byorgey/posts">post updates on ko-fi</a> with things I’m thinking about and working on; I am also going to try to publish more frequent blog posts, at least in the near term.
</p>
</li>
</ul>
<p>
Thank you, friends — I hope to see many people in Seattle! Next up: back to your regularly scheduled competitive programming!
</p>

]]></description>
    <pubDate>2023-05-22T19:27:30Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/05/22/new-ko-fi-page-help-me-attend-icfp.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>
<item>
    <title>Competitive programming in Haskell: tries</title>
    <link>http://byorgey.github.io/blog/posts/2023/05/03/competitive-programming-in-haskell-tries.html</link>
    <description><![CDATA[
<h1>Competitive programming in Haskell: tries</h1>

<div class="info">
  Posted on May  3, 2023
  
  
  <br />
  Tagged <a title="All pages tagged &#39;challenge&#39;." href="/tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged &#39;Kattis&#39;." href="/tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged &#39;trie&#39;." href="/tag/trie.html" rel="tag">trie</a>
  
</div>

<section>
<p>
In <a href="https://byorgey.wordpress.com/2023/04/11/competitive-programming-in-haskell-topsort-via-laziness/">my previous post</a>, I challenged you to solve <a href="https://open.kattis.com/problems/alienmath">Alien Math</a>, which is about reading numbers in some base <span class="math inline">\(B\)</span>, but with a twist. We are given a list of <span class="math inline">\(B\)</span> strings representing the <em>names</em> of the digits <span class="math inline">\(0\)</span> through <span class="math inline">\(B-1\)</span>, and a single string describing a number, consisting of <em>concatenated</em> digit names. For example, if <span class="math inline">\(B = 3\)</span> and the names of the digits are <code>zero</code>, <code>one</code>, <code>two</code>, then we might be given a string like <code>twotwozerotwoone</code>, which we should interpret as <span class="math inline">\(22021_3 = 223_{10}\)</span>. Crucially, we are also told that the digit names are <em>prefix-free</em>, that is, no digit name is a prefix of any other. But other than that, the digit names could be really weird: they could be very different lengths, some digit names could occur as substrings (just not prefixes) of others, digit names could share common prefixes, and so on. So this is really more of a <em>parsing</em> problem than a math problem; once we have parsed the string as a list of digits, converting from base <span class="math inline">\(B\)</span> is the easy part.
</p>
<p>
One simple way we can do this is to define a map from digit names to digits, and simply look up each prefix of the given string until we find a hit, then chop off that prefix and start looking at successive prefixes of the remainder. This takes something like <span class="math inline">\(O(n^2 \lg n)\)</span> time in the worst case (I think)—but this is actually fine since <span class="math inline">\(n\)</span> is at most 300. This solution is accepted and runs in 0.00 seconds for me.
</p>
<h2 id="tries">
Tries
</h2>
<p>
However, I want to talk about a more sophisticated solution that has better asymptotic time complexity and generalizes nicely to other problems. Reading a sequence of strings from a prefix-free set should make you think of <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a>, if you’ve ever seen that before. In general, the idea is to define a <a href="https://en.wikipedia.org/wiki/Trie">trie</a> containing all the digit names, with each leaf storing the corresponding digit. We can then scan through the input one character at a time, keeping track of our current position in trie, and emit a digit (and restart at the root) every time we reach a leaf. This should run in <span class="math inline">\(O(n)\)</span> time.
</p>
<p>
Let’s see some generic Haskell code for tries (this code can also be found at <a href="https://github.com/byorgey/comprog-hs/blob/master/Trie.hs">byorgey/comprog-hs/Trie.hs</a> on GitHub). First, some imports, a data type definition, and <code>emptyTrie</code> and <code>foldTrie</code> for convenience:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">module</span> <span>Trie</span> <span style="color: blue;font-weight: bold">where</span>

<span style="color: blue;font-weight: bold">import</span>           <span>Control.Monad</span>              <span style="color: red">(</span><span style="color: red">(</span><span>&gt;=&gt;</span><span style="color: red">)</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span style="color: blue;font-weight: bold">qualified</span> <span>Data.ByteString.Lazy.Char8</span> <span style="color: blue;font-weight: bold">as</span> <span>C</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.List</span>                  <span style="color: red">(</span><span>foldl'</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.Map</span>                   <span style="color: red">(</span><span>Map</span><span style="color: red">,</span> <span style="color: red">(</span><span>!</span><span style="color: red">)</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span style="color: blue;font-weight: bold">qualified</span> <span>Data.Map</span>                   <span style="color: blue;font-weight: bold">as</span> <span>M</span>
<span style="color: blue;font-weight: bold">import</span>           <span>Data.Maybe</span>                 <span style="color: red">(</span><span>fromMaybe</span><span style="color: red">)</span>

<span style="color: blue;font-weight: bold">data</span> <span>Trie</span> <span>a</span> <span style="color: red">=</span> <span>Trie</span>
  <span style="color: red">{</span> <span>trieSize</span> <span style="color: red">::</span> <span>!</span><span>Int</span>
  <span style="color: red">,</span> <span>value</span>    <span style="color: red">::</span> <span>!</span><span style="color: red">(</span><span>Maybe</span> <span>a</span><span style="color: red">)</span>
  <span style="color: red">,</span> <span>children</span> <span style="color: red">::</span> <span>!</span><span style="color: red">(</span><span>Map</span> <span>Char</span> <span style="color: red">(</span><span>Trie</span> <span>a</span><span style="color: red">)</span><span style="color: red">)</span>
  <span style="color: red">}</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span>Show</span>

<span>emptyTrie</span> <span style="color: red">::</span> <span>Trie</span> <span>a</span>
<span>emptyTrie</span> <span style="color: red">=</span> <span>Trie</span> <span class="hs-num">0</span> <span>Nothing</span> <span>M.empty</span>

<span style="color: green">-- | Fold a trie into a summary value.</span>
<span>foldTrie</span> <span style="color: red">::</span> <span style="color: red">(</span><span>Int</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Map</span> <span>Char</span> <span>r</span> <span style="color: red">-&gt;</span> <span>r</span><span style="color: red">)</span> <span style="color: red">-&gt;</span> <span>Trie</span> <span>a</span> <span style="color: red">-&gt;</span> <span>r</span>
<span>foldTrie</span> <span>f</span> <span style="color: red">(</span><span>Trie</span> <span>n</span> <span>b</span> <span>m</span><span style="color: red">)</span> <span style="color: red">=</span> <span>f</span> <span>n</span> <span>b</span> <span style="color: red">(</span><span>M.map</span> <span style="color: red">(</span><span>foldTrie</span> <span>f</span><span style="color: red">)</span> <span>m</span><span style="color: red">)</span></code></pre>
<p>
A trie has a cached size (we could easily generalize this to store any sort of monoidal annotation), a possible value (<em>i.e.</em> the value associated with the empty string key, if any), and a map from characters to child tries. The cached size is not needed for this problem, but is included since I needed it for some other problems.
</p>
<p>
Now for inserting a key/value pair into a <code>Trie</code>. This code honestly took me a while to get right! We fold over the given string key, producing for each key suffix a <em>function</em> which will insert that key suffix into a trie. We have to be careful to correctly update the size, which depends on whether the key being inserted already exists—so the recursive <code>go</code> function actually returns a pair of a new <code>Trie</code> and an <code>Int</code> representing the change in size.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">-- | Insert a new key/value pair into a trie, updating the size</span>
<span style="color: green">--   appropriately.</span>
<span>insert</span> <span style="color: red">::</span> <span>C.ByteString</span> <span style="color: red">-&gt;</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Trie</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Trie</span> <span>a</span>
<span>insert</span> <span>w</span> <span>a</span> <span>t</span> <span style="color: red">=</span> <span>fst</span> <span style="color: red">(</span><span>go</span> <span>w</span> <span>t</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>go</span> <span style="color: red">=</span> <span>C.foldr</span>
      <span style="color: red">(</span><span style="color: red">\</span><span>c</span> <span>insSuffix</span> <span style="color: red">(</span><span>Trie</span> <span>n</span> <span>v</span> <span>m</span><span style="color: red">)</span> <span style="color: red">-&gt;</span>
         <span style="color: blue;font-weight: bold">let</span> <span style="color: red">(</span><span>t'</span><span style="color: red">,</span> <span>ds</span><span style="color: red">)</span> <span style="color: red">=</span> <span>insSuffix</span> <span style="color: red">(</span><span>fromMaybe</span> <span>emptyTrie</span> <span style="color: red">(</span><span>M.lookup</span> <span>c</span> <span>m</span><span style="color: red">)</span><span style="color: red">)</span>
         <span style="color: blue;font-weight: bold">in</span>  <span style="color: red">(</span><span>Trie</span> <span style="color: red">(</span><span>n</span><span>+</span><span>ds</span><span style="color: red">)</span> <span>v</span> <span style="color: red">(</span><span>M.insert</span> <span>c</span> <span>t'</span> <span>m</span><span style="color: red">)</span><span style="color: red">,</span> <span>ds</span><span style="color: red">)</span>
      <span style="color: red">)</span>
      <span style="color: red">(</span><span style="color: red">\</span><span style="color: red">(</span><span>Trie</span> <span>n</span> <span>v</span> <span>m</span><span style="color: red">)</span> <span style="color: red">-&gt;</span>
         <span style="color: blue;font-weight: bold">let</span> <span>ds</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">if</span> <span>isJust</span> <span>v</span> <span style="color: blue;font-weight: bold">then</span> <span class="hs-num">0</span> <span style="color: blue;font-weight: bold">else</span> <span class="hs-num">1</span>
         <span style="color: blue;font-weight: bold">in</span>  <span style="color: red">(</span><span>Trie</span> <span style="color: red">(</span><span>n</span><span>+</span><span>ds</span><span style="color: red">)</span> <span style="color: red">(</span><span>Just</span> <span>a</span><span style="color: red">)</span> <span>m</span><span style="color: red">,</span> <span>ds</span><span style="color: red">)</span>
      <span style="color: red">)</span></code></pre>
<p>
Now we can create an entire <code>Trie</code> in one go by folding over a list of key/value pairs with <code>insert</code>:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">-- | Create an initial trie from a list of key/value pairs.  If there</span>
<span style="color: green">--   are multiple pairs with the same key, later pairs override</span>
<span style="color: green">--   earlier ones.</span>
<span>mkTrie</span> <span style="color: red">::</span> <span style="color: red">[</span><span style="color: red">(</span><span>C.ByteString</span><span style="color: red">,</span> <span>a</span><span style="color: red">)</span><span style="color: red">]</span> <span style="color: red">-&gt;</span> <span>Trie</span> <span>a</span>
<span>mkTrie</span> <span style="color: red">=</span> <span>foldl'</span> <span style="color: red">(</span><span>flip</span> <span style="color: red">(</span><span>uncurry</span> <span>insert</span><span style="color: red">)</span><span style="color: red">)</span> <span>emptyTrie</span></code></pre>
<p>
A few lookup functions: one to look up a single character and return the corresponding child trie, and then on top of that we can build one to look up the value associated to an entire string key.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green">-- | Look up a single character in a trie, returning the corresponding</span>
<span style="color: green">--   child trie (if any).</span>
<span>lookup1</span> <span style="color: red">::</span> <span>Char</span> <span style="color: red">-&gt;</span> <span>Trie</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span style="color: red">(</span><span>Trie</span> <span>a</span><span style="color: red">)</span>
<span>lookup1</span> <span>c</span> <span style="color: red">=</span> <span>M.lookup</span> <span>c</span> <span>.</span> <span>children</span>

<span style="color: green">-- | Look up a string key in a trie, returning the corresponding value</span>
<span style="color: green">--   (if any).</span>
<span>lookup</span> <span style="color: red">::</span> <span>C.ByteString</span> <span style="color: red">-&gt;</span> <span>Trie</span> <span>a</span> <span style="color: red">-&gt;</span> <span>Maybe</span> <span>a</span>
<span>lookup</span> <span style="color: red">=</span> <span>C.foldr</span> <span style="color: red">(</span><span style="color: red">(</span><span>&gt;=&gt;</span><span style="color: red">)</span> <span>.</span> <span>lookup1</span><span style="color: red">)</span> <span>value</span></code></pre>
<p>
Finally, a function that often comes in handy for using a trie to decode a prefix-free code. It takes an input string and looks it up character by character; every time it encounters a key which exists in the trie, it emits the corresponding value and then starts over at the root of the trie.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>decode</span> <span style="color: red">::</span> <span>Trie</span> <span>a</span> <span style="color: red">-&gt;</span> <span>C.ByteString</span> <span style="color: red">-&gt;</span> <span style="color: red">[</span><span>a</span><span style="color: red">]</span>
<span>decode</span> <span>t</span> <span style="color: red">=</span> <span>reverse</span> <span>.</span> <span>snd</span> <span>.</span> <span>C.foldl'</span> <span>step</span> <span style="color: red">(</span><span>t</span><span style="color: red">,</span> <span>[]</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>step</span> <span style="color: red">(</span><span>s</span><span style="color: red">,</span> <span style="color: blue;font-weight: bold">as</span><span style="color: red">)</span> <span>c</span> <span style="color: red">=</span>
      <span style="color: blue;font-weight: bold">let</span> <span>Just</span> <span>s'</span> <span style="color: red">=</span> <span>lookup1</span> <span>c</span> <span>s</span>
      <span style="color: blue;font-weight: bold">in</span>  <span>maybe</span> <span style="color: red">(</span><span>s'</span><span style="color: red">,</span> <span style="color: blue;font-weight: bold">as</span><span style="color: red">)</span> <span style="color: red">(</span><span style="color: red">\</span><span>a</span> <span style="color: red">-&gt;</span> <span style="color: red">(</span><span>t</span><span style="color: red">,</span> <span>a</span><span>:</span><span style="color: blue;font-weight: bold">as</span><span style="color: red">)</span><span style="color: red">)</span> <span style="color: red">(</span><span>value</span> <span>s'</span><span style="color: red">)</span></code></pre>
<p>
These tries are limited to string keys, since that is most useful in a competitive programming context, but it is of course possible to make much more general sorts of tries — see <a href="https://www.cs.ox.ac.uk/ralf.hinze/publications/GGTries/index.html">Hinze, <em>Generalizing Generalized Tries</em></a>.
</p>
<h2 id="solution">
Solution
</h2>
<p>
Finally, we can use our generic tries to solve the problem: read the input, build a trie mapping digit names to values, use the <code>decode</code> function to read the given number, and finally interpret the resulting list of digits in the given base.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue;font-weight: bold">import</span> <span>Control.Arrow</span> <span style="color: red">(</span><span style="color: red">(</span><span>&gt;&gt;&gt;</span><span style="color: red">)</span><span style="color: red">)</span>
<span style="color: blue;font-weight: bold">import</span> <span>ScannerBS</span>
<span style="color: blue;font-weight: bold">import</span> <span>Trie</span>

<span>main</span> <span style="color: red">=</span> <span>C.interact</span> <span>$</span> <span>runScanner</span> <span>tc</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>showB</span>

<span style="color: blue;font-weight: bold">data</span> <span>TC</span> <span style="color: red">=</span> <span>TC</span> <span style="color: red">{</span> <span>base</span> <span style="color: red">::</span> <span>Integer</span><span style="color: red">,</span> <span>digits</span> <span style="color: red">::</span> <span style="color: red">[</span><span>C.ByteString</span><span style="color: red">]</span><span style="color: red">,</span> <span>number</span> <span style="color: red">::</span> <span>C.ByteString</span> <span style="color: red">}</span>
  <span style="color: blue;font-weight: bold">deriving</span> <span style="color: red">(</span><span>Eq</span><span style="color: red">,</span> <span>Show</span><span style="color: red">)</span>

<span>tc</span> <span style="color: red">::</span> <span>Scanner</span> <span>TC</span>
<span>tc</span> <span style="color: red">=</span> <span style="color: blue;font-weight: bold">do</span>
  <span>base</span> <span style="color: red">&lt;-</span> <span>integer</span>
  <span>TC</span> <span>base</span> <span>&lt;$&gt;</span> <span style="color: red">(</span><span>fromIntegral</span> <span>base</span> <span>&gt;&lt;</span> <span>str</span><span style="color: red">)</span> <span>&lt;*&gt;</span> <span>str</span>

<span>solve</span> <span style="color: red">::</span> <span>TC</span> <span style="color: red">-&gt;</span> <span>Integer</span>
<span>solve</span> <span>TC</span><span style="color: red">{</span><span style="color: red">..</span><span style="color: red">}</span> <span style="color: red">=</span> <span>foldl'</span> <span style="color: red">(</span><span style="color: red">\</span><span>n</span> <span>d</span> <span style="color: red">-&gt;</span> <span>n</span><span>*</span><span>base</span> <span>+</span> <span>d</span><span style="color: red">)</span> <span class="hs-num">0</span> <span style="color: red">(</span><span>decode</span> <span>t</span> <span>number</span><span style="color: red">)</span>
  <span style="color: blue;font-weight: bold">where</span>
    <span>t</span> <span style="color: red">=</span> <span>mkTrie</span> <span style="color: red">(</span><span>zip</span> <span>digits</span> <span style="color: red">[</span><span class="hs-num">0</span> <span style="color: red">::</span> <span>Integer</span> <span style="color: red">..</span><span style="color: red">]</span><span style="color: red">)</span>
</code></pre>
<h2 id="practice-problems">
Practice problems
</h2>
<p>
Here are a few other problems where you can profitably make use of tries. Some of these can be solved directly using the <code>Trie</code> code given above; others may require some modifications or enhancements to the basic concept.
</p>
<ul>
<li>
<a href="https://open.kattis.com/problems/baza">Baza</a>
</li>
<li>
<a href="https://open.kattis.com/problems/prefixfreecode">Prefix Free Code</a>
</li>
<li>
<a href="https://open.kattis.com/problems/haiku">Haiku</a>
</li>
</ul>
<h2 id="for-next-time">
For next time
</h2>
<p>
For next time, I challenge you to solve <a href="https://open.kattis.com/problems/chemistsvows">Chemist’s vows</a>!
</p>

]]></description>
    <pubDate>2023-05-03T19:57:58Z</pubDate>
    <guid>http://byorgey.github.io/blog/posts/2023/05/03/competitive-programming-in-haskell-tries.html</guid>
    <dc:creator>Brent Yorgey</dc:creator>
</item>

    </channel>
</rss>
