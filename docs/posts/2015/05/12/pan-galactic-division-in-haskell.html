<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>blog :: Brent -> [String] - Pan-Galactic Division in Haskell</title>
        <!-- <link rel="stylesheet" type="text/css" href="/css/default.css" /> -->
        <link rel="stylesheet" type="text/css" href="../../../../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../../../../css/tufte.css" />

        <!-- See https://katex.org/docs/browser -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
        <link rel="alternate" type="application/rss+xml" href="../../../../rss.xml" title="RSS Feed">

        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../../../../">Home</a> •
                <a href="../../../../about.html">About</a> •
                <a href="../../../../rss.xml">RSS</a> •
                <a href="../../../../posts/blogliterately.html">BlogLiterately</a> •
                <a href="../../../../posts/catsters-guide-2.html">Catsters Guide</a> •
                <a href="../../../../posts/how-to-print-things.html">How To Print Things</a>
            </div>
        </div>

        <article>
          
<a href="../../../../posts/2015/04/14/polynomial-functors-constrained-by-regular-expressions.html">« Polynomial Functors Constrained by Regular Expressions</a>


<span style="margin-left: 2em">

<a href="../../../../posts/2015/05/26/thoughts-on-grade-inflation-part-i-is-grade-inflation-bad.html">» Thoughts on grade inflation, part I: is grade inflation bad?</a>

</span>


<h1>Pan-Galactic Division in Haskell</h1>

<div class="info">
  Posted on May 12, 2015
  
  
  <br />
  Tagged <a title="All pages tagged 'bijection'." href="../../../../tag/bijection.html" rel="tag">bijection</a>, <a title="All pages tagged 'card'." href="../../../../tag/card.html" rel="tag">card</a>, <a title="All pages tagged 'combinatorics'." href="../../../../tag/combinatorics.html" rel="tag">combinatorics</a>, <a title="All pages tagged 'division'." href="../../../../tag/division.html" rel="tag">division</a>, <a title="All pages tagged 'Doyle'." href="../../../../tag/Doyle.html" rel="tag">Doyle</a>, <a title="All pages tagged 'game'." href="../../../../tag/game.html" rel="tag">game</a>, <a title="All pages tagged 'injection'." href="../../../../tag/injection.html" rel="tag">injection</a>, <a title="All pages tagged 'proof'." href="../../../../tag/proof.html" rel="tag">proof</a>, <a title="All pages tagged 'Qiu'." href="../../../../tag/Qiu.html" rel="tag">Qiu</a>, <a title="All pages tagged 'Schwartz'." href="../../../../tag/Schwartz.html" rel="tag">Schwartz</a>
  
</div>

<section>
<p>
<em>Summary: given an injective function <span class="math inline">\(A \times N \hookrightarrow B \times N\)</span>, it is possible to constructively “divide by <span class="math inline">\(N\)</span>” to obtain an injection <span class="math inline">\(A \hookrightarrow B\)</span>, as <a href="http://arxiv.org/abs/1504.01402">shown recently by Peter Doyle and Cecil Qiu</a> and expounded by <a href="http://arxiv.org/abs/1504.02179">Richard Schwartz</a>. Their algorithm is nontrivial to come up with—this had been a longstanding open question—but it’s not too difficult to explain. I exhibit some Haskell code implementing the algorithm, and show some examples.</em>
</p>
<h1 id="introduction-division-by-two">
Introduction: division by two
</h1>
<p>
Suppose someone hands you the following:
</p>
<ul>
<li>
<p>
A Haskell function <code>f :: (A, Bool) -&gt; (B, Bool)</code>, where <code>A</code> and <code>B</code> are abstract types (i.e. their constructors are not exported, and you have no other functions whose types mention <code>A</code> or <code>B</code>).
</p>
</li>
<li>
<p>
A promise that the function <code>f</code> is injective, that is, no two values of <code>(A, Bool)</code> map to the same <code>(B, Bool)</code> value. (Thus <code>(B, Bool)</code> must contain at least as many inhabitants as <code>(A, Bool)</code>.)
</p>
</li>
<li>
<p>
A list <code>as :: [A]</code>, with a promise that it contains every value of type <code>A</code> exactly once, at a finite position.
</p>
</li>
</ul>
<p>
Can you explicitly produce an injective function <code>f’ :: A -&gt; B</code>? Moreover, your answer should not depend on the order of elements in <code>as</code>.
</p>
<p>
It really seems like this ought to be possible. After all, if <code>(B, Bool)</code> has at least as many inhabitants as <code>(A, Bool)</code>, then surely <code>B</code> must have at least as many inhabitants as <code>A</code>. But it is not enough to reason merely that some injection <em>must exist</em>; we have to actually <em>construct</em> one. This, it turns out, is tricky. As a first attempt, we might try <code>f’ a = fst (f (a, True))</code>. That is certainly a function of type <code>A -&gt; B</code>, but there is no guarantee that it is injective. There could be <code>a1, a2 :: A</code> which both map to the same <code>b</code>, that is, one maps to <code>(b, False)</code> and the other to <code>(b, True)</code>. The picture below illustrates such a situation: <code>(a1, True)</code> and <code>(a2, True)</code> both map to <code>b2</code>. So the function <code>f</code> may be injective overall, but we can’t say much about <code>f</code> restricted to a particular <code>Bool</code> value.
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/9577e0a81dc50817.png"><img src="https://byorgey.files.wordpress.com/2015/05/9577e0a81dc50817.png" alt="9577e0a81dc50817" width="400" height="227" class="aligncenter size-full wp-image-1450" /></a>
</p>
</div>
<p>
The requirement that the answer not depend on the order of <code>as</code> also makes things difficult. (Over in math-land, depending on a particular ordering of the elements in <code>as</code> would amount to the well-ordering principle, which is equivalent to the axiom of choice, which in turn implies the law of excluded middle—and as we all know, every time someone uses the law of excluded middle, a puppy dies. …I feel like I’m in one of those <a href="https://www.youtube.com/watch?v=oMtPGAkvAPg">DirecTV commercials</a>. “Don’t let a puppy die. Ignore the order of elements in <code>as</code>.”) Anyway, making use of the order of values in <code>as</code>, we could do something like the following:
</p>
<ul>
<li>
For each <code>a :: A</code>:
<ul>
<li>
Look at the <code>B</code> values generated by <code>f (a,True)</code> and <code>f (a,False)</code>. (Note that there might only be one distinct such <code>B</code> value).
</li>
<li>
If neither <code>B</code> value has been used so far, pick the one that corresponds to <code>(a,True)</code>, and add the other one to a queue of available <code>B</code> values.
</li>
<li>
If one is used and one unused, pick the unused one.
</li>
<li>
If both are used, pick the next available <code>B</code> value from the queue.
</li>
</ul>
</li>
</ul>
<p>
<strike>It is not too hard</strike> I couldn’t be bothered to show that this will always successfully result in a total function <code>A -&gt; B</code>, which is injective by construction. (One has to show that there will always be an available <code>B</code> value in the queue when you need it.) The only problem is that the particular function we get depends on the order in which we iterate through the <code>A</code> values. The above example illustrates this as well: if the <code>A</code> values are listed in the order <span class="math inline">\([a_1, a_2]\)</span>, then we first choose <span class="math inline">\(a_1 \mapsto b_2\)</span>, and then <span class="math inline">\(a_2 \mapsto b_3\)</span>. If they are listed in the other order, we end up with <span class="math inline">\(a_2 \mapsto b_2\)</span> and <span class="math inline">\(a_1 \mapsto b_1\)</span>. Whichever value comes first “steals” <span class="math inline">\(b_2\)</span>, and then the other one takes whatever is left. We’d like to avoid this sort of dependence on order. That is, we want a well-defined algorithm which will yield a total, injective function <code>A -&gt; B</code>, which is <em>canonical</em> in the sense that the algorithm yields the same function given any permutation of <code>as</code>.
</p>
<p>
It <em>is</em> possible—you might enjoy puzzling over this a bit before reading on!
</p>
<h1 id="division-by-n">
Division by N
</h1>
<p>
The above example is a somewhat special case. More generally, let <span class="math inline">\(N = \{0, \dots, n-1\}\)</span> denote a canonical finite set of size <span class="math inline">\(n\)</span>, and let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be arbitrary sets. Then, given an injection <span class="math inline">\(f : A \times N \hookrightarrow B \times N\)</span>, is it possible to <em>effectively</em> (that is, without excluded middle or the axiom of choice) compute an injection <span class="math inline">\(A \hookrightarrow B\)</span>?
</p>
<p>
Translating down to the world of numbers representing set cardinalities—natural numbers if <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are finite, or cardinal numbers in general—this just says that if <span class="math inline">\(an \leq bn\)</span> then <span class="math inline">\(a \leq b\)</span>. This statement about numbers is obviously true, so it would be nice if we could say something similar about sets, so that this fact about numbers and inequalities can be seen as just a “shadow” of a more general theorem about sets and injections.
</p>
<p>
As hinted in the introduction, the interesting part of this problem is really the word “effectively”. Using the Axiom of Choice/Law of Excluded Middle makes the problem a lot easier, but either fails to yield an actual function that we can compute with, instead merely guaranteeing the <em>existence</em> of such a function, or gives us a function that depends on a particular ordering of <span class="math inline">\(A\)</span>.
</p>
<p>
Apparently this has been a longstanding open question, recently answered in the affirmative by Peter Doyle and Cecil Qiu in their paper <a href="http://arxiv.org/abs/1504.01402">Division By Four</a>. It’s a really great paper: they give some fascinating historical context for the problem, and explain their algorithm (which is conceptually not all that difficult) using an intuitive analogy to a card game with certain rules. (It is not a “game” in the usual sense of having winners and losers, but really just an algorithm implemented with “players” and “cards”. In fact, you could get some friends together and actually perform this algorithm in parallel (if you have sufficiently nerdy friends).) <a href="http://arxiv.org/abs/1504.02179">Richard Schwartz’s companion article</a> is also great fun and easy to follow (you should read it first).
</p>
<h1 id="a-game-of-thrones-cards">
A Game of <strike>Thrones</strike> Cards
</h1>
<p>
Here’s a quick introduction to the way Doyle, Qiu, and Schwartz use a card game to formulate their algorithm. (Porting this framework to use “thrones” and “claimants” instead of “spots” and “cards” is left as an exercise to the reader.)
</p>
<p>
The finite set <span class="math inline">\(N\)</span> is to be thought of as a set of <em>suits</em>. The set <span class="math inline">\(A\)</span> will correspond to a set of <em>players</em>, and <span class="math inline">\(B\)</span> to a set of <em>ranks</em> or <em>values</em> (for example, Ace, 2, 3, …) In that case <span class="math inline">\(B \times N\)</span> corresponds to a deck of cards, each card having a rank and a suit; and we can think of <span class="math inline">\(A \times N\)</span> in terms of each player having in front of them a number of “spots” or “slots”, each labelled by a suit. An injection <span class="math inline">\(A \times N \hookrightarrow B \times N\)</span> is then a particular “deal” where one card has been dealt into each of the spots in front of the players. (There may be some cards left over in the deck, but the fact that the function is total means every spot has a card, and the fact that it is injective is encoded in the common-sense idea that a given card cannot be in two spots at once.) For example, the example function from before:
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/9577e0a81dc50817.png"><img src="https://byorgey.files.wordpress.com/2015/05/9577e0a81dc50817.png" alt="9577e0a81dc50817" width="400" height="227" class="aligncenter size-full wp-image-1450" /></a>
</p>
</div>
<p>
corresponds to the following deal:
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/88e26b8c78506653.png"><img src="https://byorgey.files.wordpress.com/2015/05/88e26b8c78506653.png" alt="88e26b8c78506653" width="200" height="273" class="aligncenter size-full wp-image-1452" /></a>
</p>
</div>
<p>
Here each <em>column</em> corresponds to one player’s hand, and the rows correspond to suit spots (with the spade spots on top and the heart spots beneath). We have mapped <span class="math inline">\(\{b_1, b_2, b_3\}\)</span> to the ranks A, 2, 3, and mapped T and F to Spades and Hearts respectively. The spades are also highlighted in green, since later we will want to pay particular attention to what is happening with them. You might want to take a moment to convince yourself that the deal above really does correspond to the example function from before.
</p>
<h1 id="a-haskell-implementation">
A Haskell implementation
</h1>
<p>
Of course, doing everything <em>effectively</em> means we are really talking about <em>computation</em>. Doyle and Qiu do talk a bit about computation, but it’s still pretty abstract, in the sort of way that mathematicians talk about computation, so I thought it would be interesting to actually implement the algorithm in Haskell.
</p>
<p>
The algorithm “works” for infinite sets, but only (as far as I understand) if you consider some notion of transfinite recursion. It still counts as “effective” in math-land, but over here in programming-land I’d like to stick to (finitely) terminating computations, so we will stick to finite sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.
</p>
<p>
First, some extensions and imports. Nothing too controversial.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:green;">{-# LANGUAGE DataKinds                  #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE GADTs                      #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE KindSignatures             #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE RankNTypes                 #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE ScopedTypeVariables        #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE StandaloneDeriving         #-}</span>
<span>&gt;</span> <span style="color:green;">{-# LANGUAGE TypeOperators              #-}</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">module</span> <span>PanGalacticDivision</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Control</span><span>.</span><span>Arrow</span> <span style="color:red;">(</span><span>second</span><span style="color:red;">,</span> <span style="color:red;">(</span><span>&amp;&amp;&amp;</span><span style="color:red;">)</span><span style="color:red;">,</span> <span style="color:red;">(</span><span>***</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Data</span><span>.</span><span>Char</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Data</span><span>.</span><span>List</span>     <span style="color:red;">(</span><span>find</span><span style="color:red;">,</span> <span>findIndex</span><span style="color:red;">,</span> <span>transpose</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Data</span><span>.</span><span>Maybe</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Diagrams</span><span>.</span><span>Prelude</span> <span>hiding</span> <span style="color:red;">(</span><span>universe</span><span style="color:red;">,</span> <span>value</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Diagrams</span><span>.</span><span>Backend</span><span>.</span><span>Rasterific</span><span>.</span><span>CmdLine</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">import</span>           <span>Graphics</span><span>.</span><span>SVGFonts</span>
</code></pre>
<p>
We’ll need some standard machinery for type-level natural numbers. Probably all this stuff is in a library somewhere but I couldn’t be bothered to find out. Pointers welcome.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:green;">-- Standard unary natural number type</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">data</span> <span>Nat</span> <span style="color:red;">::</span> <span>*</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>Z</span> <span style="color:red;">::</span> <span>Nat</span>
<span>&gt;</span>   <span>Suc</span> <span style="color:red;">::</span> <span>Nat</span> <span style="color:red;">-&gt;</span> <span>Nat</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>One</span> <span style="color:red;">=</span> <span>Suc</span> <span>Z</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Two</span> <span style="color:red;">=</span> <span>Suc</span> <span>One</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Three</span> <span style="color:red;">=</span> <span>Suc</span> <span>Two</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Four</span> <span style="color:red;">=</span> <span>Suc</span> <span>Three</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Six</span> <span style="color:red;">=</span> <span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span>Four</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Eight</span> <span style="color:red;">=</span> <span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span>Six</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Ten</span> <span style="color:red;">=</span> <span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span>Eight</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Thirteen</span> <span style="color:red;">=</span> <span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span>Ten</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:green;">-- Singleton Nat-indexed natural numbers, to connect value-level and</span>
<span>&gt;</span> <span style="color:green;">-- type-level Nats</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">data</span> <span>SNat</span> <span style="color:red;">::</span> <span>Nat</span> <span style="color:red;">-&gt;</span> <span>*</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>SZ</span> <span style="color:red;">::</span> <span>SNat</span> <span>Z</span>
<span>&gt;</span>   <span>SS</span> <span style="color:red;">::</span> <span>Natural</span> <span>n</span> <span style="color:red;">=&gt;</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>SNat</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:green;">-- A class for converting type-level nats to value-level ones</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">class</span> <span>Natural</span> <span>n</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>toSNat</span> <span style="color:red;">::</span> <span>SNat</span> <span>n</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">instance</span> <span>Natural</span> <span>Z</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>toSNat</span> <span style="color:red;">=</span> <span>SZ</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">instance</span> <span>Natural</span> <span>n</span> <span style="color:red;">=&gt;</span> <span>Natural</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>toSNat</span> <span style="color:red;">=</span> <span>SS</span> <span>toSNat</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:green;">-- A function for turning explicit nat evidence into implicit</span>
<span>&gt;</span> <span>natty</span> <span style="color:red;">::</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>Natural</span> <span>n</span> <span style="color:red;">=&gt;</span> <span>r</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>r</span>
<span>&gt;</span> <span>natty</span> <span>SZ</span> <span>r</span>     <span style="color:red;">=</span> <span>r</span>
<span>&gt;</span> <span>natty</span> <span style="color:red;">(</span><span>SS</span> <span>n</span><span style="color:red;">)</span> <span>r</span> <span style="color:red;">=</span> <span>natty</span> <span>n</span> <span>r</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:green;">-- The usual canonical finite type.  Fin n has exactly n</span>
<span>&gt;</span> <span style="color:green;">-- (non-bottom) values.</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">data</span> <span>Fin</span> <span style="color:red;">::</span> <span>Nat</span> <span style="color:red;">-&gt;</span> <span>*</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>FZ</span> <span style="color:red;">::</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span>
<span>&gt;</span>   <span>FS</span> <span style="color:red;">::</span> <span>Fin</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span>finToInt</span> <span style="color:red;">::</span> <span>Fin</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>Int</span>
<span>&gt;</span> <span>finToInt</span> <span>FZ</span>     <span style="color:red;">=</span> <span class="hs-num">0</span>
<span>&gt;</span> <span>finToInt</span> <span style="color:red;">(</span><span>FS</span> <span>n</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span class="hs-num">1</span> <span>+</span> <span>finToInt</span> <span>n</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">deriving</span> <span style="color:blue;font-weight:bold;">instance</span> <span>Eq</span> <span style="color:red;">(</span><span>Fin</span> <span>n</span><span style="color:red;">)</span>
</code></pre>
<h1 id="finiteness">
Finiteness
</h1>
<p>
Next, a type class to represent finiteness. For our purposes, a type <code>a</code> is finite if we can explicitly list its elements. For convenience we throw in decidable equality as well, since we will usually need that in conjunction. Of course, we have to be careful: although we can get a <em>list</em> of elements for a finite type, we don’t want to depend on the ordering. We must ensure that the output of the algorithm is independent of the order of elements.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> This is in fact true, although somewhat nontrivial to prove formally; I mention some of the intuitive ideas behind the proof below.
</p>
<p>
While we are at it, we give <code>Finite</code> instances for <code>Fin n</code> and for products of finite types.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:blue;font-weight:bold;">class</span> <span>Eq</span> <span>a</span> <span style="color:red;">=&gt;</span> <span>Finite</span> <span>a</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>universe</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>a</span><span style="color:red;">]</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:blue;font-weight:bold;">instance</span> <span>Natural</span> <span>n</span> <span style="color:red;">=&gt;</span> <span>Finite</span> <span style="color:red;">(</span><span>Fin</span> <span>n</span><span style="color:red;">)</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>universe</span> <span style="color:red;">=</span> <span>fins</span> <span>toSNat</span>
<span>&gt;</span> 
<span>&gt;</span> <span>fins</span> <span style="color:red;">::</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span style="color:red;">[</span><span>Fin</span> <span>n</span><span style="color:red;">]</span>
<span>&gt;</span> <span>fins</span> <span>SZ</span>     <span style="color:red;">=</span> <span>[]</span>
<span>&gt;</span> <span>fins</span> <span style="color:red;">(</span><span>SS</span> <span>n</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span>FZ</span> <span>:</span> <span>map</span> <span>FS</span> <span style="color:red;">(</span><span>fins</span> <span>n</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:green;">-- The product of two finite types is finite.</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">instance</span> <span style="color:red;">(</span><span>Finite</span> <span>a</span><span style="color:red;">,</span> <span>Finite</span> <span>b</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>Finite</span> <span style="color:red;">(</span><span>a</span><span style="color:red;">,</span><span>b</span><span style="color:red;">)</span> <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>   <span>universe</span> <span style="color:red;">=</span> <span style="color:red;">[</span><span style="color:red;">(</span><span>a</span><span style="color:red;">,</span><span>b</span><span style="color:red;">)</span> <span style="color:red;">|</span> <span>a</span> <span style="color:red;">&lt;-</span> <span>universe</span><span style="color:red;">,</span> <span>b</span> <span style="color:red;">&lt;-</span> <span>universe</span><span style="color:red;">]</span>
</code></pre>
<h1 id="division-inductively">
Division, inductively
</h1>
<p>
Now we come to the division algorithm proper. The idea is that <code>panGalacticPred</code> turns an injection <span class="math inline">\(A \times N \hookrightarrow B \times N\)</span> into an injection <span class="math inline">\(A \times (N-1) \hookrightarrow B \times (N-1)\)</span>, and then we use induction on <span class="math inline">\(N\)</span> to repeatedly apply <code>panGalacticPred</code> until we get an injection <span class="math inline">\(A \times 1 \hookrightarrow B \times 1\)</span>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>panGalacticDivision</span>
<span>&gt;</span>   <span style="color:red;">::</span> <span style="color:blue;font-weight:bold;">forall</span> <span>a</span> <span>b</span> <span>n</span><span>.</span> <span style="color:red;">(</span><span>Finite</span> <span>a</span><span style="color:red;">,</span> <span>Eq</span> <span>b</span><span style="color:red;">)</span>
<span>&gt;</span>   <span style="color:red;">=&gt;</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span style="color:red;">(</span><span>a</span><span style="color:red;">,</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>b</span><span style="color:red;">,</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>a</span> <span style="color:red;">-&gt;</span> <span>b</span><span style="color:red;">)</span>
</code></pre>
<p>
In the base case, we are given an injection <span class="math inline">\(A \times 1 \hookrightarrow B \times 1\)</span>, so we just pass a unit value in along with the <span class="math inline">\(A\)</span> and project out the <span class="math inline">\(B\)</span>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>panGalacticDivision</span> <span>SZ</span> <span>f</span> <span style="color:red;">=</span> <span style="color:red;">\</span><span>a</span> <span style="color:red;">-&gt;</span> <span>fst</span> <span style="color:red;">(</span><span>f</span> <span style="color:red;">(</span><span>a</span><span style="color:red;">,</span> <span>FZ</span><span style="color:red;">)</span><span style="color:red;">)</span>
</code></pre>
<p>
In the inductive case, we call <code>panGalacticPred</code> and recurse.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>panGalacticDivision</span> <span style="color:red;">(</span><span>SS</span> <span>n'</span><span style="color:red;">)</span> <span>f</span> <span style="color:red;">=</span> <span>panGalacticDivision</span> <span>n'</span> <span style="color:red;">(</span><span>panGalacticPred</span> <span>n'</span> <span>f</span><span style="color:red;">)</span>
</code></pre>
<h1 id="pan-galactic-predecessor">
Pan-Galactic Predecessor
</h1>
<p>
And now for the real meat of the algorithm, the <code>panGalacticPred</code> function. The idea is that we swap outputs around until the function has the property that every output of the form <span class="math inline">\((b,0)\)</span> corresponds to an input also of the form <span class="math inline">\((a,0)\)</span>. That is, using the card game analogy, every spade in play should be in the leftmost spot (the spades spot) of some player’s hand (some spades can also be in the deck). Then simply dropping the leftmost card in everyone’s hand (and all the spades in the deck) yields a game with no spades. That is, we will have an injection <span class="math inline">\(A \times \{1, \dots, n-1\} \hookrightarrow B \times \{1, \dots, n-1\}\)</span>. Taking predecessors everywhere (i.e. “hearts are the new spades”) yields the desired injection <span class="math inline">\(A \times (N-1) \hookrightarrow B \times (N-1)\)</span>.
</p>
<p>
We need a <code>Finite</code> constraint on <code>a</code> so that we can enumerate all possible inputs to the function, and an <code>Eq</code> constraint on <code>b</code> so that we can compare functions for extensional equality (we iterate until reaching a fixed point). Note that whether two functions are extensionally equal does not depend on the order in which we enumerate their inputs, so far validating my claim that nothing depends on the order of elements returned by <code>universe</code>.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>panGalacticPred</span>
<span>&gt;</span>   <span style="color:red;">::</span> <span style="color:red;">(</span><span>Finite</span> <span>a</span><span style="color:red;">,</span> <span>Eq</span> <span>b</span><span style="color:red;">,</span> <span>Natural</span> <span>n</span><span style="color:red;">)</span>
<span>&gt;</span>   <span style="color:red;">=&gt;</span> <span>SNat</span> <span>n</span>
<span>&gt;</span>   <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span style="color:red;">(</span><span>a</span><span style="color:red;">,</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>b</span><span style="color:red;">,</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span>   <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span style="color:red;">(</span><span>a</span><span style="color:red;">,</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>b</span><span style="color:red;">,</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span>
</code></pre>
<p>
We construct a function <code>f’</code> which is related to <code>f</code> by a series of swaps, and has the property that it only outputs <code>FZ</code> when given <code>FZ</code> as an input. So given <code>(a,i)</code> we can call <code>f’</code> on <code>(a, FS i)</code> which is guaranteed to give us something of the form <code>(b, FS j)</code>. Thus it is safe to strip off the <code>FS</code> and return <code>(b, j)</code> (though the Haskell type checker most certainly does not know this, so we just have to tell it to trust us).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>panGalacticPred</span> <span>n</span> <span>f</span> <span style="color:red;">=</span> <span style="color:red;">\</span><span style="color:red;">(</span><span>a</span><span style="color:red;">,</span><span>i</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>second</span> <span>unFS</span> <span style="color:red;">(</span><span>f'</span> <span style="color:red;">(</span><span>a</span><span style="color:red;">,</span> <span>FS</span> <span>i</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>unFS</span> <span style="color:red;">::</span> <span>Fin</span> <span style="color:red;">(</span><span>Suc</span> <span>n</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>Fin</span> <span>n</span>
<span>&gt;</span>     <span>unFS</span> <span>FZ</span> <span style="color:red;">=</span> <span>error</span> <span style="color:teal;">"impossible!"</span>
<span>&gt;</span>     <span>unFS</span> <span style="color:red;">(</span><span>FS</span> <span>i</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span>i</span>
</code></pre>
<p>
To construct <code>f’</code> we iterate a certain transformation until reaching a fixed point. For finite sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> this is guaranteed to terminate, though it is certainly not obvious from the Haskell code. (Encoding this in Agda so that it is accepted by the termination checker would be a fun (?) exercise.)
</p>
<p>
One round of the algorithm consists of two phases called “shape up” and “ship out” (to be described shortly).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span>     <span>oneRound</span> <span style="color:red;">=</span> <span>natty</span> <span>n</span> <span>$</span> <span>shipOut</span> <span>.</span> <span>shapeUp</span>
<span>&gt;</span> 
<span>&gt;</span>     <span style="color:green;">-- iterate 'oneRound' beginning with the original function...</span>
<span>&gt;</span>     <span>fs</span> <span style="color:red;">=</span> <span>iterate</span> <span>oneRound</span> <span>f</span>
<span>&gt;</span>     <span style="color:green;">-- ... and stop when we reach a fixed point.</span>
<span>&gt;</span>     <span>f'</span> <span style="color:red;">=</span> <span>fst</span> <span>.</span> <span>head</span> <span>.</span> <span>dropWhile</span> <span style="color:red;">(</span><span>uncurry</span> <span style="color:red;">(</span><span>=/=</span><span style="color:red;">)</span><span style="color:red;">)</span> <span>$</span> <span>zip</span> <span>fs</span> <span style="color:red;">(</span><span>tail</span> <span>fs</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>f1</span> <span>=/=</span> <span>f2</span> <span style="color:red;">=</span> <span>all</span> <span style="color:red;">(</span><span style="color:red;">\</span><span>x</span> <span style="color:red;">-&gt;</span> <span>f1</span> <span>x</span> <span>==</span> <span>f2</span> <span>x</span><span style="color:red;">)</span> <span>universe</span>
</code></pre>
<h1 id="encoding-card-games">
Encoding Card Games
</h1>
<p>
Recall that a “card” is a pair of a value and a suit; we think of <span class="math inline">\(B\)</span> as the set of values and <span class="math inline">\(N\)</span> as the set of suits.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>v</span><span style="color:red;">,</span> <span>s</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span>value</span> <span style="color:red;">::</span> <span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>v</span>
<span>&gt;</span> <span>value</span> <span style="color:red;">=</span> <span>fst</span>
<span>&gt;</span> 
<span>&gt;</span> <span>suit</span> <span style="color:red;">::</span> <span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>s</span>
<span>&gt;</span> <span>suit</span> <span style="color:red;">=</span> <span>snd</span>
</code></pre>
<p>
Again, there are a number of players (one for each element of <span class="math inline">\(A\)</span>), each of which has a “hand” of cards. A hand has a number of “spots” for cards, each one labelled by a different suit (which may not have any relation to the actual suit of the card in that position).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>PlayerSpot</span> <span>p</span> <span>s</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>p</span><span style="color:red;">,</span> <span>s</span><span style="color:red;">)</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Hand</span> <span>v</span> <span>s</span> <span style="color:red;">=</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Card</span> <span>v</span> <span>s</span>
</code></pre>
<p>
A “game” is an injective function from player spots to cards. Of course, the type system is not enforcing injectivity here.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span> <span style="color:red;">=</span> <span>PlayerSpot</span> <span>p</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Card</span> <span>v</span> <span>s</span>
</code></pre>
<p>
Some utility functions. First, a function to project out the hand of a given player.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>hand</span> <span style="color:red;">::</span> <span>p</span> <span style="color:red;">-&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Hand</span> <span>v</span> <span>s</span>
<span>&gt;</span> <span>hand</span> <span>p</span> <span>g</span> <span style="color:red;">=</span> <span style="color:red;">\</span><span>s</span> <span style="color:red;">-&gt;</span> <span>g</span> <span style="color:red;">(</span><span>p</span><span style="color:red;">,</span> <span>s</span><span style="color:red;">)</span>
</code></pre>
<p>
A function to swap two cards, yielding a bijection on cards.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>swap</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Eq</span> <span>s</span><span style="color:red;">,</span> <span>Eq</span> <span>v</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Card</span> <span>v</span> <span>s</span><span style="color:red;">)</span>
<span>&gt;</span> <span>swap</span> <span>c1</span> <span>c2</span> <span style="color:red;">=</span> <span>f</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>f</span> <span>c</span>
<span>&gt;</span>       <span style="color:red;">|</span> <span>c</span> <span>==</span> <span>c1</span>   <span style="color:red;">=</span> <span>c2</span>
<span>&gt;</span>       <span style="color:red;">|</span> <span>c</span> <span>==</span> <span>c2</span>   <span style="color:red;">=</span> <span>c1</span>
<span>&gt;</span>       <span style="color:red;">|</span> <span>otherwise</span> <span style="color:red;">=</span> <span>c</span>
</code></pre>
<p>
<code>leftmost</code> finds the leftmost card in a player’s hand which has a given suit.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>leftmost</span> <span style="color:red;">::</span> <span>Finite</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Hand</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Maybe</span> <span>s</span>
<span>&gt;</span> <span>leftmost</span> <span>targetSuit</span> <span>h</span> <span style="color:red;">=</span> <span>find</span> <span style="color:red;">(</span><span style="color:red;">\</span><span>s</span> <span style="color:red;">-&gt;</span> <span>suit</span> <span style="color:red;">(</span><span>h</span> <span>s</span><span style="color:red;">)</span> <span>==</span> <span>targetSuit</span><span style="color:red;">)</span> <span>universe</span>
</code></pre>
<h1 id="playing-rounds">
Playing Rounds
</h1>
<p>
<code>playRound</code> abstracts out a pattern that is used by both <code>shapeUp</code> and <code>shipOut</code>. The first argument is a function which, given a hand, produces a function on cards; that is, based on looking at a single hand, it decides how to swap some cards around.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <code>playRound</code> then applies that function to every hand, and composes together all the resulting permutations.
</p>
<p>
Note that <code>playRound</code> has both <code>Finite s</code> and <code>Finite p</code> constraints, so we should think about whether the result depends on the order of elements returned by any call to <code>universe</code>—I claimed it does not. <code>Finite s</code> corresponds to suits/spots, which corresponds to <span class="math inline">\(N\)</span> in the original problem formulation. <span class="math inline">\(N\)</span> explicitly has a canonical ordering, so this is not a problem. The <code>Finite p</code> constraint, on the face of it, is more problematic. We will have to think carefully about each of the rounds implemented in terms of <code>playRound</code> and make sure they do not depend on the order of players. Put another way, it should be possible for all the players to take their turn simultaneously.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>playRound</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Finite</span> <span>s</span><span style="color:red;">,</span> <span>Finite</span> <span>p</span><span style="color:red;">,</span> <span>Eq</span> <span>v</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span style="color:red;">(</span><span>Hand</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Card</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Card</span> <span>v</span> <span>s</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span>
<span>&gt;</span> <span>playRound</span> <span>withHand</span> <span>g</span> <span style="color:red;">=</span> <span>foldr</span> <span style="color:red;">(</span><span>.</span><span style="color:red;">)</span> <span>id</span> <span>swaps</span> <span>.</span> <span>g</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>swaps</span> <span style="color:red;">=</span> <span>map</span> <span style="color:red;">(</span><span>withHand</span> <span>.</span> <span>flip</span> <span>hand</span> <span>g</span><span style="color:red;">)</span> <span>players</span>
<span>&gt;</span>     <span>players</span> <span style="color:red;">=</span> <span>universe</span>
</code></pre>
<h1 id="shape-up-and-ship-out">
Shape Up and Ship Out
</h1>
<p>
Finally, we can describe the “shape up” and “ship out” phases, beginning with “shape up”. A “bad” card is defined as one having the lowest suit; make sure every hand with any bad cards has one in the leftmost spot (by swapping the leftmost bad card with the card in the leftmost spot, if necessary).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>shapeUp</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Finite</span> <span>s</span><span style="color:red;">,</span> <span>Finite</span> <span>p</span><span style="color:red;">,</span> <span>Eq</span> <span>v</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span>
<span>&gt;</span> <span>shapeUp</span> <span style="color:red;">=</span> <span>playRound</span> <span>shapeUp1</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>badSuit</span> <span style="color:red;">=</span> <span>head</span> <span>universe</span>
<span>&gt;</span>     <span>shapeUp1</span> <span>theHand</span> <span style="color:red;">=</span>
<span>&gt;</span>       <span style="color:blue;font-weight:bold;">case</span> <span>leftmost</span> <span>badSuit</span> <span>theHand</span> <span style="color:blue;font-weight:bold;">of</span>
<span>&gt;</span>         <span>Nothing</span>      <span style="color:red;">-&gt;</span> <span>id</span>
<span>&gt;</span>         <span>Just</span> <span>badSpot</span> <span style="color:red;">-&gt;</span> <span>swap</span> <span style="color:red;">(</span><span>theHand</span> <span>badSuit</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>theHand</span> <span>badSpot</span><span style="color:red;">)</span>
</code></pre>
<p>
And now for the “ship out” phase. Send any “bad” cards not in the leftmost spot somewhere else, by swapping with a replacement, namely, the card whose suit is the same as the suit of the spot, and whose value is the same as the value of the bad card in the leftmost spot. The point is that bad cards in the leftmost spot are OK, since we will eventually just ignore the leftmost spot. So we have to keep shipping out bad cards not in the leftmost spot until they all end up in the leftmost spot. For some intuition as to why this is guaranteed to terminate, consult Schwartz; note that columns tend to acquire more and more cards that have the same rank as a spade in the top spot (which never moves).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span>shipOut</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Finite</span> <span>s</span><span style="color:red;">,</span> <span>Finite</span> <span>p</span><span style="color:red;">,</span> <span>Eq</span> <span>v</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Game</span> <span>p</span> <span>v</span> <span>s</span>
<span>&gt;</span> <span>shipOut</span> <span style="color:red;">=</span> <span>playRound</span> <span>shipOutHand</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>badSuit</span> <span style="color:red;">=</span> <span>head</span> <span>universe</span>
<span>&gt;</span>     <span>spots</span> <span style="color:red;">=</span> <span>universe</span>
<span>&gt;</span>     <span>shipOutHand</span> <span>theHand</span> <span style="color:red;">=</span> <span>foldr</span> <span style="color:red;">(</span><span>.</span><span style="color:red;">)</span> <span>id</span> <span>swaps</span>
<span>&gt;</span>       <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>         <span>swaps</span> <span style="color:red;">=</span> <span>map</span> <span style="color:red;">(</span><span>shipOut1</span> <span>.</span> <span style="color:red;">(</span><span>theHand</span> <span>&amp;&amp;&amp;</span> <span>id</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>drop</span> <span class="hs-num">1</span> <span>spots</span><span style="color:red;">)</span>
<span>&gt;</span>         <span>shipOut1</span> <span style="color:red;">(</span><span style="color:red;">(</span><span style="color:blue;font-weight:bold;">_</span><span style="color:red;">,</span><span>s</span><span style="color:red;">)</span><span style="color:red;">,</span> <span>spot</span><span style="color:red;">)</span>
<span>&gt;</span>           <span style="color:red;">|</span> <span>s</span> <span>==</span> <span>badSuit</span> <span style="color:red;">=</span> <span>swap</span> <span style="color:red;">(</span><span>theHand</span> <span>spot</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>value</span> <span style="color:red;">(</span><span>theHand</span> <span>badSuit</span><span style="color:red;">)</span><span style="color:red;">,</span> <span>spot</span><span style="color:red;">)</span>
<span>&gt;</span>           <span style="color:red;">|</span> <span>otherwise</span>    <span style="color:red;">=</span> <span>id</span>
</code></pre>
<p>
And that’s it! Note that both <code>shapeUp</code> and <code>shipOut</code> are implemented by composing a bunch of swaps; in fact, in both cases, all the swaps commute, so the order in which they are composed does not matter. (For proof, see Schwartz.) Thus, the result is independent of the order of the players (<em>i.e.</em> the set <code>A</code>).
</p>
<p>
Enough code, let’s see an example! This example is taken directly from Doyle and Qiu’s paper, and the diagrams are being generated literally (literately?) by running the code in this blog post. Here’s the starting configuration:
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/08c40ab96ca385c0.png"><img src="https://byorgey.files.wordpress.com/2015/05/08c40ab96ca385c0.png" alt="08c40ab96ca385c0" width="600" height="334" class="aligncenter size-full wp-image-1453" /></a>
</p>
</div>
<p>
Again, the spades are all highlighted in green. Recall that our goal is to get them all to be in the first row, but we have to do it in a completely deterministic, canonical way. After shaping up, we have:
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/e32d54891cc5e470.png"><img src="https://byorgey.files.wordpress.com/2015/05/e32d54891cc5e470.png" alt="e32d54891cc5e470" width="600" height="334" class="aligncenter size-full wp-image-1455" /></a>
</p>
</div>
<p>
Notice how the 6, K, 5, A, and 8 of spades have all been swapped to the top of their column. However, there are still spades which are not at the top of their column (in particular the 10, 9, and J) so we are not done yet.
</p>
<p>
Now, we ship out. For example, the 10 of spades is in the diamonds position in the column with the Ace of spades, so we swap it with the Ace of diamonds. Similarly, we swap the 9 of spades with the Queen of diamonds, and the Jack of spades with the 4 of hearts.
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/271c3505d198b229.png"><img src="https://byorgey.files.wordpress.com/2015/05/271c3505d198b229.png" alt="271c3505d198b229" width="600" height="334" class="aligncenter size-full wp-image-1456" /></a>
</p>
</div>
<p>
Shaping up does nothing at this point so we ship out again, and then continue to alternate rounds.
</p>
<div style="text-align:center;">
<p>
<a href="https://byorgey.files.wordpress.com/2015/05/d2012b69fc3cc161.png"><img src="https://byorgey.files.wordpress.com/2015/05/d2012b69fc3cc161.png" alt="d2012b69fc3cc161" width="600" height="1401" class="aligncenter size-full wp-image-1457" /></a>
</p>
</div>
<p>
In the final deal above, all the spades are at the top of a column, so there is an injection from the set of all non-spade spots to the deck of cards with all spades removed. This example was, I suspect, carefully constructed so that none of the spades get swapped out into the undealt portion of the deck, and so that we end up with <em>only</em> spades in the top row. In general, we might end up with some non-spades also in the top row, but that’s not a problem. The point is that ignoring the top row gets rid of all the spades.
</p>
<p>
Anyway, I hope to write more about some “practical” examples and about what this has to do with combinatorial species, but this post is long enough already. Doyle and Qiu also describe a “short division” algorithm (the above is “long division”) that I hope to explore as well.
</p>
<h1 id="the-rest-of-the-code">
The rest of the code
</h1>
<p>
For completeness, here’s the code I used to represent the example game above, and to render all the card diagrams (using <a href="http://projects.haskell.org/diagrams">diagrams 1.3</a>).
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Suit</span> <span style="color:red;">=</span> <span>Fin</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Rank</span> <span style="color:red;">=</span> <span>Fin</span>
<span>&gt;</span> <span style="color:blue;font-weight:bold;">type</span> <span>Player</span> <span style="color:red;">=</span> <span>Fin</span>
<span>&gt;</span> 
<span>&gt;</span> <span>readRank</span> <span style="color:red;">::</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>Char</span> <span style="color:red;">-&gt;</span> <span>Rank</span> <span>n</span>
<span>&gt;</span> <span>readRank</span> <span>n</span> <span>c</span> <span style="color:red;">=</span> <span>fins</span> <span>n</span> <span>!!</span> <span style="color:red;">(</span><span>fromJust</span> <span>$</span> <span>findIndex</span> <span style="color:red;">(</span><span>==</span><span>c</span><span style="color:red;">)</span> <span style="color:teal;">"A23456789TJQK"</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span>readSuit</span> <span style="color:red;">::</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>Char</span> <span style="color:red;">-&gt;</span> <span>Suit</span> <span>n</span>
<span>&gt;</span> <span>readSuit</span> <span style="color:red;">(</span><span>SS</span> <span style="color:blue;font-weight:bold;">_</span><span style="color:red;">)</span> <span style="color:teal;">'S'</span>                <span style="color:red;">=</span> <span>FZ</span>
<span>&gt;</span> <span>readSuit</span> <span style="color:red;">(</span><span>SS</span> <span style="color:red;">(</span><span>SS</span> <span style="color:blue;font-weight:bold;">_</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:teal;">'H'</span>           <span style="color:red;">=</span> <span>FS</span> <span>FZ</span>
<span>&gt;</span> <span>readSuit</span> <span style="color:red;">(</span><span>SS</span> <span style="color:red;">(</span><span>SS</span> <span style="color:red;">(</span><span>SS</span> <span style="color:blue;font-weight:bold;">_</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:teal;">'D'</span>      <span style="color:red;">=</span> <span>FS</span> <span style="color:red;">(</span><span>FS</span> <span>FZ</span><span style="color:red;">)</span>
<span>&gt;</span> <span>readSuit</span> <span style="color:red;">(</span><span>SS</span> <span style="color:red;">(</span><span>SS</span> <span style="color:red;">(</span><span>SS</span> <span style="color:red;">(</span><span>SS</span> <span style="color:blue;font-weight:bold;">_</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:teal;">'C'</span> <span style="color:red;">=</span> <span>FS</span> <span style="color:red;">(</span><span>FS</span> <span style="color:red;">(</span><span>FS</span> <span>FZ</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span>readGame</span> <span style="color:red;">::</span> <span>SNat</span> <span>a</span> <span style="color:red;">-&gt;</span> <span>SNat</span> <span>b</span> <span style="color:red;">-&gt;</span> <span>SNat</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>String</span> <span style="color:red;">-&gt;</span> <span>Game</span> <span style="color:red;">(</span><span>Player</span> <span>a</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Rank</span> <span>b</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Suit</span> <span>n</span><span style="color:red;">)</span>
<span>&gt;</span> <span>readGame</span> <span>a</span> <span>b</span> <span>n</span> <span>str</span> <span style="color:red;">=</span> <span style="color:red;">\</span><span style="color:red;">(</span><span>p</span><span style="color:red;">,</span> <span>s</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>table</span> <span>!!</span> <span>finToInt</span> <span>p</span> <span>!!</span> <span>finToInt</span> <span>s</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>table</span> <span style="color:red;">=</span> <span>transpose</span> <span>.</span> <span>map</span> <span style="color:red;">(</span><span>map</span> <span>readCard</span> <span>.</span> <span>words</span><span style="color:red;">)</span> <span>.</span> <span>lines</span> <span>$</span> <span>str</span>
<span>&gt;</span>     <span>readCard</span> <span style="color:red;">[</span><span>r</span><span style="color:red;">,</span><span>s</span><span style="color:red;">]</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>readRank</span> <span>b</span> <span>r</span><span style="color:red;">,</span> <span>readSuit</span> <span>n</span> <span>s</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span style="color:green;">-- Example game from Doyle &amp; Qiu</span>
<span>&gt;</span> <span>exampleGameStr</span> <span style="color:red;">::</span> <span>String</span>
<span>&gt;</span> <span>exampleGameStr</span> <span style="color:red;">=</span> <span>unlines</span>
<span>&gt;</span>   <span style="color:red;">[</span> <span style="color:teal;">"4D 6H QD 8D 9H QS 4C AD 6C 4S"</span>
<span>&gt;</span>   <span style="color:red;">,</span> <span style="color:teal;">"JH AH 9C 8H AS TC TD 5H QC JS"</span>
<span>&gt;</span>   <span style="color:red;">,</span> <span style="color:teal;">"KC 6S 4H 6D TS 9S JC KD 8S 8C"</span>
<span>&gt;</span>   <span style="color:red;">,</span> <span style="color:teal;">"5C 5D KS 5S TH JD AC QH 9D KH"</span>
<span>&gt;</span>   <span style="color:red;">]</span>
<span>&gt;</span> 
<span>&gt;</span> <span>exampleGame</span> <span style="color:red;">::</span> <span>Game</span> <span style="color:red;">(</span><span>Player</span> <span>Ten</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Rank</span> <span>Thirteen</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Suit</span> <span>Four</span><span style="color:red;">)</span>
<span>&gt;</span> <span>exampleGame</span> <span style="color:red;">=</span> <span>readGame</span> <span>toSNat</span> <span>toSNat</span> <span>toSNat</span> <span>exampleGameStr</span>
<span>&gt;</span> 
<span>&gt;</span> <span>suitSymbol</span> <span style="color:red;">::</span> <span>Suit</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>String</span>
<span>&gt;</span> <span>suitSymbol</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>:</span><span>[]</span><span style="color:red;">)</span> <span>.</span> <span style="color:red;">(</span><span style="color:teal;">"♠♥♦♣"</span><span>!!</span><span style="color:red;">)</span> <span>.</span> <span>finToInt</span>  <span style="color:green;">-- Huzzah for Unicode</span>
<span>&gt;</span> 
<span>&gt;</span> <span>suitDia</span> <span style="color:red;">::</span> <span>Suit</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>Diagram</span> <span>B</span>
<span>&gt;</span> <span>suitDia</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>suitDias</span><span>!!</span><span style="color:red;">)</span> <span>.</span> <span>finToInt</span>
<span>&gt;</span> 
<span>&gt;</span> <span>suitDias</span> <span style="color:red;">=</span> <span>map</span> <span>mkSuitDia</span> <span style="color:red;">(</span><span>fins</span> <span style="color:red;">(</span><span>toSNat</span> <span style="color:red;">::</span> <span>SNat</span> <span>Four</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span> <span>mkSuitDia</span> <span>s</span> <span style="color:red;">=</span> <span>text'</span> <span style="color:red;">(</span><span>suitSymbol</span> <span>s</span><span style="color:red;">)</span> <span>#</span> <span>fc</span> <span style="color:red;">(</span><span>suitColor</span> <span>s</span><span style="color:red;">)</span> <span>#</span> <span>lw</span> <span>none</span>
<span>&gt;</span> 
<span>&gt;</span> <span>suitColor</span> <span style="color:red;">::</span> <span>Suit</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>Colour</span> <span>Double</span>
<span>&gt;</span> <span>suitColor</span> <span>n</span>
<span>&gt;</span>   <span style="color:red;">|</span> <span>finToInt</span> <span>n</span> <span>`elem`</span> <span style="color:red;">[</span><span class="hs-num">0</span><span style="color:red;">,</span><span class="hs-num">3</span><span style="color:red;">]</span> <span style="color:red;">=</span> <span>black</span>
<span>&gt;</span>   <span style="color:red;">|</span> <span>otherwise</span>               <span style="color:red;">=</span> <span>red</span>
<span>&gt;</span> 
<span>&gt;</span> <span>rankStr</span> <span style="color:red;">::</span> <span>Rank</span> <span>n</span> <span style="color:red;">-&gt;</span> <span>String</span>
<span>&gt;</span> <span>rankStr</span> <span>n</span> <span style="color:red;">=</span> <span>rankStr'</span> <span style="color:red;">(</span><span>finToInt</span> <span>n</span> <span>+</span> <span class="hs-num">1</span><span style="color:red;">)</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>rankStr'</span> <span class="hs-num">1</span> <span style="color:red;">=</span> <span style="color:teal;">"A"</span>
<span>&gt;</span>     <span>rankStr'</span> <span>i</span> <span style="color:red;">|</span> <span>i</span> <span>&lt;=</span> <span class="hs-num">10</span>    <span style="color:red;">=</span> <span>show</span> <span>i</span>
<span>&gt;</span>                <span style="color:red;">|</span> <span>otherwise</span> <span style="color:red;">=</span> <span style="color:red;">[</span><span style="color:teal;">"JQK"</span> <span>!!</span> <span style="color:red;">(</span><span>i</span> <span style="color:green;">-</span> <span class="hs-num">11</span><span style="color:red;">)</span><span style="color:red;">]</span>
<span>&gt;</span> 
<span>&gt;</span> <span>text'</span> <span>t</span> <span style="color:red;">=</span> <span>stroke</span> <span style="color:red;">(</span><span>textSVG'</span> <span style="color:red;">(</span><span>TextOpts</span> <span>lin</span> <span>INSIDE_H</span> <span>KERN</span> <span>False</span> <span class="hs-num">1</span> <span class="hs-num">1</span><span style="color:red;">)</span> <span>t</span><span style="color:red;">)</span>
<span>&gt;</span> 
<span>&gt;</span> <span>renderCard</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Rank</span> <span>b</span><span style="color:red;">,</span> <span>Suit</span> <span>n</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>Diagram</span> <span>B</span>
<span>&gt;</span> <span>renderCard</span> <span style="color:red;">(</span><span>r</span><span style="color:red;">,</span> <span>s</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span>mconcat</span>
<span>&gt;</span>   <span style="color:red;">[</span> <span>mirror</span> <span>label</span>
<span>&gt;</span>   <span style="color:red;">,</span> <span>cardContent</span> <span style="color:red;">(</span><span>finToInt</span> <span>r</span> <span>+</span> <span class="hs-num">1</span><span style="color:red;">)</span>
<span>&gt;</span>   <span style="color:red;">,</span> <span>back</span>
<span>&gt;</span>   <span style="color:red;">]</span>
<span>&gt;</span>   <span style="color:blue;font-weight:bold;">where</span>
<span>&gt;</span>     <span>cardWidth</span>  <span style="color:red;">=</span> <span class="hs-num">2.25</span>
<span>&gt;</span>     <span>cardHeight</span> <span style="color:red;">=</span> <span class="hs-num">3.5</span>
<span>&gt;</span>     <span>cardCorners</span> <span style="color:red;">=</span> <span class="hs-num">0.1</span>
<span>&gt;</span>     <span>mirror</span> <span>d</span> <span style="color:red;">=</span> <span>d</span> <span></span> <span>d</span> <span>#</span> <span>rotateBy</span> <span style="color:red;">(</span><span class="hs-num">1</span><span>/</span><span class="hs-num">2</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>back</span>  <span style="color:red;">=</span> <span>roundedRect</span> <span>cardWidth</span> <span>cardHeight</span> <span>cardCorners</span> <span>#</span> <span>fc</span> <span>white</span>
<span>&gt;</span>           <span>#</span> <span>lc</span> <span style="color:red;">(</span><span style="color:blue;font-weight:bold;">case</span> <span>s</span> <span style="color:blue;font-weight:bold;">of</span> <span style="color:red;">{</span> <span>FZ</span> <span style="color:red;">-&gt;</span> <span>green</span><span style="color:red;">;</span> <span style="color:blue;font-weight:bold;">_</span> <span style="color:red;">-&gt;</span> <span>black</span> <span style="color:red;">}</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>label</span> <span style="color:red;">=</span> <span>vsep</span> <span class="hs-num">0.1</span> <span style="color:red;">[</span><span>text'</span> <span style="color:red;">(</span><span>rankStr</span> <span>r</span><span style="color:red;">)</span><span style="color:red;">,</span> <span>text'</span> <span style="color:red;">(</span><span>suitSymbol</span> <span>s</span><span style="color:red;">)</span><span style="color:red;">]</span>
<span>&gt;</span>           <span>#</span> <span>scale</span> <span class="hs-num">0.6</span> <span>#</span> <span>fc</span> <span style="color:red;">(</span><span>suitColor</span> <span>s</span><span style="color:red;">)</span> <span>#</span> <span>lw</span> <span>none</span>
<span>&gt;</span>           <span>#</span> <span>translate</span> <span style="color:red;">(</span><span style="color:red;">(</span><span style="color:green;">-</span><span class="hs-num">0.9</span><span style="color:red;">)</span> <span>^&amp;</span> <span class="hs-num">1.5</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>cardContent</span> <span>n</span>
<span>&gt;</span>       <span style="color:red;">|</span> <span>n</span> <span>&lt;=</span> <span class="hs-num">10</span>   <span style="color:red;">=</span> <span>pips</span> <span>n</span>
<span>&gt;</span>       <span style="color:red;">|</span> <span>otherwise</span> <span style="color:red;">=</span> <span>face</span> <span>n</span> <span>#</span> <span>fc</span> <span style="color:red;">(</span><span>suitColor</span> <span>s</span><span style="color:red;">)</span> <span>#</span> <span>lw</span> <span>none</span>
<span>&gt;</span>                            <span>#</span> <span>sized</span> <span style="color:red;">(</span><span>mkWidth</span> <span style="color:red;">(</span><span>cardWidth</span> <span>*</span> <span class="hs-num">0.6</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pip</span> <span style="color:red;">=</span> <span>suitDia</span> <span>s</span> <span>#</span> <span>scale</span> <span class="hs-num">1.1</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">1</span> <span style="color:red;">=</span> <span>pip</span> <span>#</span> <span>scale</span> <span class="hs-num">2</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">2</span> <span style="color:red;">=</span> <span>mirror</span> <span style="color:red;">(</span><span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">2</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">3</span> <span style="color:red;">=</span> <span>pips</span> <span class="hs-num">2</span> <span></span> <span>pip</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">4</span> <span style="color:red;">=</span> <span>mirror</span> <span style="color:red;">(</span><span>pair</span> <span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">2</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">5</span> <span style="color:red;">=</span> <span>pips</span> <span class="hs-num">4</span> <span></span> <span>pip</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">6</span> <span style="color:red;">=</span> <span>mirror</span> <span style="color:red;">(</span><span>pair</span> <span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">2</span><span style="color:red;">)</span> <span></span> <span>pair</span> <span>pip</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">7</span> <span style="color:red;">=</span> <span>pips</span> <span class="hs-num">6</span> <span></span> <span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">1</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">8</span> <span style="color:red;">=</span> <span>pips</span> <span class="hs-num">6</span> <span></span> <span>mirror</span> <span style="color:red;">(</span><span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">1</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">9</span> <span style="color:red;">=</span> <span>mirror</span> <span style="color:red;">(</span><span>pair</span> <span style="color:red;">(</span><span>pip</span> <span>#</span> <span>up</span> <span style="color:red;">(</span><span class="hs-num">2</span><span>/</span><span class="hs-num">3</span><span style="color:red;">)</span> <span></span> <span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">2</span><span style="color:red;">)</span><span style="color:red;">)</span> <span></span> <span>pip</span> <span>#</span> <span>up</span> <span style="color:red;">(</span><span style="color:blue;font-weight:bold;">case</span> <span>finToInt</span> <span>s</span> <span style="color:blue;font-weight:bold;">of</span> <span style="color:red;">{</span><span class="hs-num">1</span> <span style="color:red;">-&gt;</span> <span style="color:green;">-</span><span class="hs-num">0.1</span><span style="color:red;">;</span> <span class="hs-num">3</span> <span style="color:red;">-&gt;</span> <span class="hs-num">0</span><span style="color:red;">;</span> <span style="color:blue;font-weight:bold;">_</span> <span style="color:red;">-&gt;</span> <span class="hs-num">0.1</span><span style="color:red;">}</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pips</span> <span class="hs-num">10</span> <span style="color:red;">=</span> <span>mirror</span> <span style="color:red;">(</span><span>pair</span> <span style="color:red;">(</span><span>pip</span> <span>#</span> <span>up</span> <span style="color:red;">(</span><span class="hs-num">2</span><span>/</span><span class="hs-num">3</span><span style="color:red;">)</span> <span></span> <span>pip</span> <span>#</span> <span>up</span> <span class="hs-num">2</span><span style="color:red;">)</span> <span></span> <span>pip</span> <span>#</span> <span>up</span> <span style="color:red;">(</span><span class="hs-num">4</span><span>/</span><span class="hs-num">3</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pips</span> <span style="color:blue;font-weight:bold;">_</span> <span style="color:red;">=</span> <span>mempty</span>
<span>&gt;</span>     <span>up</span> <span>n</span> <span style="color:red;">=</span> <span>translateY</span> <span style="color:red;">(</span><span class="hs-num">0.5</span><span>*</span><span>n</span><span style="color:red;">)</span>
<span>&gt;</span>     <span>pair</span> <span>d</span> <span style="color:red;">=</span> <span>hsep</span> <span class="hs-num">0.4</span> <span style="color:red;">[</span><span>d</span><span style="color:red;">,</span> <span>d</span><span style="color:red;">]</span> <span>#</span> <span>centerX</span>
<span>&gt;</span>     <span>face</span> <span class="hs-num">11</span> <span style="color:red;">=</span> <span>squares</span> <span>#</span> <span>frame</span> <span class="hs-num">0.1</span>
<span>&gt;</span>     <span>face</span> <span class="hs-num">12</span> <span style="color:red;">=</span> <span>loopyStar</span>
<span>&gt;</span>     <span>face</span> <span class="hs-num">13</span> <span style="color:red;">=</span> <span>burst</span> <span>#</span> <span>centerXY</span>
<span>&gt;</span>     <span>squares</span>
<span>&gt;</span>       <span style="color:red;">=</span> <span>strokeP</span> <span style="color:red;">(</span><span>mirror</span> <span style="color:red;">(</span><span>square</span> <span class="hs-num">1</span> <span>#</span> <span>translate</span> <span style="color:red;">(</span><span class="hs-num">0.2</span> <span>^&amp;</span> <span class="hs-num">0.2</span><span style="color:red;">)</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span>       <span>#</span> <span>fillRule</span> <span>EvenOdd</span>
<span>&gt;</span>     <span>loopyStar</span>
<span>&gt;</span>       <span style="color:red;">=</span> <span>regPoly</span> <span class="hs-num">7</span> <span class="hs-num">1</span>
<span>&gt;</span>       <span>#</span> <span>star</span> <span style="color:red;">(</span><span>StarSkip</span> <span class="hs-num">3</span><span style="color:red;">)</span>
<span>&gt;</span>       <span>#</span> <span>pathVertices</span>
<span>&gt;</span>       <span>#</span> <span>map</span> <span style="color:red;">(</span><span>cubicSpline</span> <span>True</span><span style="color:red;">)</span>
<span>&gt;</span>       <span>#</span> <span>mconcat</span>
<span>&gt;</span>       <span>#</span> <span>fillRule</span> <span>EvenOdd</span>
<span>&gt;</span>     <span>burst</span>
<span>&gt;</span>       <span style="color:red;">=</span> <span style="color:red;">[</span><span style="color:red;">(</span><span class="hs-num">1</span><span style="color:red;">,</span><span class="hs-num">5</span><span style="color:red;">)</span><span style="color:red;">,</span> <span style="color:red;">(</span><span class="hs-num">1</span><span style="color:red;">,</span><span style="color:green;">-</span><span class="hs-num">5</span><span style="color:red;">)</span><span style="color:red;">]</span> <span>#</span> <span>map</span> <span>r2</span> <span>#</span> <span>fromOffsets</span>
<span>&gt;</span>       <span>#</span> <span>iterateN</span> <span class="hs-num">13</span> <span style="color:red;">(</span><span>rotateBy</span> <span style="color:red;">(</span><span style="color:green;">-</span><span class="hs-num">1</span><span>/</span><span class="hs-num">13</span><span style="color:red;">)</span><span style="color:red;">)</span>
<span>&gt;</span>       <span>#</span> <span>mconcat</span> <span>#</span> <span>glueLine</span>
<span>&gt;</span>       <span>#</span> <span>strokeLoop</span>
<span>&gt;</span> 
<span>&gt;</span> <span>renderGame</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Natural</span> <span>n</span><span style="color:red;">,</span> <span>Natural</span> <span>a</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>Game</span> <span style="color:red;">(</span><span>Player</span> <span>a</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Rank</span> <span>b</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Suit</span> <span>n</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>Diagram</span> <span>B</span>
<span>&gt;</span> <span>renderGame</span> <span>g</span> <span style="color:red;">=</span> <span>hsep</span> <span class="hs-num">0.5</span> <span>$</span> <span>map</span> <span style="color:red;">(</span><span style="color:red;">\</span><span>p</span> <span style="color:red;">-&gt;</span> <span>renderHand</span> <span>p</span> <span>$</span> <span>hand</span> <span>p</span> <span>g</span><span style="color:red;">)</span> <span>universe</span>
<span>&gt;</span> 
<span>&gt;</span> <span>renderHand</span> <span style="color:red;">::</span> <span>Natural</span> <span>n</span> <span style="color:red;">=&gt;</span> <span>Player</span> <span>a</span> <span style="color:red;">-&gt;</span> <span>Hand</span> <span style="color:red;">(</span><span>Rank</span> <span>b</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Suit</span> <span>n</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>Diagram</span> <span>B</span>
<span>&gt;</span> <span>renderHand</span> <span>p</span> <span>h</span> <span style="color:red;">=</span> <span>vsep</span> <span class="hs-num">0.2</span> <span>$</span> <span>map</span> <span style="color:red;">(</span><span>renderCard</span> <span>.</span> <span>h</span><span style="color:red;">)</span> <span>universe</span>
</code></pre>
<div class="references">

</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1">
<p>
If we could program in Homotopy Type Theory, we could make this very formal by using the notion of cardinal-finiteness developed in <a href="http://www.cis.upenn.edu/~byorgey/hosted/thesis.pdf">my dissertation</a> (see section 2.4).<a href="#fnref1">↩︎</a>
</p>
</li>
<li id="fn2">
<p>
In practice this function on cards will always be a permutation, though the Haskell type system is not enforcing that at all. An early version of this code used the <code>Iso</code> type from <code>lens</code>, but it wasn’t really paying its way.<a href="#fnref2">↩︎</a>
</p>
</li>
</ol>
</div>

</section>

<script data-isso="http://155.138.238.211" src="http://155.138.238.211/js/embed.min.js"></script>
<section id="isso-thread"></section>


        </article>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
