<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>blog :: Brent -> [String] - Competitive Programming in Haskell: Union-Find</title>
        <!-- <link rel="stylesheet" type="text/css" href="/css/default.css" /> -->
        <link rel="stylesheet" type="text/css" href="../../../../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../../../../css/tufte.css" />

        <!-- See https://katex.org/docs/browser -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
        <link rel="alternate" type="application/rss+xml" href="../../../../rss.xml" title="RSS Feed">

        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    </head>
    <body>
        <div id="header">
            <div id="navigation" style="position: relative">
                <a href="../../../../">Home</a> •
                <a href="../../../../about.html">About</a> •
                <a href="../../../../rss.xml">RSS</a> •
                <a href="../../../../posts/blogliterately.html">BlogLiterately</a> •
                <a href="../../../../posts/catsters-guide-2.html">Catsters Guide</a> •
                <a href="../../../../posts/how-to-print-things.html">How To Print
                  Things</a> •
                <a class="no-tufte-underline" href="https://ko-fi.com/I3I5KYUQX">
                  <img src="https://ko-fi.com/img/githubbutton_sm.svg" alt="ko-fi" style="position: absolute; top: 50%;
                  left: 50%; transform: translate(-70%, -50%)" />
                </a>
            </div>
        </div>

        <article>
          
<a href="../../../../posts/2024/10/14/MonadRandom-version-bump.html">« MonadRandom: major or minor version bump?</a>


<span style="margin-left: 2em">

</span>


<h1>Competitive Programming in Haskell: Union-Find</h1>

<div class="info">
  Posted on October 23, 2024
  
  
  <br />
  Tagged <a title="All pages tagged 'challenge'." href="../../../../tag/challenge.html" rel="tag">challenge</a>, <a title="All pages tagged 'Kattis'." href="../../../../tag/Kattis.html" rel="tag">Kattis</a>, <a title="All pages tagged 'union-find'." href="../../../../tag/union-find.html" rel="tag">union-find</a>
  
</div>

<section>
<section id="union-find" class="level2">
<h2>Union-find</h2>
<p>A <em>union-find</em> data structure (also known as a <em>disjoint set</em> data
structure) keeps track of a <em>collection of disjoint sets</em>, typically
with elements drawn from <span class="math inline">\(\{0, \dots, n-1\}\)</span>. For example, we might
have the sets</p>
<p><span class="math inline">\(\{1,3\}, \{0, 4, 2\}, \{5, 6, 7\}\)</span></p>
<p>A union-find structure must support three basic operations:</p>
<ul>
<li><p>We can <span class="math inline">\(\mathit{create}\)</span> a union-find structure with <span class="math inline">\(n\)</span> singleton sets
<span class="math inline">\(\{0\}\)</span> through <span class="math inline">\(\{n-1\}\)</span>. (Alternatively, we could support two
operations: creating an empty union-find structure, and adding a new
singleton set; occasionally this more fine-grained approach is
useful, but we will stick with the simpler <span class="math inline">\(\mathit{create}\)</span> API for now.)</p></li>
<li><p>We can <span class="math inline">\(\mathit{find}\)</span> a given <span class="math inline">\(x \in \{0, \dots, n-1\}\)</span>, returning some sort
of “name” for the set <span class="math inline">\(x\)</span> is in. It doesn’t matter what these names
are; the only thing that matters is that for any <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>,
<span class="math inline">\(\mathit{find}(x) = \mathit{find}(y)\)</span> if and only if <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are in the same
set. The most important application of <span class="math inline">\(\mathit{find}\)</span> is therefore to check
whether two given elements are in the same set or not.</p></li>
<li><p>We can <span class="math inline">\(\mathit{union}\)</span> two elements, so the sets that contain them become
one set. For example, if we <span class="math inline">\(\mathit{union}(2,5)\)</span> then we would have</p>
<p><span class="math inline">\(\{1,3\}, \{0, 4, 2, 5, 6, 7\}\)</span></p></li>
</ul>
<p>Note that <span class="math inline">\(\mathit{union}\)</span> is a one-way operation: once two sets have been
unioned together, there’s no way to split them apart again. (If both
merging and splitting are required, one can use a <a href="XXX">link/cut
tree</a>, which is very cool, and possibly something I will write
about in the future, but much more complex.) However, these three
operations are enough for union-find structures to have a large number
of interesting applications!</p>
<p>In addition, we can annotate each set with a value taken from some
commutative semigroup. When creating a new union-find structure, we
must specify the starting value for each singleton set; when unioning
two sets, we combine their annotations via the semigroup operation.</p>
<ul>
<li>For example, we could annotate each set with its <em>size</em>; singleton
sets always start out with size 1, and every time we union two sets
we add their sizes.</li>
<li>We could also annotate each set with the sum, product, maximum, or
minumum of all its elements.</li>
</ul>
<p>We typically use a commutative semigroup, as in the examples above;
this guarantees that a given set will always have the same value,
regardless of the sequence of union-find operations that were used to
create it. However, we can actually use any binary operation at all
(<em>i.e.</em> any <em>magma</em>), in which case the annotations on a set may
reflect the precise tree of calls to |union| that were used to
construct it.</p>
<ul>
<li><p>For example, we could annotate each set with a list of values, and
combine annotations using list concatenation; the order of elements
in the list associated to a given set will depend on the order of
arguments to |union|.</p></li>
<li><p>We could also annotate each set with a binary tree storing values at
the leaves. XXX each singleton starts as leaf, to combine make a
new branch node. Then each set is annotated with the precise tree
of union calls made.</p></li>
</ul>
</section>
<section id="implementing-union-find" class="level2">
<h2>Implementing union-find</h2>
<p>My implementation is based on <a href="https://kseo.github.io/posts/2014-01-30-implementing-union-find-in-haskell.html">one by Kwang Yul
Seo</a>,
but I have modified it quite a bit. This blog post is not a
comprehensive union-find tutorial (XXX link to other resources), but I
will explain some things as we go. First, a few imports.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">UnionFind</span> <span class="kw">where</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array.ST</span></span></code></pre></div>
<p>Now, let’s see the definition of the <code>UnionFind</code> type itself. Note
that the elements are also sometimes called “nodes”, since, as we will
see, they are organized into a forest.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UnionFind</span> s m <span class="ot">=</span> <span class="dt">UnionFind</span></span></code></pre></div>
<p>The basic idea is to maintain three mappings:</p>
<ul>
<li>First, each element is mapped to a <em>parent</em> (another element).
There are no cycles, except that some elements can be their own
parents. This means that the elements form a <em>forest</em> of rooted
trees (XXX link?), with the self-parenting elements as roots. We
store the parent mapping as an <code>STUArray</code> (XXX see reference) for
efficiency. XXX picture?</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> parent ::</span> <span class="op">!</span>(<span class="dt">STUArray</span> s <span class="dt">Node</span> <span class="dt">Node</span>)</span></code></pre></div>
<ul>
<li><p>Each element is also mapped to a <em>size</em>. We maintain the
invariant that for any element which is a root (<em>i.e.</em> any element
which is its own parent), we store the size of the tree rooted at
that element. The size associated to other, non-root elements
does not matter.</p>
<p>XXX note can also be done with <em>height</em> instead of size, but makes
not much practical difference.</p></li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> sz ::</span> <span class="op">!</span>(<span class="dt">STUArray</span> s <span class="dt">Node</span> <span class="dt">Int</span>)</span></code></pre></div>
<ul>
<li>Finally, we map each element to a custom annotation value; again,
we only care about the annotation values for root nodes.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ann ::</span> <span class="op">!</span>(<span class="dt">STArray</span> s <span class="dt">Node</span> m)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>To <span class="math inline">\(\mathit{create}\)</span> a new union-find structure, we need a size and a
function mapping each element to an initial annotation value. Every
element starts as its own parent, with a size of 1. For convenience,
we can also make a variant of <code>createWith</code> that gives every element
the same constant annotation value.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">createWith ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Node</span> <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s m)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>createWith n m <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnionFind</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> newListArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) [<span class="dv">0</span> <span class="op">..</span> n <span class="op">-</span> <span class="dv">1</span>]    <span class="co">-- Every node is its own parent</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> newArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) <span class="dv">1</span>                   <span class="co">-- Every node has size 1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> newListArray (<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>) (<span class="fu">map</span> m [<span class="dv">0</span> <span class="op">..</span> n <span class="op">-</span> <span class="dv">1</span>])</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">create ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s m)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>create n m <span class="ot">=</span> createWith n (<span class="fu">const</span> m)</span></code></pre></div>
<p>To perform a <span class="math inline">\(\mathit{find}\)</span> operation, we keep following <em>parent</em>
references up the tree until reaching a root. We can also do a cool
optimization known as <em>path compression</em> (XXX link): after finding a
root, we can directly update the parent of every node along the path
we just traversed to be the root. This means <span class="math inline">\(\mathit{find}\)</span> can be very
efficient, since it tends to create trees that are extremely wide and
shallow.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">find ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Node</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>find uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> readArray parent x</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> p <span class="op">/=</span> x</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>      r <span class="ot">&lt;-</span> find uf p</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>      writeArray parent x r</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> r</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">pure</span> x</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">connected ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Bool</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>connected uf x y <span class="ot">=</span> (<span class="op">==</span>) <span class="op">&lt;$&gt;</span> find uf x <span class="op">&lt;*&gt;</span> find uf y</span></code></pre></div>
<p>Finally, to implement <span class="math inline">\(\mathit{union}\)</span>, we find the roots of the given nodes;
if they are not the same we make the root with the smaller tree the
child of the other root, combining sizes and annotations as
appropriate.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">union ::</span> (<span class="dt">Semigroup</span> m) <span class="ot">=&gt;</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>union uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x y <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> find uf y</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  when (x <span class="op">/=</span> y) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    sx <span class="ot">&lt;-</span> readArray sz x</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    sy <span class="ot">&lt;-</span> readArray sz y</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    mx <span class="ot">&lt;-</span> readArray ann x</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    my <span class="ot">&lt;-</span> readArray ann y</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> sx <span class="op">&lt;</span> sy</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        writeArray parent x y</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        writeArray sz y (sx <span class="op">+</span> sy)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        writeArray ann y (mx <span class="op">&lt;&gt;</span> my)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        writeArray parent y x</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        writeArray sz x (sx <span class="op">+</span> sy)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        writeArray ann x (mx <span class="op">&lt;&gt;</span> my)</span></code></pre></div>
<p>XXX note <code>x &lt;- find uf x</code> trick
XXX note have to be careful with order when combining annotations</p>
<p>XXX Finally, a few utility functions. First, one to find the size of
the set containing a given node:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>size uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  readArray sz x</span></code></pre></div>
<p>XXX Also a couple to update and fetch the custom annotation value
associated to the set containing a given node.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateAnn ::</span> (<span class="dt">Semigroup</span> m) <span class="ot">=&gt;</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>updateAnn uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  old <span class="ot">&lt;-</span> readArray ann x <span class="co">-- modifyArray is not available in Kattis test environment</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  writeArray ann x (old <span class="op">&lt;&gt;</span> m)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">getAnn ::</span> <span class="dt">UnionFind</span> s m <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s m</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>getAnn uf<span class="op">@</span>(<span class="dt">UnionFind</span> {<span class="op">..</span>}) x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> find uf x</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  readArray ann x</span></code></pre></div>
</section>
<section id="challenge" class="level2">
<h2>Challenge</h2>
<p>For next time, I challenge you to solve <a href="XXX">Duck Journey</a> + other problems?</p>
</section>

</section>

<script data-isso="https://comments.byorgey.com/" src="https://comments.byorgey.com/js/embed.min.js"></script>
<section id="isso-thread" data-title="Competitive Programming in Haskell: Union-Find">
  <noscript>Javascript needs to be activated to view comments.</noscript>
</section>



        </article>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
