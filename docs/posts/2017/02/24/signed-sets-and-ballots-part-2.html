<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>blog :: Brent -> [String] - Signed sets and ballots, part 2</title>
        <!-- <link rel="stylesheet" type="text/css" href="/css/default.css" /> -->
        <link rel="stylesheet" type="text/css" href="../../../../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../../../../css/tufte.css" />

        <!-- See https://katex.org/docs/browser -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../../../../">Home</a> •
                <a href="../../../../about.html">About</a> •
                <a href="../../../../posts/blogliterately.html">BlogLiterately</a> •
                <a href="../../../../posts/catsters-guide-2.html">Catsters Guide</a> •
                <a href="../../../../posts/how-to-print-things.html">How To Print Things</a>
            </div>
        </div>

        <article>
          
<a href="../../../../posts/2017/02/20/signed-sets-and-ballots-part-1.html">« Signed sets and ballots, part 1</a>


<span style="margin-left: 2em">

<a href="../../../../posts/2017/02/27/signed-sets-and-ballots-and-naturality.html">» Signed sets and ballots and naturality</a>

</span>


<h1>Signed sets and ballots, part 2</h1>

<div class="info">
  Posted on February 24, 2017
  
  
  <br />
  Tagged <a title="All pages tagged 'ballots'." href="../../../../tag/ballots.html" rel="tag">ballots</a>, <a title="All pages tagged 'bijection'." href="../../../../tag/bijection.html" rel="tag">bijection</a>, <a title="All pages tagged 'involution'." href="../../../../tag/involution.html" rel="tag">involution</a>, <a title="All pages tagged 'natural'." href="../../../../tag/natural.html" rel="tag">natural</a>, <a title="All pages tagged 'sets'." href="../../../../tag/sets.html" rel="tag">sets</a>, <a title="All pages tagged 'signed'." href="../../../../tag/signed.html" rel="tag">signed</a>, <a title="All pages tagged 'species'." href="../../../../tag/species.html" rel="tag">species</a>, <a title="All pages tagged 'virtual'." href="../../../../tag/virtual.html" rel="tag">virtual</a>
  
</div>

<section>
<p>
Recall, from <a href="https://byorgey.wordpress.com/2017/02/20/signed-sets-and-ballots-part-1/">my previous post</a>, that our goal is to find a <em>combinatorial</em> proof showing the correspondence between signed sets and signed ballots, where a <em>signed set</em> is just a set of <span class="math inline">\(n\)</span> elements, considered positive or negative according to the parity of <span class="math inline">\(n\)</span>, and a <em>signed ballot</em> is an ordered list of sets, considered positive or negative according to the parity of the number of sets.
</p>
<p>
So, how should such a proof look? For a given number of labels <span class="math inline">\(n\)</span>, there is a single signed set structure, which is just the set of labels itself (with a sign depending on the parity of <span class="math inline">\(n\)</span>). On the other hand, there are lots of ballots on <span class="math inline">\(n\)</span> labels; the key is that some are positive and some are negative, since the sign of the ballots depends on the parity of the number of parts, not the number of labels. For example, consider <span class="math inline">\(n = 3\)</span>. There is a single (negative) signed set structure:
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/c8dadbdd1a4a1256.png" />
</p>
</div>
<p>
(I will use a dashed blue line to indicate negative things, and a solid black line for positive things.)
</p>
<p>
On the other hand, as we saw <a href="https://byorgey.wordpress.com/2017/02/20/signed-sets-and-ballots-part-1/">last time</a>, there are 13 ballot structures on 3 labels, some positive and some negative:
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/1c54d7738a0e2be6.png" />
</p>
</div>
<p>
In this example, it is easy to see that most of the positives and negatives cancel, with exactly one negative ballot left over, which corresponds with the one negative set. As another example, when <span class="math inline">\(n = 4\)</span>, there is a single positive set, and 75 signed ballots:
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/55d603bded1137d5.png" />
</p>
</div>
<p>
This time it is not quite so easy to tell at a glance (at least not the way I have arranged the ballots in the above picture!), but in fact one can verify that there are exactly 37 negative ballots and 38 positive ones, again cancelling to match the one positive set.
</p>
<p>
What we need to show, then, is that we can pair up the ballots in such a way that positive ballots are matched with negative ballots, with exactly one ballot of the appropriate sign left to be matched with the one signed set. This is known as a <em>signed involution</em>: an involution is a function which is its own inverse, so it matches things up in pairs; a signed involution sends positive things to negative things and vice versa, except for any fixed points.
</p>
<p>
In order to do this, we will start by assuming the set of labels is linearly ordered. In one sense this is no big deal, since for any finite set of labels we can always just pick an arbitrary ordering, if there isn’t an “obvious” ordering to use already. On the other hand, it means that the correspondence will be specific to the chosen linear ordering. All other things being equal, we would prefer a correspondence that depends solely on the structure of the ballots, and not on any structure inherent to the labels. I will have quite a bit more to say about this in my third and (probably) final post on the topic. But for today, let’s just see how the correspondence works, given the assumption of a linear order on the labels. I came up with this proof independently while contemplating <a href="http://akc.is/blog/2017-02-18-Inverse-species-and-sign-reversing-involutions.html">Anders Claesson’s post</a>, though it turns out that the exact same proof is already in <a href="http://www.combinatorics.org/ojs/index.php/eljc/article/view/v21i4p16">a paper by Claesson and Hannah</a> (in any case it is really just a small lemma, the sort of thing you might give as a homework problem in an undergraduate course on combinatorics).
</p>
<p>
Given some ballot, find the <em>smallest</em> label. For example, if the labels are <span class="math inline">\(\{1, \dots, n\}\)</span> as in the examples so far, we will find the label <span class="math inline">\(1\)</span>.
</p>
<ul>
<li>
<p>
If the smallest label is contained in some part together with at least one other label, separate it out into its own part by itself, and put it to the right of its former part. Like this:
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/aca212b025804418.png" />
</p>
</div>
</li>
<li>
<p>
On the other hand, if the smallest label is in a part by itself, merge it with the part on the left (if one exists). This is clearly the inverse of the above operation.
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/5f0f2b812d6bc1a0.png" />
</p>
</div>
</li>
<li>
<p>
The only case we haven’t handled is when the smallest label is in a part by itself which is the <em>leftmost</em> part in the ballot. In that case, we leave that part alone, switch to considering the <em>second</em>-smallest label, and recursively carry out the involution on the remainder of the ballot.
</p>
<p>
For example:
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/17a4dd855ed2e8c4.png" />
</p>
</div>
<p>
In this case we find the smallest label (1) in a part by itself in the leftmost position, so we leave it where it is and recurse on the remainder of the ballot. Again, we find the smallest remaining label (2) by itself and leftmost, so we recurse again. This time, we find the smallest remaining label (3) in a part with one other label, so we separate it out and place it to the right.
</p>
</li>
</ul>
<p>
This transformation on ballots is clearly reversible. The only ballots it doesn’t change are ballots with each label in its own singleton part, sorted from smallest to biggest, like this:
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/c60ed358cf8efa8e.png" />
</p>
</div>
<p>
In this case the algorithm recurses through the whole ballot and finds each smallest remaining label in the leftmost position, ultimately doing nothing. Notice that a sorted ballot of singletons has the same sign as the signed set on the same labels, namely, <span class="math inline">\((-1)^n\)</span>. In any other case, we can see that the algorithm matches positive ballots to negative and vice versa, since it always changes the number of parts by 1, either splitting one part into two or merging two parts into one.
</p>
<p>
Here’s my implementation of the involution in Haskell:
</p>
<pre><code>type Ballot = [[Int]]

ballotInv :: Ballot -&gt; Ballot
ballotInv = go 1
  where
    go _ [] = []
    go s ([a]:ps)
      | s == a = [a] : go (s+1) ps
    go s (p:ps)
      | s `elem` p = delete s p : [s] : ps
    go s (p:[a]:ps)
      | s == a = sort (a:p) : ps
    go s (p:ps) = p : go s ps</code></pre>
<p>
(The call to <code>sort</code> is not strictly necessary, but I like to keep each part canonically sorted.)
</p>
<p>
Here again are the 13 signed ballots for <span class="math inline">\(n = 3\)</span>, this time arranged so that the pair of ballots in each row correspond to each other under the involution, with the leftover, sorted ballot by itself at the top.
</p>
<div style="text-align:center;">
<p>
<img src="http://byorgey.files.wordpress.com/2017/02/99df466df8234d85.png" />
</p>
</div>
<p>
If you’d like to see an illustration of the correspondence for <span class="math inline">\(n = 4\)</span>, you can <a href="https://byorgey.files.wordpress.com/2017/02/ballots41.png">find it here</a> (I didn’t want to include inline since it’s somewhat large).
</p>
<p>
This completes the proof that signed sets and signed ballots correspond. But did we really need that linear order on the labels? Tune in next time to find out!
</p>

</section>

<script data-isso="http://155.138.238.211" src="http://155.138.238.211/js/embed.min.js"></script>
<section id="isso-thread"></section>


        </article>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
