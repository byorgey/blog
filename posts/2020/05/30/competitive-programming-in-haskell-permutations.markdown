---
title: 'Competitive programming in Haskell: permutations'
published: 2020-05-30T14:00:01Z
categories: competitive programming,haskell
tags: cipher,cycle,decomposition,GCRT,Kattis,permutation,substitution
---

<p>In my previous post I challenged you to solve <a href="https://open.kattis.com/problems/substitution">The Power of Substitution</a>. This problem presents us with a substitution cipher, and asks how many times we would have to iterate the encoding process in order to turn a given message into a given encryption.</p>
<h2 id="a-non-solution">A non-solution</h2>
<p>Several commenters mentioned that they tried some sort of straightforward brute force approach: just iterate the encoding process and count how many iterations are needed to reach the specified encryption. This certainly works for the provided sample inputs. However, I hinted that this approach likely wouldn’t fit within Kattis’s time limit for the other, secret, test cases.</p>
<p>How did I know this solution would exceed the time limit? It is <em>not</em> just an issue of using efficient data structures! Even if someone told me they coded this straightforward solution in C++, I would have the same reaction. The problem specifies that the answer should be at most $10^9$—and, as we will see, it is not hard to come up with test cases where the answer is indeed that large—and the simple fact is that counting to $10^9$ and applying the encryption at each step (which requires iterating through a list of length 200) is definitely going to take more than 1 second. A useful rule of thumb that I learned from <a href="https://cpbook.net/">Competitive Programming 3</a> is $10^8$ operations per second. (Of course your processor can carry out much more than $10^8$ <em>instructions</em> per second, but in practice this rule of thumb seems to work remarkably well for predicting run times up to the right order of magnitude.)</p>
<h2 id="cycle-decomposition-of-permutations">Cycle decomposition of permutations</h2>
<p>The given encoding, of course, is a <em>permutation</em> (the problem specifies only that it will be <em>one-to-one</em>, but <a href="https://mathlesstraveled.com/2020/03/17/ways-to-prove-a-bijection/">any one-to-one endofunction on a finite set must in fact be a permtuation</a>). Let’s call it $p$. If we start with an arbitrary $m$ and repeatedly apply $p$—that is, $m, p(m), p^2(m), p^3(m), \dots$—what happens? Of course, because of the pigeonhole principle, the sequence must eventually repeat. But actually, something stronger is true: because $p$ is a permutation, the first repeated value must be $m$ itself. For suppose that $p^i(m) = p^j(m)$ was the first repeated value in the sequence. But then since $p$ is one-to-one, it must be the case that $p^{i-1}(m) = p^{j-1}(m)$ as well, which means $p^{i-2}(m) = p^{j-2}(m)$, and so on up to $m = p^0(m) = p^{j-i}(m)$.</p>
<p>So in fact if we start at an arbitrary $m$ and iterate $p$, we will find a cycle that includes $m$ (including the possibility of a trivial length-1 cycle if $p(m) = m$). If there are other elements not included in $m$’s cycle, we can pick any one of them and repeat the process to find another cycle (which can’t possibly overlap at all with $m$’s cycle—do you see why?). In general, any permutation can be decomposed in this way into a collection of disjoint cycles.</p>
<h2 id="crt-to-the-rescue">CRT to the rescue</h2>
<p>This idea of cycle decomposition is the key to unlocking the problem. Think about what happens to a particular letter $m_i$ in the message, which we eventually want to become $c_i$. This will happen after applying the permutation some small number of times $j$, such that $p^j(m_i) = c_i$. (In general, of course, it would be quite possible that $m_i$ and $c_i$ are not in the same cycle at all, and so $m_i$ will never turn into $c_i$ no matter how many times we apply $p$; but the problem statement guarantees that this will not be the case.)</p>
<p>The problem, of course, is that all the other letters may not be encrypted properly after only $j$ encryption steps, in which case we need to keep going until all the cycles line up. Suppose $m_i$ and $c_i$ are in a cycle of length $n$. That means applying the encryption $n$ times to $c_i$ will result in $c_i$ again (and not before). Thus, we will get $c_i$ after $j$ steps and then every $n$ steps thereafter ($j, j+n, j+2n, \dots$); in other words, the number of encryption steps must be equivalent to $j \pmod n$.</p>
<p>Every position in the message yields a similar modular equivalence, giving us a system of up to 200 simultaneous modular equivalences which we can solve using the <a href="https://byorgey.wordpress.com/2020/03/03/competitive-programming-in-haskell-modular-arithmetic-part-2/">generalized Chinese Remainder Theorem</a>. Incidentally, this is why the solution can be so large—if we have cycles of sizes $n_1, n_2, \dots, n_q$, then it could take up to $\mathrm{lcm}(n_1, n_2, \dots, n_q)$ iterations for them to all line up. In the special case that all the cycle sizes are relatively prime, this is just their product. So for example we could have cycles of sizes $2, 3, 5, 7, 11, 13, 17, 19, 23$, which add up to exactly $100$; the product of these is the <a href="https://en.wikipedia.org/wiki/Primorial">primorial</a> $23\# = 223\,092\,870$.</p>
<h2 id="my-solution">My solution</h2>
<p>Here is my solution. We’re going to use an <a href="https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-Unboxed.html">unboxed array</a> to represent the permutation, and <a href="https://github.com/byorgey/comprog-hs/blob/master/NumberTheory.hs">the implementation of GCRT</a> from a <a href="https://byorgey.wordpress.com/2020/03/03/competitive-programming-in-haskell-modular-arithmetic-part-2/">previous post</a>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color:green;">{-# LANGUAGE RecordWildCards #-}</span>

<span style="color:blue;font-weight:bold;">import</span>           <span>Control.Arrow</span>
<span style="color:blue;font-weight:bold;">import</span>           <span>Data.Array.Unboxed</span>

<span style="color:blue;font-weight:bold;">import</span>           <span>NumberTheory</span>
<span style="color:blue;font-weight:bold;">import</span>           <span>Scanner</span></code></pre>
<p>Here’s <code>main</code>, along with a data type to represent a single test case and a <code>Scanner</code> for reading one in. I like using record syntax to help me remember which field is which, combined with the <a href="https://ocharles.org.uk/posts/2014-12-04-record-wildcards.html"><code>RecordWildCards</code> extension</a> to unpack the data structure and get the field names as local variables.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>main</span> <span style="color:red;">=</span> <span>interact</span> <span>$</span>
  <span>runScanner</span> <span style="color:red;">(</span><span>numberOf</span> <span>tc</span><span style="color:red;">)</span> <span>&gt;&gt;&gt;</span> <span>map</span> <span style="color:red;">(</span><span>solve</span> <span>&gt;&gt;&gt;</span> <span>show</span><span style="color:red;">)</span> <span>&gt;&gt;&gt;</span> <span>unlines</span>

<span style="color:blue;font-weight:bold;">data</span> <span>TC</span> <span style="color:red;">=</span> <span>TC</span> <span style="color:red;">{</span> <span>message</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>Int</span><span style="color:red;">]</span><span style="color:red;">,</span> <span>crypt</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>Int</span><span style="color:red;">]</span><span style="color:red;">,</span> <span>subst</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>Int</span><span style="color:red;">]</span> <span style="color:red;">}</span>
  <span style="color:blue;font-weight:bold;">deriving</span> <span>Show</span>

<span>tc</span> <span style="color:red;">=</span> <span style="color:blue;font-weight:bold;">do</span>
  <span>l</span> <span style="color:red;">&lt;-</span> <span>int</span>
  <span>TC</span> <span>&lt;$&gt;</span> <span>l</span> <span>`times`</span> <span>int</span> <span>&lt;*&gt;</span> <span>l</span> <span>`times`</span> <span>int</span> <span>&lt;*&gt;</span> <span class="hs-num">100</span> <span>`times`</span> <span>int</span></code></pre>
<p>We’re going to represent a permutation as an unboxed array, which gives us nice constant-time lookup. I often use <code>Data.Array</code> or <code>Data.Array.Unboxed</code> to represent read-only information (which comes up a lot more than you might think!), giving all the benefits of fast array access with none of the complications of mutability.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color:blue;font-weight:bold;">type</span> <span>Perm</span> <span style="color:red;">=</span> <span>UArray</span> <span>Int</span> <span>Int</span></code></pre>
<p>The <em>distance</em> between $i$ and $j$ is simply the number of times we have to apply $p$ to get from $i$ to $j$. Of course this definition would hang if $i$ and $j$ are not part of the same cycle, but we know they will be. Given <code>dist</code>, we can also find the length of a cycle containing $i$ as one more than the distance from $p(i)$ to $i$. (We can’t just ask for the distance from $i$ to itself since that would return $0$.)</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>dist</span> <span style="color:red;">::</span> <span>Perm</span> <span style="color:red;">-&gt;</span> <span>Int</span> <span style="color:red;">-&gt;</span> <span>Int</span> <span style="color:red;">-&gt;</span> <span>Int</span>
<span>dist</span> <span>p</span> <span>i</span> <span>j</span> <span style="color:red;">=</span> <span>length</span> <span>$</span> <span>takeWhile</span> <span style="color:red;">(</span><span>/=</span> <span>j</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>iterate</span> <span style="color:red;">(</span><span>p</span><span>!</span><span style="color:red;">)</span> <span>i</span><span style="color:red;">)</span>

<span>cycleLen</span> <span style="color:red;">::</span> <span>Perm</span> <span style="color:red;">-&gt;</span> <span>Int</span> <span style="color:red;">-&gt;</span> <span>Int</span>
<span>cycleLen</span> <span>p</span> <span>i</span> <span style="color:red;">=</span> <span>succ</span> <span>$</span> <span>dist</span> <span>p</span> <span style="color:red;">(</span><span>p</span><span>!</span><span>i</span><span style="color:red;">)</span> <span>i</span></code></pre>
<p>Finally, we can put these pieces together: create an array for the permutation, zip together the message and desired encryption, generating a modular equivalence for each, and solve the resulting system using <code>gcrt</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>solve</span> <span style="color:red;">::</span> <span>TC</span> <span style="color:red;">-&gt;</span> <span>Int</span>
<span>solve</span> <span style="color:red;">(</span><span>TC</span><span style="color:red;">{</span><span style="color:red;">..</span><span style="color:red;">}</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span>pick</span> <span>.</span> <span>gcrt</span> <span>$</span> <span>zipWith</span> <span>modEqn</span> <span>message</span> <span>crypt</span>
  <span style="color:blue;font-weight:bold;">where</span>
    <span>p</span> <span style="color:red;">::</span> <span>UArray</span> <span>Int</span> <span>Int</span>
    <span>p</span> <span style="color:red;">=</span> <span>listArray</span> <span style="color:red;">(</span><span class="hs-num">1</span><span style="color:red;">,</span><span class="hs-num">100</span><span style="color:red;">)</span> <span>subst</span>

    <span>modEqn</span> <span>m</span> <span>c</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>fromIntegral</span> <span style="color:red;">(</span><span>dist</span> <span>p</span> <span>m</span> <span>c</span><span style="color:red;">)</span><span style="color:red;">,</span> <span>fromIntegral</span> <span style="color:red;">(</span><span>cycleLen</span> <span>p</span> <span>m</span><span style="color:red;">)</span><span style="color:red;">)</span>
    <span>pick</span> <span style="color:red;">(</span><span>Just</span> <span style="color:red;">(</span><span>z</span><span style="color:red;">,</span><span>k</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span>fromIntegral</span> <span style="color:red;">(</span><span>z</span> <span>`mod`</span> <span>k</span><span style="color:red;">)</span></code></pre>
<p>Incidentally, this code inspired me to create a <a href="https://github.com/byorgey/comprog-hs/blob/master/Util.hs"><code>Util.hs</code> in my <code>comprog-hs</code> repository</a> containing (for now) <code>fi</code> as an alias for <code>fromIntegral</code>, and <code>both</code> to apply a function to both elements of a tuple (sadly <code>lens</code> is not available in the Kattis environment). Then we can just write <code>modEqn m c = both fi (dist p m c, cycleLen p m)</code>.</p>
<h2 id="solving-bigger-instances">Solving bigger instances</h2>
<p>The above solution works because the alphabet is quite small (only $100$). However, it’s actually quite wasteful. For example, suppose that the given message consists of $200$ copies of the number $1$; then we will recompute the length of $1$’s cycle $200$ times. It’s easy to imagine a variant of this problem where both the message length and the alphabet size could be much larger. Then my solution above would be too slow. For example, suppose the permutation consists of one giant cycle of length $10^5$, and the message also has length $10^5$. We would traverse the entire cycle for every single character in the message, for a total of about $10^{10}$ operations—much too slow. This post has gotten long enough, but in another post I will show an alternative solution which I believe would work quickly enough even for such large inputs (assuming that the input was restricted such that the answer was still of a reasonable size!). The idea is to precompute the cycle decomposition of the permutation (in time proportional to the size of the alphabet), storing the information in such a way that for each pair of letters in the message and desired encryption, we can find the distance between them and the length of their cycle in constant time.</p>
<h2 id="next-up-geometry">Next up: geometry</h2>
<p>Next, I’d like to spend a few posts on the topic of geometry. I find that geometry problems work particularly well in Haskell (I don’t think I’ve solved a single geometry problem in Java). Let’s kick things off with a problem on the easier side:</p>
<div style="text-align:center;">
<p><a href="https://open.kattis.com/problems/vacuumba">Vacuumba</a></p>
</div>
<p>Have fun!</p>

