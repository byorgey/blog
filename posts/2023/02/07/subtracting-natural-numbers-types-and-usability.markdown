---
title: Subtracting natural numbers: types and usability
published: 2023-02-07T17:03:46Z
categories: projects,teaching
tags: Disco,natural,number,subtraction,types
---

<p>For several years now I have been working on a <a href="https://github.com/disco-lang/disco/#readme">functional teaching language for discrete mathematics, called Disco</a>. It has a strong static type system, subtyping, equirecursive algebraic types, built-in property-based testing, and mathematically-inspired syntax. If you want to know more about it in general, you can <a href="https://github.com/disco-lang/disco/#readme">check out the GitHub repo</a>, or <a href="https://replit.com/@BrentYorgey/Disco#README.md">give it a try on replit.com</a>.</p>
<p>In this blog I want to write about a particular usability issue surrounding the type of the subtraction operation, partly because I think some might find it interesting, and partly because forcing myself to clearly articulate possible solutions may help me come to a good resolution.</p>
<h2 id="the-problem-with-subtraction">The problem with subtraction</h2>
<p>Disco supports four basic numeric types: natural numbers $latex \mathbb{N}$, integers $latex \mathbb{Z}$, “fractional” numbers $latex \mathbb{F}$ (<em>i.e.</em> nonnegative rationals), and rational numbers $latex \mathbb{Q}$. These types form a subtyping lattice, with natural numbers being a subtype of both integers and fractionals, and integers and fractionals in turn being subtypes of the rationals. All the numeric types support addition and multiplication; the integers allow negation/subtraction, the fractionals allow reciprocals/division, and rationals allow both.</p>
<p>So what is the type of $latex x - y$? Clearly it has to be either $latex \mathbb{Z}$ or $latex \mathbb{Q}$; that’s the whole point. Natural numbers and fractional numbers are not closed under subtraction; $latex \mathbb{Z}$ and $latex \mathbb{Q}$ are precisely what we get when we start with $latex \mathbb{N}$ or $latex \mathbb{F}$ and decide to allow subtraction, <em>i.e.</em> when we throw in additive inverses for everything.</p>
<p>However, this is one of the single biggest things that trips up students. As an example, consider the following function definition:</p>
<pre><code>fact_bad : N -&gt; N
fact_bad(0) = 1
fact_bad(n) = n * fact_bad(n-1)</code></pre>
<p>This looks perfectly reasonable on the surface, and would work flawlessly at runtime. However, it <strong>does not typecheck</strong>: the argument to the recursive call must be of type $latex \mathbb{N}$, but since $latex n-1$ uses subtraction, it cannot have that type.</p>
<p>This is very annoying in practice for several reasons. The most basic reason is that, in my experience at least, it is very common: students often write functions like this without thinking about the fact that they happened to use subtraction along the way, and are utterly baffled when the function does not type check. This case is also extra annoying since it <em>would</em> work at runtime: we can clearly reason that if $latex n$ is a natural number that is not zero, then it must be $latex 1$ or greater, and hence $latex n-1$ will in fact be a natural number. Because of <a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice’s Theorem</a>, we know that every decidable type system must <em>necessarily</em> exclude some programs as untypeable which nonetheless do not “go wrong”, <em>i.e.</em> exhibit no undesirable behavior when evaluated. The above <code>fact_bad</code> function is a particularly irksome example.</p>
<p>To be clear, there is nothing wrong with the type system, which is working exactly as intended. Rather, the problem lies in the fact that this is a common and confusing issue for students.</p>
<h2 id="implementing-factorial">Implementing factorial</h2>
<p>You may be wondering how it is even possible to implement something like factorial at all without being able to subtract natural numbers. In fact, there are two good ways to implement it, but they don’t necessarily solve the problem of student confusion.</p>
<ul>
<li><p>One solution is to use an <a href="https://disco-lang.readthedocs.io/en/latest/reference/arith-pattern.html"><em>arithmetic pattern</em></a> and match on <code>n+1</code> instead of <code>n</code>, like this:</p>
<pre><code>fact_ok1 : N -&gt; N
fact_ok1(0) = 1
fact_ok1(n+1) = (n+1) * fact_ok1(n)</code></pre>
<p>This works, and it’s theoretically well-motivated, but feels somewhat unsatisfying: both because we have to repeat <code>n+1</code> and because this style of definition probably feels foreign to anyone except those who have played with a <code>Nat</code> algebraic data type (which excludes the vast majority of Discrete Math students).</p></li>
<li><p>Another solution is to use a <em>saturating subtraction</em> operator, $latex x \mathbin{\dot -} y = \max(0, x - y)$. In Disco this operator is written <code>x .- y</code>. Unlike normal subtraction, it can have the type $latex \mathbb{N} \times \mathbb{N} \to \mathbb{N}$, so we can rewrite the factorial function this way:</p>
<pre><code>fact_ok2 : N -&gt; N
fact_ok2(0) = 1
fact_ok2(n) = n * fact_ok2(n .- 1)</code></pre>
<p>The <code>.-</code> operator is also theoretically well-motivated, being the “<a href="https://en.wikipedia.org/wiki/Monus">monus</a>” operator for the commutative monoid of natural numbers under addition. However, in my experience, students are annoyed and confused by this. They often do not understand when and why they are supposed to use <code>.-</code>. Of course, better error messages could help here, as could better pedagogy. This is actually my current approach: this semester I talked about the difference between $latex \mathbb{N}$ and $latex \mathbb{Z}$ very early, hitting on the fact that $latex \mathbb{N}$ is not closed under subtraction, and explicitly made them explore the use of the <code>.-</code> operator in their first homework assignment. We’ll see how it goes!</p></li>
</ul>
<h2 id="some-tempting-and-expedient-but-wrong-solutions">Some tempting and expedient, but wrong, solutions</h2>
<p>One solution that sounds nice on the surface is to just pun the notation: why not just have a single operator <code>-</code>, but make it behave like <code>.-</code> on types without negation ($latex \mathbb{N}$ and $latex \mathbb{F}$), and like normal subtraction on $latex \mathbb{Z}$ and $latex \mathbb{Q}$? That way students wouldn’t have to remember to use one version or the other, they can just use subtraction and have it do the right thing depending on the type.</p>
<p>This would be sound from a type system point of view; that is, we would never be able to produce, say, a negative value with type $latex \mathbb{N}$. However, in the presence of subtyping and type inference, there is a subtle problem from a semantics point of view. To understand the problem, consider the following function:</p>
<pre><code>f : N -&gt; Z
f(n) = (-3) * (n - 5)</code></pre>
<p>What is the output of <code>f(3)</code>? Most people would say it should be <code>(-3) * (3 - 5) = (-3) * (-2) = 6</code>. However, if the behavior of subtraction depends on its type, it would also be sound for <code>f(3)</code> to output <code>0</code>! The input <code>3</code> and the constant <code>5</code> can both be given the type $latex \mathbb{N}$, in which case the subtraction would act as a saturating subtraction and result in <code>0</code>.</p>
<p>What’s going on here? Conceptually, one of the jobs of type inference, when subtyping is involved, is to decide where to insert type coercions. (Practically speaking, in Disco, such coercions are always no-ops; for example, all numeric values are represented as <code>Rational</code>, so <code>3 : N</code> and <code>3 : Q</code> have the same runtime representation.) An important guiding principle is that <em>the semantics of a program should not depend on where coercions are inserted</em>, and type-dependent-subtraction violates this principle. <code>f(3)</code> evaluates to either <code>6</code> or <code>0</code>, depending on whether a coercion from $latex \mathbb{N}$ to $latex \mathbb{Z}$ is inserted inside or outside the subtraction. Violating this principle can make it very difficult for anyone (let alone students!) to understand the semantics of a given program: at worst it is ambiguous or undefined; at best, it depends on understanding where coercions will be inserted.</p>
<p>What about having <code>-</code> always mean subtraction, but crash at runtime if we try to subtract natural numbers and get something less than 0? That way we can use it as long as we “know it is safe” (as in the factorial example). Unfortunately, this has the exact same issue, which the above example with <code>f(3)</code> still illustrates perfectly: <code>f(3)</code> can either evaluate to <code>6</code> or crash, depending on exactly where coercions are inserted.</p>
<h2 id="typechecking-heuristics">Typechecking heuristics?</h2>
<p>Another interesting option would be to make typechecking a bit smarter, so that instead of only keeping track of the type of each variable, we also sometimes keep track of values we statically know a variable can and can’t have in a certain context. We could then use this information to allow subtraction to have a type like $latex \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ as long as we can statically prove it is safe. For example, after matching on 0 in the first line of <code>fact_bad</code>, in the second line we know <code>n</code> cannot be <code>0</code>, and we could imagine using this information to decide that the expression <code>n - 1</code> is safe. This scheme would not change the semantics of any existing programs; it would only allow some additional programs to typecheck which did not before.</p>
<p>Of course, this would never be complete—there would always be examples of Disco programs where we can prove that a certain subtraction is safe but the heuristics don’t cover it. But it might still go a long way towards making this kind of thing less annoying. On the other hand, it makes errors even more mysterious when they do happen, and hard to understand when a program will and won’t typecheck. Perhaps it is best to just double down on the pedagogy and get students to understand the difference between $latex \mathbb{N}$ and $latex \mathbb{Z}$!</p>
<h2 id="division">Division?</h2>
<p>As a final aside, note that we have the same issue with division: <code>x / y</code> is only allowed at types $latex \mathbb{F}$ or $latex \mathbb{Q}$. If we want to divide integers, we can use a different built-in operator, <code>//</code> which does integer division, <em>i.e.</em> “rounds down”. However, this is not nearly as bad of an issue in practice, both because some students are already used to the idea of integer division (<em>e.g.</em> Python makes the same distinction), and because wanting to divide integers does not come up nearly as often, in practice, as wanting to subtract natural numbers.</p>

