---
title: Anafunctors
published: 2014-06-16T18:35:16Z
categories: category theory,math,species
tags: AC,anafunctor,axiom of choice,category,constructive,equivalence,functor,isomorphism,theory,types,unique
---

<p>This is part four in a series of posts on avoiding the axiom of choice (<a href="http://byorgey.wordpress.com/2014/05/08/avoiding-the-axiom-of-choice-part-i/">part one</a>, <a href="http://byorgey.wordpress.com/2014/05/13/unique-isomorphism-and-generalized-the/">part two</a>, <a href="http://byorgey.wordpress.com/2014/06/05/ac-and-equivalence-of-categories/">part three</a>).</p>
<p>In my <a href="http://byorgey.wordpress.com/2014/06/05/ac-and-equivalence-of-categories/">previous post</a>, we considered the “Axiom of Protoequivalence”—that is, the statement that every fully faithful, essentially surjective functor (<em>i.e.</em> every <em>protoequivalence</em>) is an equivalance—and I claimed that in a traditional setting this is equivalent to the axiom of choice. However, intuitively it feels like AP “ought to” be true, whereas AC must be rejected in constructive logic.</p>
<p>One way around this is by generalizing functors to <em>anafunctors</em>, which were introduced by <span class="citation">Makkai (1996)</span>. The original paper is difficult going, since it is full of tons of detail, poorly typeset, and can only be <a href="http://www.math.mcgill.ca/makkai/anafun/">downloaded as seven separate postscript files</a>. There is also quite a lot of legitimate depth to the paper, which requires significant categorical sophistication (more than I possess) to fully understand. However, the basic ideas are not too hard to grok, and that’s what I will present here.</p>
<p>It’s important to note at the outset that anafunctors are much more than just a technical device enabling the Axiom of Protoequivalence. More generally, if everything in category theory is supposed to be done “up to isomorphism”, it is a bit suspect that functors have to be defined for objects <em>on the nose</em>. Anafunctors can be seen as a generalization of functors, where each object in the source category is sent not just to a single object, but to an entire <em>isomorphism class</em> of objects, without privileging any particular object in the class. In other words, anafunctors are functors whose “values are specified only up to unique isomorphism”.</p>
<p>Such functors represent a many-to-many relationship between objects of $latex \mathbb{C}$ and objects of $latex \mathbb{D}$. Normal functors, as with any function, may of course map multiple objects of $latex \mathbb{C}$ to the same object in $latex \mathbb{D}$. The novel aspect is the ability to have a single object of $latex \mathbb{C}$ correspond to multiple objects of $latex \mathbb{D}$. The key idea is to add a class of “specifications” which mediate the relationship between objects in the source and target categories, in exactly the same way that a “junction table” must be added to support a many-to-many relationship in a database schema, as illustrated below:</p>
<div style="text-align:center;">
<p><img src="http://byorgey.files.wordpress.com/2014/06/f19b088cf62e288e.png" /></p>
</div>
<p>On the left is a many-to-many relation between a set of shapes and a set of numbers. On the right, this relation has been mediated by a “junction table” containing a set of “specifications”—in this case, each specification is simply a pair of a shape and a number—together with two mappings (one-to-many relations) from the specifications to both of the original sets, such that a specification maps to a shape $latex s$ and number $latex n$ if and only if $latex s$ and $latex n$ were originally related.</p>
<p>In particular, an <em>anafunctor</em> $latex F : \mathbb{C} \to \mathbb{D}$ is defined as follows.</p>
<ul>
<li>There is a class $latex S$ of <em>specifications</em>.</li>
<li>There are two functions $latex \mathrm{Ob}\ \mathbb{C}  \stackrel{\overleftarrow{F}}{\longleftarrow} S  \stackrel{\overrightarrow{F}}{\longrightarrow} \mathrm{Ob}\ \mathbb{D}$ mapping specifications to objects of $latex \mathbb{C}$ and $latex \mathbb{D}$.</li>
</ul>
<p>$latex S$, $latex \overleftarrow{F}$, and $latex \overrightarrow{F}$ together define a many-to-many relationship between objects of $latex \mathbb{C}$ and objects of $latex \mathbb{D}$. $latex D \in \mathbb{D}$ is called a <em>specified value of $latex F$ at $latex C$</em> if there is some specification $latex s \in S$ such that $latex \overleftarrow{F}(s) = C$ and $latex \overrightarrow{F}(s) = D$, in which case we write $latex F_s(C) = D$. Moreover, $latex D$ is <em>a value of $latex F$ at $latex C$</em> (not necessarily a <em>specified</em> one) if there is some $latex s$ for which $latex D \cong F_s(C)$.</p>
<p>The idea now is to impose additional conditions which ensure that $latex F$ “acts like” a regular functor $latex \mathbb{C} \to \mathbb{D}$.</p>
<ul>
<li>Functors are defined on all objects; so we require each object of $latex \mathbb{C}$ to have at least one specification $latex s$ which corresponds to it—that is, $latex \overleftarrow{F}$ must be surjective.</li>
<li>Functors transport morphisms as well as objects. For each $latex s,t \in   S$ (the middle of the below diagram) and each $latex f :   \overleftarrow{F}(s) \to \overleftarrow{F}(t)$ in $latex \mathbb{C}$ (the left-hand side below), there must be a morphism $latex F_{s,t}(f) :   \overrightarrow{F}(s) \to \overrightarrow{F}(t)$ in $latex \mathbb{D}$ (the right-hand side):</li>
</ul>
<div style="text-align:center;">
<p><img src="http://byorgey.files.wordpress.com/2014/06/959dc11fe357b271.png" /></p>
</div>
<ul>
<li>Functors preserve identities: for each $latex s \in S$ we should have $latex F_{s,s}(\mathit{id}_{\overleftarrow{F}(s)}) = \mathit{id}_{\overrightarrow{F}(s)}$.</li>
<li>Finally, functors preserve composition: for all $latex s,t,u \in S$ (in the middle below), $latex f : \overleftarrow{F}(s) \to \overleftarrow{F}(t)$, and $latex g : \overleftarrow{F}(t) \to \overleftarrow{F}(u)$ (the left side below), it must be the case that $latex F_{s,u}(f ; g) = F_{s,t}(f) ; F_{t,u}(g)$:</li>
</ul>
<div style="text-align:center;">
<p><img src="http://byorgey.files.wordpress.com/2014/06/e85fe8007b58880c.png" /></p>
</div>
<p>Our initial intuition was that an anafunctor should map objects of $latex \mathbb{C}$ to isomorphism classes of objects in $latex \mathbb{D}$. This may not be immediately apparent from the definition, but is in fact the case. In particular, the identity morphism $latex \mathit{id}_C$ maps to isomorphisms between specified values of $latex C$; that is, under the action of an anafunctor, an object $latex C$ together with its identity morphism “blow up” into an isomorphism class (aka a <em>clique</em>). To see this, let $latex s,t \in S$ be two different specifications corresponding to $latex C$, that is, $latex \overleftarrow{F}(s) = \overleftarrow{F}(t) = C$. Then by preservation of composition and identities, we have $latex F_{s,t}(\mathit{id}_C) ; F_{t,s}(\mathit{id}_C) = F_{s,s}(\mathit{id}_C ; \mathit{id}_C) = F_{s,s}(\mathit{id}_C) = \mathit{id}_{\overrightarrow{F}(s)}$, so $latex F_{s,t}(\mathit{id}_C)$ and $latex F_{t,s}(\mathit{id}_C)$ constitute an isomorphism between $latex F_s(C)$ and $latex F_t(C)$.</p>
<p>There is an alternative, equivalent definition of anafunctors, which is somewhat less intuitive but usually more convenient to work with: an anafunctor $latex F : \mathbb{C} \to \mathbb{D}$ is a <em>category</em> of specifications $latex \mathbb{S}$ together with a span of <em>functors</em> $latex \mathbb{C} \stackrel{\overleftarrow{F}}{\longleftarrow} \mathbb{S} \stackrel{\overrightarrow{F}}{\longrightarrow} \mathbb{D}$ where $latex \overleftarrow{F}$ is fully faithful and (strictly) surjective on objects.</p>
<p>Note that in this definition, $latex \overleftarrow{F}$ must be <em>strictly</em> (as opposed to <em>essentially</em>) surjective on objects, that is, for every $latex C \in \mathbb{C}$ there is some $latex S \in \mathbb{S}$ such that $latex \overleftarrow{F}(S) = C$, rather than only requiring $latex \overleftarrow{F}(S) \cong C$. Given this strict surjectivity on objects, it is equivalent to require $latex \overleftarrow F$ to be full, as in the definition above, or to be (strictly) surjective on the class of all morphisms.</p>
<p>We are punning on notation a bit here: in the original definition of anafunctor, $latex S$ is a set and $latex \overleftarrow{F}$ and $latex \overrightarrow{F}$ are functions on objects, whereas in this more abstract definition $latex \mathbb{S}$ is a category and $latex \overleftarrow{F}$ and $latex \overrightarrow{F}$ are functors. Of course, the two are closely related: given a span of functors $latex \mathbb{C} \stackrel{\overleftarrow{F}}{\longleftarrow} \mathbb{S} \stackrel{\overrightarrow{F}}{\longrightarrow} \mathbb{D}$, we may simply take the objects of $latex \mathbb{S}$ as the class of specifications $latex S$, and the actions of the functors $latex \overleftarrow{F}$ and $latex \overrightarrow{F}$ on objects as the functions from specifications to objects of $latex \mathbb{C}$ and $latex \mathbb{D}$. Conversely, given a class of specifications $latex S$ and functions $latex \overleftarrow{F}$ and $latex \overrightarrow{F}$, we may construct the category $latex \mathbb{S}$ with $latex \mathrm{Ob}\ \mathbb{S} = S$ and with morphisms $latex \overleftarrow{F}(s) \to \overleftarrow{F}(t)$ in $latex \mathbb{C}$ acting as morphisms $latex s \to t$ in $latex \mathbb{S}$. From $latex \mathbb{S}$ to $latex \mathbb{C}$, we construct the functor given by $latex \overleftarrow{F}$ on objects and the identity on morphisms, and the other functor maps $latex f : s \to t$ in $latex \mathbb{S}$ to $latex F_{s,t}(f) : \overrightarrow{F}(s) \to \overrightarrow{F}(t)$ in $latex \mathbb{D}$.</p>
<p>Every functor $latex F : \mathbb{C} \to \mathbb{D}$ can be trivially turned into an anafunctor $latex \mathbb{C} \stackrel{\mathit{Id}}{\longleftarrow} \mathbb{C} \stackrel{F}{\longrightarrow} \mathbb{D}$. Anafunctors also compose. Given compatible anafunctors $latex F : \mathbb{C} \stackrel{\overleftarrow F}{\longleftarrow} S \stackrel{\overrightarrow F}{\longrightarrow} \mathbb{D}$ and $latex G : \mathbb{D} \stackrel{\overleftarrow G}{\longleftarrow} T \stackrel{\overrightarrow G}{\longrightarrow} \mathbb{E}$, consider the action of their composite on objects: each object of $latex \mathbb{C}$ may map to multiple objects of $latex \mathbb{E}$, via objects of $latex \mathbb{D}$. Each such mapping corresponds to a zig-zag path $latex C \longleftarrow s \longrightarrow D \longleftarrow t \longrightarrow E$. In order to <em>specify</em> such a path it suffices to give the pair $latex (s,t)$, which determines $latex C$, $latex D$, and $latex E$. Note, however, that not every pair in $latex S \times T$ corresponds to a valid path, but only those which agree on the middle object $latex D \in \mathbb{D}$. Thus, we may take $latex \{ (s,t) \mid s \in S, t \in T, \overrightarrow{F}(s) = \overleftarrow{G}(t) \}$ as the set of specifications for the composite $latex F ; G$, with $latex \overleftarrow{F ; G}(s,t) = \overleftarrow{F}(s)$ and $latex \overrightarrow{F ; G}(s,t) = \overrightarrow{G}(t)$. On morphisms, $latex (F ; G)_{(s,t),(u,v)}(f) = G_{t,v}(F_{s,u}(f))$. It is not hard to check that this satisfies the anafunctor laws.</p>
<p>If you know what a pullback is, note that the same thing can also be defined at a higher level in terms of spans. $latex \mathbf{Cat}$, the category of all (small) categories, is complete, and in particular has pullbacks, so we may construct a new anafunctor from $latex \mathbb{C}$ to $latex \mathbb{E}$ by taking a pullback of $latex \overrightarrow F$ and $latex \overleftarrow G$ and then composing appropriately.</p>
<p>One can go on to define ananatural transformations between anafunctors, and show that together these constitute a $latex 2$-category $latex \mathbf{AnaCat}$ which is analogous to the usual $latex 2$-category of (small) categories, functors, and natural transformations; in particular, there is a fully faithful embedding of $latex \mathbf{Cat}$ into $latex \mathbf{AnaCat}$, which moreover is an equivalence if AC holds.</p>
<p>To work in category theory based on set theory and classical logic, while avoiding AC, one is therefore justified in “mixing and matching” functors and anafunctors as convenient, but discussing them all as if they were regular functors (except when defining a particular anafunctor). Such usage can be formalized by turning everything into an anafunctor, and translating functor operations and properties into corresponding operations and properties of anafunctors.</p>
<p>However, as I will argue in some future posts, there is a better solution, which is to throw out set theory as a foundation of category theory and start over with homotopy type theory. In that case, thanks to a generalized notion of equality, regular functors act like anafunctors, and in particular AP holds.</p>
<div class="references">
<h1>References</h1>
<p>Makkai, Michael. 1996. “Avoiding the Axiom of Choice in General Category Theory.” <em>Journal of Pure and Applied Algebra</em> 108 (2). Elsevier: 109–73.</p>
</div>

