---
katex: true
title: 'AC and equivalence of categories'
published: 2014-06-05T19:55:19Z
categories: category theory,math,species
tags: AC,axiom of choice,category,constructive,equivalence,functor,isomorphism,theory,types,unique
---

<p>This is part three in a series of posts on avoiding the axiom of choice (<a href="http://byorgey.wordpress.com/2014/05/08/avoiding-the-axiom-of-choice-part-i/">part one</a>, <a href="http://byorgey.wordpress.com/2014/05/13/unique-isomorphism-and-generalized-the/">part two</a>).</p>
<p>In my <a href="http://byorgey.wordpress.com/2014/05/13/unique-isomorphism-and-generalized-the/">previous post</a>, I explained one place where the axiom of choice often shows up in category theory, namely, when defining certain functors whose action on objects is specified only up to unique isomorphism. In this post, I’ll explain another place AC shows up, when talking about <em>equivalence</em> of categories. (Actually, as we’ll see, it’s really the same underlying issue, of defining a functor defined only up to unique isomorphism; this is just a particularly important instantiation of that issue.)</p>
<p>When are two categories “the same”? In traditional category theory, founded on set theory, there are quite a few different definitions of “sameness” for categories. Ultimately, this comes down to the fact that set theory does not make a very good foundation for category theory! There are lots of different ideas of equivalence, and they often do not correspond to the underlying equality on sets, so one must carefully pick and choose which notions of equality to use in which situations (and some choices might be better than others!). Every concept, it seems, comes with “strict” and “weak” variants, and often many others besides. Maintaining the principle of equivalence requires hard work and vigilence.</p>
<p>As an example, consider the following definition, our first candidate for the definition of “sameness” of categories:</p>
<blockquote>
Two categories $\mathbb{C}$ and $\mathbb{D}$ are <em>isomorphic</em> if there are functors $F : \mathbb{C} \to \mathbb{D}$ and $G : \mathbb{D} \to \mathbb{C}$ such that $GF = 1_\mathbb{C}$ and $FG = 1_\mathbb{D}$.
</blockquote>

<p>Seems pretty straightforward, right? Well, this is the right idea in general, but it is subtly flawed. In fact, it is somewhat “evil”, in that it talks about <em>equality</em> of functors ($GF$ and $FG$ must be <em>equal to</em> the identity). However, two functors $H$ and $J$ can be <em>isomorphic</em> without being <em>equal</em>, if there is a natural isomorphism between them—that is, a pair of natural transformations $\phi : H \to J$ and $\psi : J \to H$ such that $\phi \circ \psi$ and $\psi \circ \phi$ are both equal to the identity natural transformation.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> For example, consider the Haskell functors given by</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color:blue;font-weight:bold;">data</span> <span>Rose</span> <span>a</span> <span style="color:red;">=</span> <span>Node</span> <span>a</span> <span style="color:red;">[</span><span>Rose</span> <span>a</span><span style="color:red;">]</span>
<span style="color:blue;font-weight:bold;">data</span> <span>Fork</span> <span>a</span> <span style="color:red;">=</span> <span>Leaf</span> <span>a</span> <span style="color:red;">|</span> <span>Fork</span> <span style="color:red;">(</span><span>Fork</span> <span>a</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>Fork</span> <span>a</span><span style="color:red;">)</span></code></pre>
<p>These are obviously not <em>equal</em>, but they are isomorphic, in the sense that there are natural transformations (<em>i.e.</em> polymorphic functions) <code>rose2fork :: forall a. Rose a -&gt; Fork a</code> and <code>fork2rose :: forall a. Fork a -&gt; Rose a</code> such that <code>rose2fork . fork2rose === id</code> and <code>fork2rose . rose2fork === id</code> (showing this is left as an exercise for the interested reader).</p>
<p>Here, then, is a better definition:</p>
<blockquote> 
Categories $\mathbb{C}$ and $\mathbb{D}$ are <em>equivalent</em> if there are functors $F : \mathbb{C} \to \mathbb{D}$ and $G : \mathbb{D} \to \mathbb{C}$ which are inverse <em>up to natural isomorphism</em>, that is, there are natural isomorphisms $GF \cong 1_\mathbb{C}$ and $FG \cong 1_\mathbb{D}$.
</blockquote>

<p>So the compositions of the functors $F$ and $G$ do not <em>literally</em> have to be the identity functor, but only (naturally) <em>isomorphic</em> to it. This does turn out to be a well-behaved notion of sameness for categories (although you’ll have to take my word for it).</p>
<p>The story doesn’t end here, however. In set theory, a function is a bijection—that is, an isomorphism of sets—if and only if it is both injective and surjective. By analogy, one might wonder what properties a functor $F : \mathbb{C} \to \mathbb{D}$ must have in order to be one half of an equivalence. This leads to the following definition:</p>
<blockquote> 
$\mathbb{C}$ is <em>proto-equivalent</em><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> to $\mathbb{D}$ if there is a functor $F : \mathbb{C} \to \mathbb{D}$ which is full and faithful (<em>i.e.</em>, a bijection on each hom-set) as well as <em>essentially surjective</em>, that is, for every object $D \in \mathbb{D}$ there exists some object $C \in \mathbb{C}$ such that $F\
C \cong D$.
</blockquote>

<p>Intuitively, this says that $F$ “embeds” an entire copy of $\mathbb{C}$ into $\mathbb{D}$ (that’s the “full and faithful” part), and that every object of $D$ which is not directly in the image of $F$ is <em>isomorphic</em> to one that is. So every object of $\mathbb{D}$ is “included” in the image of $\mathbb{C}$, at least up to isomorphism (which, remember, is supposed to be all that matters).</p>
<p>So, are equivalence and protoequivalence the same thing? In one direction, it is not too hard to show that every equivalence is a protoequivalence: if $F$ and $G$ are inverse-up-to-natural-isomorphism, then they must be fully faithful and essentially surjective. It would be nice if the converse were also true: in that case, in order to prove two categories equivalent, it would suffice to construct a single functor $F$ from one to the other, and show that $F$ has the requisite properties. This often ends up being more convenient than explicitly constructing two functors and showing they are inverse. However, it turns out that the converse is provable <em>only</em> if one accepts the axiom of choice!</p>
<p>To get an intuitive sense for why this is, suppose $F : \mathbb{C} \to \mathbb{D}$ is fully faithful and essentially surjective. To construct an equivalence between $\mathbb{C}$ and $\mathbb{D}$, we must define a functor $G : \mathbb{D} \to \mathbb{C}$ and show it is inverse to $F$ (up to natural isomorphism). However, to define $G$ we must give its action on each object $D \in \mathbb{D}$, that is, we must exhibit a function $\mathrm{Ob}\ \mathbb{D} \to \mathrm{Ob}\
\mathbb{C}$. We know that for each $D \in \mathbb{D}$ there <em>exists</em> some object $C \in \mathbb{C}$ such that $F\ C \cong D$. That is,</p>
<div style="text-align:center;">
$\{ \{ C \in \mathbb{C} \mid F\ C \cong D \} \mid D \in \mathbb{D} \}$
</div>
<p><br /></p>
<p>is a collection of non-empty sets. However, in a non-constructive logic, knowing these sets are nonempty does not actually give us any objects! Instead, we have to use the axiom of choice, which gives us a choice function $\mathrm{Ob}\ \mathbb{D} \to \mathrm{Ob}\
\mathbb{C}$, and we can use this function as the object mapping of the functor $G$.</p>
<p>So AC is required to prove that every protoequivalence is an equivalence. In fact, the association goes deeper yet: it turns out that the statement “every protoequivalence is an equivalence” (let’s call this the <em>Axiom of Protoequivalence</em>, or AP for short) not only requires AC, but is <em>equivalent</em> to it—that is, you can also derive AC given AP as an axiom!</p>
<p>On purely intuitive grounds, however, I would wager that to (almost?) anyone with sufficient category theory experience, it “feels” like AP “ought to be” true. If there is a full, faithful, and essentially surjective functor $F : \mathbb{C} \to \mathbb{D}$, then $\mathbb{C}$ and $\mathbb{D}$ “ought to be” equivalent. The particular choice of functor $G : \mathbb{D} \to \mathbb{C}$ “doesn’t matter”, since it makes no difference up to isomorphism. On the other hand, we certainly don’t want to accept the axiom of choice. This puts us in the very awkward and inconsistent position of having two logically equivalent statements which we want to respectively affirm and reject. A fine pickle indeed! What to do?</p>
<p>There are four options (that I know of, at least):</p>
<ol style="list-style-type:decimal;">
<li>If one is feeling particularly rational, one can simply say, “Well, since AC and AP are equivalent, and I reject AC, I must therefore reject AP as well; my <em>feelings</em> about it are irrelevant.”</li>
</ol>
<p>This is a perfectly sensible and workable approach. It’s important to highlight, therefore, that the “problem” is in some sense more a <em>philosophical</em> problem than a <em>technical</em> one. One can perfectly well adopt the above solution and continue to do category theory; it just may not be the “nicest” (a philosophical rather than technical notion!) way to do it.</p>
<p>We can therefore also consider some more creative solutions!</p>
<ol start="2" style="list-style-type:decimal;">
<li><p>In a classical setting, one can avoid AC and affirm (an analogue of) AP by generalizing the notion of functor to that of <em>anafunctor</em> <span class="citation">(Makkai 1996)</span>. Essentially, an anafunctor is a functor “defined only up to unique isomorphism”. It turns out that the appropriate analogue of AP, where “functor” has been replaced by “anafunctor”, is indeed true—and neither requires nor implies AC. Anafunctors “act like” functors in a sufficiently strong sense that one can simply do category theory using anafunctors in place of functors. However, one also has to replace natural transformations with “ananatural transformations”, <em>etc.</em>, and it quickly gets rather fiddly.</p></li>
<li><p>In a constructive setting, a witness of essential surjectivity is necessarily a function which gives an <em>actual witness</em> $C \in    \mathbb{C}$, along with a proof that $F\ C \cong D$, for each $D    \in \mathbb{D}$. In other words, a constructive witness of essential surjectivity is already a “choice function”, and an inverse functor $G$ can be defined directly, with no need to invoke AC and no need for anafunctors. So in constructive logic, AP is simply true. However, this version of “essential surjectivity” is rather strong, in that it forces you to make choices you might prefer not to make: for each $D \in \mathbb{D}$ there might be many isomorphic $C \in \mathbb{C}$ to choose from, with no “canonical” choice, and it is annoying (again, a philosophical rather than technical consideration!) to be forced to choose one.</p></li>
<li><p>Instead of generalizing functors, a more direct solution is to <em>generalize the notion of equality</em>. After all, what really seems to be at the heart of all these problems is differing notions of equality (<em>i.e.</em> equality of sets <em>vs</em> isomorphism <em>vs</em> equivalence…). This is precisely what is done in <a href="http://homotopytypetheory.org/">homotopy type theory</a> <span class="citation">(<span>Univalent Foundations Program</span> 2013)</span>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> It turns out that if one builds up suitable notions of category theory on top of HoTT instead of set theory, then (a) AP is true, (b) without the need for AC, (c) even with a <em>weaker</em> version of essential surjectivity that corresponds more closely to essential surjectivity in classical logic.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> This is explained in Chapter 9 of the <a href="http://homotopytypetheory.org/book/">HoTT book</a>.</p></li>
</ol>
<p>I plan to continue writing about these things in upcoming posts, particularly items (2) and (4) above. (If you haven’t caught on by now, I’m essentially blogging parts of my dissertation; we’ll see how far I get before graduating!) In the meantime, feedback and discussion are very welcome!</p>
<div class="references">
<h1>References</h1>
<p>Makkai, Michael. 1996. “Avoiding the Axiom of Choice in General Category Theory.” <em>Journal of Pure and Applied Algebra</em> 108 (2). Elsevier: 109–73.</p>
<p><span>Univalent Foundations Program</span>, The. 2013. <em>Homotopy Type Theory: Univalent Foundations of Mathematics</em>. Institute for Advanced Study: <a href="http://homotopytypetheory.org/book">http://homotopytypetheory.org/book</a>.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The astute reader may well ask: but how do we know <em>this</em> is a non-evil definition of isomorphism between <em>functors</em>? Is it turtles all the way down (up)? This is a subtle point, but it turns out that it is not evil to talk about equality of natural transformations, since for the usual notion of category there is no higher structure after natural transformations, <em>i.e.</em> no nontrivial morphisms (and hence no nontrivial isomorphisms) between natural transformations. (However, you can have <a href="http://ncatlab.org/nlab/show/%28infinity%2C1%29-category">turtles all the way up</a> if you really want.)<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>I made this term up, since there is no term in standard use: of course, if you accept AC, there is no need for a separate term at all!<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>As a <a href="http://byorgey.wordpress.com/2014/05/13/unique-isomorphism-and-generalized-the/#comment-13123">historical note</a>, it seems that the original work on anafunctors is part of the same intellectual thread that led to the development of HoTT.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>That is, using <em>propositional truncation</em> to encode the classical notion of “there exists”.<a href="#fnref4">↩</a></p></li>
</ol>
</div>

