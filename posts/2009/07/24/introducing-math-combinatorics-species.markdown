---
katex: true
title: 'Introducing Math.Combinatorics.Species!'
published: 2009-07-24T22:22:10Z
categories: combinatorics,haskell,math,projects
tags: combinatorial species
---

I have just uploaded to <a href="http://hackage.haskell.org">Hackage</a> version 0.1 of the <a href="http://hackage.haskell.org/package/species">species</a> package, a Haskell library for computing with <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Combinatorial_species">combinatorial species</a>.  Much like David Amos's <a href="http://haskellformaths.blogspot.com/">great series of posts</a> introducing his <a href="http://hackage.haskell.org/package/HaskellForMaths">Haskell for Maths library</a>, I plan to write a series of posts over the next week or two introducing the library, explaining how it works, and showing off some interesting examples.

But, first things first: if you'd like to install the library and play along, just

<code>cabal update; cabal install species</code>

(Man, do I ever love cabal-install!  But I digress.)

<h3>Combinatorial what?</h3>

So, what are combinatorial species?  Intuitively, a species describes a certain combinatorial structure: given an underlying set of labels, it specifies a set of structures which can be built using those labels.  For example, $L$, the species of lists, when applied to an underlying set of labels $U$ yields the set of all linear orderings of the elements of $U$.  So in general a species can be viewed as a function which takes any set (the labels) and produces another set (of structures built out of those labels).

[caption id="attachment_182" align="aligncenter" width="364" caption="The species L of lists."]<img src="http://byorgey.files.wordpress.com/2009/07/list-species2.png" alt="The species L of lists." title="list-species2" width="364" height="98" class="size-full wp-image-182" />[/caption]

Actually, this isn't quite enough to capture our intuition about what a species ought to be: we want a species to work "independently" of the underlying set; which labels we use shouldn't matter at all when it comes to describing <i>structures</i>.  So, additionally, we require that if $F$ is a species, any bijection $\sigma : U \to T$ between two sets of labels can be "lifted" to a bijection between sets of $F$-structures, $F[\sigma] : F[U] \to F[T]$, in a way that respects composition of bijections.  (Of course, the categorists ought to be jumping out of their seats right now: all this just amounts to saying that a species is an endofunctor $F : \mathbb{B} \to \mathbb{B}$ on the category of sets with bijections.)  Importantly, it is not too hard to see that this requirement means that for any species $F$, the size of $F[U]$ depends <i>only</i> on the size of $U$, and not on the actual elements of $U$.

<h3>Counting labelled structures</h3>

So, let's see some examples already!  What sorts of things might we want to compute about species?

First, we of course want to be able to count <i>how many</i> structures are generated by a species.  As a first example, consider again the species $L$ of lists.  Given an underlying set $U$ of size $n$, how many lists $L[U]$ are there?  That's easy: $n!$.

<code>
[brent@euclid:~]$ ghci -XNoImplicitPrelude
&gt; :m +Math.Combinatorics.Species
&gt; take 10 $ labelled lists
[1,1,2,6,24,120,720,5040,40320,362880]
</code>

The function <code>labelled</code> takes a combinatorial species $F$ as an argument, and computes an infinite list where the entry at index $n$ is the number of labelled $F$-structures on an underlying set of size $n$.

(This is also a good time to mention that the species library depends on the <a href="http://hackage.haskell.org/package/numeric%2Dprelude">Numeric Prelude</a>, an alternative Haskell Prelude with a mathematically sane hierarchy of numeric types; hence we must pass ghci the -XNoImplicitPrelude flag so we don't get lots of horrible name clashes.  I'll write some additional thoughts on the Numeric Prelude in a future post.)

Now, so far this is nothing new: Dan Piponi wrote a <a href="http://blog.sigfpe.com/2007/11/small-combinatorial-library.html">blog post about a Haskell DSL for counting labelled structures</a> back in 2007, and in fact, that post was part of my inspiration for this library.  Counting labelled structures works by associating exponential generating functions to species.  (More on this in a future post.)  But we can do more than that!

<h3>Counting unlabelled structures</h3>

For one, we can also count <i>unlabelled</i> structures.  What's an unlabelled structure?  Intuitively, it's a structure where you can't tell the difference between the elements of the underlying set; formally, it's an equivalence class of labelled structures, where two labelled structures are equivalent if one can be transformed into the other by permuting the labels.

So, how about unlabelled lists?

<code>
&gt; take 10 $ unlabelled lists
[1,1,1,1,1,1,1,1,1,1]
</code>

Boring!  This makes sense, though: there's only one way to make a list out of n identical objects.

[caption id="attachment_189" align="aligncenter" width="350" caption="The species of lists on indistinguishable labels"]<img src="http://byorgey.files.wordpress.com/2009/07/unlabelled-lists-arr.png" alt="The species of lists on indistinguishable labels" title="unlabelled-lists-arr" width="350" height="90" class="size-full wp-image-189" />[/caption]

But how about something a bit less trivial?

<code>
&gt; take 10 $ labelled partitions
[1,1,2,5,15,52,203,877,4140,21147]
&gt; take 10 $ unlabelled partitions
[1,1,2,3,5,7,11,15,22,30]
&gt; :m +Math.OEIS
&gt; description `fmap` (lookupSequence . take 10 $ labelled partitions)
Just "Bell or exponential numbers: ways of placing n labeled balls into n indistinguishable boxes."
&gt; description `fmap` (lookupSequence . take 10 $ unlabelled partitions)
Just "a(n) = number of partitions of n (the partition numbers)."
</code>

[caption id="attachment_191" align="aligncenter" width="350" caption="Unlabelled partitions"]<img src="http://byorgey.files.wordpress.com/2009/07/unlabelled-partitions.png" alt="Unlabelled partitions" title="unlabelled-partitions" width="350" height="150" class="size-full wp-image-191" />[/caption]

(I couldn't resist sneaking in a little plug for my <a href="http://hackage.haskell.org/package/oeis">Math.OEIS</a> module there too. =)  So, how does this work?  Well... it's a bit more complicated!  But I'll explain it in a future post, too.

<h3>Generating structures</h3>

But that's not all!  Not only can we <i>count</i> structures, we can <i>generate</i> them, too:

<code>
&gt; generate lists ([1..3] :: [Int])
[{*,1,2,3},{*,1,3,2},{*,2,1,3},{*,2,3,1},{*,3,1,2},{*,3,2,1}]
&gt; generate partitions ([1..3] :: [Int])
[[[1,2,3]],[[1,2],[3]],[[1,3],[2]],[[1],[2,3]],[[1],[2],[3]]]
</code>

This is a bit magical, and of course I will... explain it in a future post.  For now, I leave you with this challenge: can you figure out what the asterisks are doing there?  (Hint: the curly brackets denote a cycle...)

Of course, no DSL would be complete without operations with which to build up more complicated structures from simpler ones; in my next post I'll talk about operations on combinatorial species.

<h3>Further reading</h3>

If you just can't wait for my next post and want to read more about combinatorial species, I recommend reading the <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Combinatorial_species">Wikipedia article</a>, which is OK, <a href="http://topologicalmusings.wordpress.com/2009/03/28/number-of-idempotent-endofunctions/">this fantastic blog post</a>, which is what introduced me to the wonderful world of species, or for a great dead-tree reference (whence I'm getting most of my information), check out <a href="http://bergeron.math.uqam.ca/Species/especes.html">Combinatorial Species and Tree-Like Structures</a> by Bergeron, Labelle, and Leroux.

