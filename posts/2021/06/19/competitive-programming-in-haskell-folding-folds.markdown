---
title: 'Competitive programming in Haskell: folding folds'
published: 2021-06-19T14:55:32Z
categories: competitive programming,haskell
tags: 2D,fold,geometry,Kattis,line,origami,reflect
---

<p>Now that the semester is over—and I will be on sabbatical in the fall!—you can expect a lot more competitive programming in Haskell posts. In <a href="https://byorgey.wordpress.com/2021/02/23/competitive-programming-in-haskell-folding-challenge/">a previous post</a>, I challenged you to solve <a href="https://open.kattis.com/problems/origami">Origami</a>. <a href="https://byorgey.wordpress.com/2021/02/23/competitive-programming-in-haskell-folding-challenge/#comment-39466">j0sejuan took me up on the challenge</a>, as did Aaron Allen and Ryan Yates; if you still want to try it, go do it before reading on!</p>
<p>In the problem, we start with a square sheet of paper and are given a series of folds to perform in sequence; each fold is specified as a line, and we fold whatever is on one side of the line across onto the other side. Given some query points, we have to compute how thick the resulting origami design is at each point.</p>
<h2 id="lines">Lines</h2>
<p>The first order of business is some computational geometry relating to lines in 2D (this code can all be found in <a href="https://github.com/byorgey/comprog-hs/blob/master/Geom.hs">Geom.hs</a>. Here I am following <a href="https://vlecomte.github.io/">Victor Lecomte</a>’s excellent <a href="https://vlecomte.github.io/cp-geo.pdf">Handbook of geometry for competitive programmers</a>, which I think I’ve mentioned before. I’ll try to give a bit of explanation, but if you want full explanations and proofs you should consult that document.</p>
<p>The equation of a line $ax + by = c$ can be thought of as the set of all points $(x,y)$ whose dot product with the vector $(a,b)$ is a constant $c$. This will in fact be a line perpendicular to the vector $(a,b)$, where $c$ determines the distance of the line from the origin. Alternatively, we can think of the vector $(b,-a)$, which is perpendicular to $(a,b)$ and thus parallel to the line; the line now consists of all points $(x,y)$ whose <a href="https://byorgey.wordpress.com/2020/07/10/competitive-programming-in-haskell-2d-cross-product-part-1/">2D cross product</a> with $(b,-a)$ is the constant $c$ (since $(b,-a) \times (x,y) = by - (-a)x = ax + by$; note that the order matters). Either representation would work, but I will follow Lecomte in choosing the second: we represent a line by a vector giving its direction, and a scalar offset.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color:blue;font-weight:bold;">data</span> <span>L2</span> <span>s</span> <span style="color:red;">=</span> <span>L2</span> <span style="color:red;">{</span> <span>getDirection</span> <span style="color:red;">::</span> <span>!</span><span style="color:red;">(</span><span>V2</span> <span>s</span><span style="color:red;">)</span><span style="color:red;">,</span> <span>getOffset</span> <span style="color:red;">::</span> <span>!</span><span>s</span> <span style="color:red;">}</span>
<span style="color:blue;font-weight:bold;">type</span> <span>L2D</span> <span style="color:red;">=</span> <span>L2</span> <span>Double</span></code></pre>
<p>There are a few ways to construct a line: from an equation $ax + by = c$, or from two points which lie on the line. The first is easy, given the above discussion. For the second, given points $p$ and $q$, we can easily construct the direction of the line as $v = q - p$. Then to get the constant $c$, we simply use the fact that $c$ is the cross product of the direction vector with any point on the line, say, $p$ (of course $q$ would also work).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>lineFromEquation</span> <span style="color:red;">::</span> <span>Num</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>L2</span> <span>s</span>
<span>lineFromEquation</span> <span>a</span> <span>b</span> <span>c</span> <span style="color:red;">=</span> <span>L2</span> <span style="color:red;">(</span><span>V2</span> <span>b</span> <span style="color:red;">(</span><span style="color:green;">-</span><span>a</span><span style="color:red;">)</span><span style="color:red;">)</span> <span>c</span>

<span>lineFromPoints</span> <span style="color:red;">::</span> <span>Num</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>L2</span> <span>s</span>
<span>lineFromPoints</span> <span>p</span> <span>q</span> <span style="color:red;">=</span> <span>L2</span> <span>v</span> <span style="color:red;">(</span><span>v</span> <span>`cross`</span> <span>p</span><span style="color:red;">)</span>
  <span style="color:blue;font-weight:bold;">where</span>
    <span>v</span> <span style="color:red;">=</span> <span>q</span> <span>^-^</span> <span>p</span></code></pre>
<p>Now we can write some functions to decide where a given point lies with respect to a line. First, the <code>side</code> function computes $ax + by - c = (b,-a) \times (x,y) - c$ for any point $p = (x,y)$.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>side</span> <span style="color:red;">::</span> <span>Num</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>s</span>
<span>side</span> <span style="color:red;">(</span><span>L2</span> <span>v</span> <span>c</span><span style="color:red;">)</span> <span>p</span> <span style="color:red;">=</span> <span>cross</span> <span>v</span> <span>p</span> <span style="color:green;">-</span> <span>c</span></code></pre>
<p>Of course, for points that lie on the line, this quantity will be zero. We can also classify points $p$ as lying to the left or right of the line (looking in the direction of $v$) depending on whether <code>side l p</code> is positive or negative, respectively.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>onLine</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Num</span> <span>s</span><span style="color:red;">,</span> <span>Eq</span> <span>s</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Bool</span>
<span>onLine</span> <span>l</span> <span>p</span> <span style="color:red;">=</span> <span>side</span> <span>l</span> <span>p</span> <span>==</span> <span class="hs-num">0</span>

<span>leftOf</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Num</span> <span>s</span><span style="color:red;">,</span> <span>Ord</span> <span>s</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Bool</span>
<span>leftOf</span> <span>l</span> <span>p</span> <span style="color:red;">=</span> <span>side</span> <span>l</span> <span>p</span> <span>&gt;</span> <span class="hs-num">0</span>

<span>rightOf</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>Num</span> <span>s</span><span style="color:red;">,</span> <span>Ord</span> <span>s</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>Bool</span>
<span>rightOf</span> <span>l</span> <span>p</span> <span style="color:red;">=</span> <span>side</span> <span>l</span> <span>p</span> <span>&lt;</span> <span class="hs-num">0</span></code></pre>
<p>The last piece we will need to solve the problem is a way to reflect a point across a line. <code>toProjection l p</code> computes the vector perpendicular to $l$ which points from $p$ to $l$, and <code>reflectAcross</code> works by adding <code>toProjection l p</code> to <code>p</code> twice. I won’t derive the definition of <code>toProjection</code>, but the basic idea is to start with a vector perpendicular to the direction of the line (<code>perp v</code>) and scale it by a factor related to <code>side l p</code>. (Intuitively, it makes sense that $ax + by - c$ tells us something about the distance from $(x,y)$ to the line; the farther away $(x,y)$ is from the line, the farther $ax + by$ is from $c$.) See Lecomte for the full details.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>toProjection</span> <span style="color:red;">::</span> <span>Fractional</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>V2</span> <span>s</span>
<span>toProjection</span> <span>l</span><span style="color:red;">@</span><span style="color:red;">(</span><span>L2</span> <span>v</span> <span style="color:blue;font-weight:bold;">_</span><span style="color:red;">)</span> <span>p</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span style="color:green;">-</span><span>side</span> <span>l</span> <span>p</span> <span>/</span> <span>normSq</span> <span>v</span><span style="color:red;">)</span> <span>*^</span> <span>perp</span> <span>v</span>

<span>project</span> <span style="color:red;">::</span> <span>Fractional</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span>
<span>project</span> <span>l</span> <span>p</span> <span style="color:red;">=</span> <span>p</span> <span>^+^</span> <span>toProjection</span> <span>l</span> <span>p</span>

<span>reflectAcross</span> <span style="color:red;">::</span> <span>Fractional</span> <span>s</span> <span style="color:red;">=&gt;</span> <span>L2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span> <span style="color:red;">-&gt;</span> <span>P2</span> <span>s</span>
<span>reflectAcross</span> <span>l</span> <span>p</span> <span style="color:red;">=</span> <span>p</span> <span>^+^</span> <span style="color:red;">(</span><span class="hs-num">2</span> <span>*^</span> <span>toProjection</span> <span>l</span> <span>p</span><span style="color:red;">)</span></code></pre>
<h2 id="folding-origami">Folding origami</h2>
<p>Finally we can solve the problem! First, some imports and input parsing.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color:green;">{-# LANGUAGE RecordWildCards #-}</span>

<span style="color:blue;font-weight:bold;">import</span>           <span>Control.Arrow</span>
<span style="color:blue;font-weight:bold;">import</span> <span style="color:blue;font-weight:bold;">qualified</span> <span>Data.ByteString.Lazy.Char8</span> <span style="color:blue;font-weight:bold;">as</span> <span>C</span>

<span style="color:blue;font-weight:bold;">import</span>           <span>Geom</span>
<span style="color:blue;font-weight:bold;">import</span>           <span>ScannerBS</span>

<span>main</span> <span style="color:red;">=</span> <span>C.interact</span> <span>$</span>
  <span>runScanner</span> <span>tc</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>map</span> <span style="color:red;">(</span><span>show</span> <span>&gt;&gt;&gt;</span> <span>C.pack</span><span style="color:red;">)</span> <span>&gt;&gt;&gt;</span> <span>C.unlines</span>

<span style="color:blue;font-weight:bold;">data</span> <span>TC</span> <span style="color:red;">=</span> <span>TC</span> <span style="color:red;">{</span> <span>steps</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>L2D</span><span style="color:red;">]</span><span style="color:red;">,</span> <span>holes</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>P2D</span><span style="color:red;">]</span> <span style="color:red;">}</span>

<span>tc</span> <span style="color:red;">=</span> <span>TC</span> <span>&lt;$&gt;</span> <span>numberOf</span> <span style="color:red;">(</span><span>lineFromPoints</span> <span>&lt;$&gt;</span> <span>p2</span> <span>double</span> <span>&lt;*&gt;</span> <span>p2</span> <span>double</span><span style="color:red;">)</span> <span>&lt;*&gt;</span> <span>numberOf</span> <span style="color:red;">(</span><span>p2</span> <span>double</span><span style="color:red;">)</span>

<span>solve</span> <span style="color:red;">::</span> <span>TC</span> <span style="color:red;">-&gt;</span> <span style="color:red;">[</span><span>Int</span><span style="color:red;">]</span>
<span>solve</span> <span>TC</span><span style="color:red;">{</span><span style="color:red;">..</span><span style="color:red;">}</span> <span style="color:red;">=</span> <span>map</span> <span>countLayers</span> <span>holes</span>
  <span style="color:blue;font-weight:bold;">where</span></code></pre>
<p>For <code>countLayers</code>, the idea is to work backwards from a given query point to find all its preimages, that is, the points that will eventually map to that point under the folds. Then we can just count how many of those points lie (strictly) inside the original square of paper.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span>inSquare</span> <span style="color:red;">(</span><span>V2</span> <span>x</span> <span>y</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span class="hs-num">0</span> <span>&lt;</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;</span> <span class="hs-num">1000</span> <span>&amp;&amp;</span> <span class="hs-num">0</span> <span>&lt;</span> <span>y</span> <span>&amp;&amp;</span> <span>y</span> <span>&lt;</span> <span class="hs-num">1000</span></code></pre>
<p>For a given point and fold, there are two possibilities, depending on which side of the fold line the point falls on. If the point falls on the fold or to the right of it, then it has no preimages (we always fold from right to left, so after the fold, there will be no paper on the right side of the line, and the problem specifies that points exactly on a folded edge do not count). Hence we can just discard such a point. On the other hand, if the point lies on the left side of the line, then the point has two preimages: the point itself, and its reflection across the fold line.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span>preimage</span> <span style="color:red;">::</span> <span>L2D</span> <span style="color:red;">-&gt;</span> <span>P2D</span> <span style="color:red;">-&gt;</span> <span style="color:red;">[</span><span>P2D</span><span style="color:red;">]</span>
    <span>preimage</span> <span>l</span> <span>p</span>
      <span style="color:red;">|</span> <span>leftOf</span> <span>l</span> <span>p</span> <span style="color:red;">=</span> <span style="color:red;">[</span><span>p</span><span style="color:red;">,</span> <span>reflectAcross</span> <span>l</span> <span>p</span><span style="color:red;">]</span>
      <span style="color:red;">|</span> <span>otherwise</span>  <span style="color:red;">=</span> <span>[]</span></code></pre>
<p>So we keep a set of points, starting with the singleton query point, and for each fold (in order from last to first) we find the preimage of every point in the set under the fold. We actually use lists of points instead of sets, because (1) we won’t ever get any collisions (actually, the more I think about this, the less sure I am!) and (2) it lets us use the actual list monad instead of making some ad-hoc <code>Set</code> monad operations.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span>countLayers</span> <span style="color:red;">::</span> <span>P2D</span> <span style="color:red;">-&gt;</span> <span>Int</span>
    <span>countLayers</span> <span>q</span> <span style="color:red;">=</span> <span>length</span> <span>.</span> <span>filter</span> <span>inSquare</span> <span>$</span> <span>foldr</span> <span style="color:red;">(</span><span style="color:red;">\</span><span>l</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>&gt;&gt;=</span> <span>preimage</span> <span>l</span><span style="color:red;">)</span><span style="color:red;">)</span> <span style="color:red;">[</span><span>q</span><span style="color:red;">]</span> <span>steps</span></code></pre>
<p>It is very satisfying to use a fold to process a list of folds!</p>
<h2 id="next-time-please-go-first">Next time: Please, Go First</h2>
<p>For next time, I invite you to solve <a href="https://open.kattis.com/problems/pleasegofirst">Please, Go First</a>.</p>

