---
title: 'Competitive programming in Haskell: BFS, part 2 (alternative APIs)'
published: 2021-10-18T19:48:36Z
categories: competitive programming,haskell
tags: BFS,graph,Kattis,search
---

<p>In <a href="https://byorgey.wordpress.com/2021/10/14/competitive-programming-in-haskell-bfs-part-1/">my last post</a>, I showed how we can solve <a href="https://open.kattis.com/problems/modulosolitaire">Modulo Solitaire</a> (and hopefully other BFS problems as well) using a certain API for BFS, which returns two functions: one, <code>level :: v -&gt; Maybe Int</code>, gives the level (<em>i.e.</em> length of a shortest path to) of each vertex, and <code>parent :: v -&gt; Maybe v</code> gives the parent of each vertex in the BFS forest. Before showing an implementation, I wanted to talk a bit more about this API and why I chose it.</p>
<p>In particular, Andrey Mokhov <a href="https://byorgey.wordpress.com/2021/10/14/competitive-programming-in-haskell-bfs-part-1/#comment-40054">left a comment</a> on my previous post with some alternative APIs:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>bfsForest</span> <span style="color:red;">::</span> <span>Ord</span> <span>a</span> <span style="color:red;">=&gt;</span> <span style="color:red;">[</span><span>a</span><span style="color:red;">]</span> <span style="color:red;">-&gt;</span> <span>AdjacencyMap</span> <span>a</span> <span style="color:red;">-&gt;</span> <span>Forest</span> <span>a</span>
<span>bfs</span> <span style="color:red;">::</span> <span>Ord</span> <span>a</span> <span style="color:red;">=&gt;</span> <span style="color:red;">[</span><span>a</span><span style="color:red;">]</span> <span style="color:red;">-&gt;</span> <span>AdjacencyMap</span> <span>a</span> <span style="color:red;">-&gt;</span> <span style="color:red;">[</span><span style="color:red;">[</span><span>a</span><span style="color:red;">]</span><span style="color:red;">]</span></code></pre>
<p>Of course, as Andrey notes, <code>AdjacencyMap</code> is actually a reified graph data structure, which we don’t want here, but that’s not essential; presumably the <code>AdjacencyMap</code> arguments in Andrey’s functions could easily be replaced by an implicit graph description instead. (Note that an API requiring an implicit representation is strictly more powerful, since if you have an explicit representation you can always just pass in a function which does lookups into your explicit representation.) However, Andrey raises a good point. Both these APIs return information which is not immediately available from my API.</p>
<ul>
<li><p><code>bfsForest</code> returns an actual forest we can traverse, giving the children of each node. My API only returns a <code>parent</code> function which gives the parent of each node. These contain equivalent information, however, and we can convert back and forth efficiently (where by “efficiently” in this context I mean “in $O(n \lg n)$ time or better”) as long as we have a list of all vertices. To convert from a <code>Forest</code> to a parent function, just traverse the forest and remember all the parent-child pairs we see, building e.g. a <code>Map</code> that can be used for lookup. To convert back, first iterate over the list of all vertices, find the parent of each, and build an inverse mapping from parents to sets of children. If we want to proceed to building an actual <code>Forest</code> data structure, we can unfold one via repeated lookups into our child mapping.</p>
<p>However, I would argue that in typical applications, having the <code>parent</code> function is more useful than having a <code>Forest</code>. For example, the <code>parent</code> function allows us to efficiently answer common, classic queries such as “Is vertex <code>v</code> reachable from vertex <code>s</code>?” and “What is a shortest path from <code>s</code> to <code>v</code>?” Answering these questions with a <code>Forest</code> would require traversing the entire <code>Forest</code> to look for the target vertex <code>v</code>.</p></li>
<li><p><code>bfs</code> returns a list of levels: that is, the first list is the starting vertices, the next list is all vertices one step away from any starting vertex, the next list is all vertices two steps away, and so on. Again, given a list of all vertices, we can recover a list of levels from the <code>level</code> function: just traverse the list of all vertices, looking up the level of each and adding it to an appropriate mapping from levels to sets of vertices. Converting in the other direction is easy as well.</p>
<p>A level list lets us efficiently answer a queries such as “how many vertices are exactly 5 steps away from <code>s</code>”?, whereas with the <code>level</code> function we can efficiently answer queries such as “What is the length of a shortest path from <code>s</code> to <code>v</code>?” In practice, the latter form of query seems more common.</p></li>
</ul>
<p>In the final version of this BFS API, I will probably include some functions to recover forests and level sets as described above. Some benchmarking will be needed to see whether it’s more efficient to recover them after the fact or to actually keep track of them along the way.</p>

