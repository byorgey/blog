---
katex: true
title: 'Competitive programming in Haskell: BFS, part 1'
published: 2021-10-14T16:09:53Z
categories: competitive programming,haskell
tags: BFS,graph,Kattis,search
---

<p>In <a href="https://byorgey.wordpress.com/2021/09/09/competitive-programming-in-haskell-kadanes-algorithm/">a previous post</a>, I challenged you to solve <a href="https://open.kattis.com/problems/modulosolitaire">Modulo Solitaire</a>. In this problem, we are given a starting number $s_0$ and are trying to reach $0$ in as few moves as possible. At each move, we may pick one of up to 10 different rules $(a_i,b_i)$ that say we can transform $s$ into $(a_i s + b_i) \bmod m$.</p>
<p>In one sense, this is a straightforward search problem. Conceptually, the numbers $0$ through $m-1$ form the vertices of a graph, with a directed edge from $s$ to $t$ whenever there is some allowed $(a_i, b_i)$ such that $t = (a_i s + b_i) \bmod m$; we want to do a breadth first search in this graph to find the length of a shortest path from $s_0$ to $0$. However, $m$ can be up to $10^6$ and there can be up to $10$ rules, giving a total of up to $10^7$ edges. In the case that $0$ is unreachable, we may have to explore every single edge. So we are going to need a pretty fast implementation; we’ll come back to that later.</p>
<p>Haskell actually has a nice advantage here. This is exactly the kind of problem in which we want to represent the graph <em>implicitly</em>. There is no reason to actually reify the graph in memory as a data structure; it would only waste memory and time. Instead, we can specify the graph implicitly using a <em>function</em> that gives the neighbors of each vertex, which means BFS itself will be a higher-order function. Higher-order functions are very awkward to represent in a language like Java or C++, so when I solve problems like this in Java, I tend to just write the whole BFS from scratch every single time, and I doubt I’m the only one. However, in Haskell we can easily make an abstract interface to BFS which takes a function as input specifying an implicit graph, allowing us to nicely separate out the graph search logic from the task of specifying the graph itself.</p>
<p>What would be my ideal API for BFS in Haskell? I think it might look something like this (but I’m happy to hear suggestions as to how it could be made more useful or general):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color:blue;font-weight:bold;">data</span> <span>BFSResult</span> <span>v</span> <span style="color:red;">=</span>
  <span>BFSR</span> <span style="color:red;">{</span> <span>level</span> <span style="color:red;">::</span> <span>v</span> <span style="color:red;">-&gt;</span> <span>Maybe</span> <span>Int</span><span style="color:red;">,</span> <span>parent</span> <span style="color:red;">::</span> <span>v</span> <span style="color:red;">-&gt;</span> <span>Maybe</span> <span>v</span> <span style="color:red;">}</span>

<span>bfs</span> <span style="color:red;">::</span>
  <span style="color:red;">(</span><span>Ord</span> <span>v</span><span style="color:red;">,</span> <span>Hashable</span> <span>v</span><span style="color:red;">)</span> <span style="color:red;">=&gt;</span>
  <span style="color:red;">[</span><span>v</span><span style="color:red;">]</span> <span style="color:red;">-&gt;</span>                      <span style="color:green;">-- Starting vertices</span>
  <span style="color:red;">(</span><span>v</span> <span style="color:red;">-&gt;</span> <span style="color:red;">[</span><span>v</span><span style="color:red;">]</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span>               <span style="color:green;">-- Neighbors</span>
  <span style="color:red;">(</span><span>v</span> <span style="color:red;">-&gt;</span> <span>Bool</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span>              <span style="color:green;">-- Goal predicate</span>
  <span>BFSResult</span> <span>v</span></code></pre>
<p><code>bfs</code> takes a list of vertices to search from (which could be a singleton if there is a single specific starting vertex), a function specifying the out-neighbors of each vertex, and a predicate specifying which vertices are “goal” vertices (so we can stop early if we reach one), and returns a <code>BFSResult</code> record, which tells us the level at which each vertex was encountered, if at all (i.e. how many steps were required to reach it), and the parent of each vertex in the search. If we just want to know whether a vertex was reachable at all, we can see if <code>level</code> returns <code>Just</code>; if we want to know the shortest path to a vertex, we can just iterate <code>parent</code>. Vertices must be <code>Ord</code> and <code>Hashable</code> to facilitate storing them in data structures.</p>
<p>Using this API, the solution is pretty short.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span>main</span> <span style="color:red;">=</span> <span>C.interact</span> <span>$</span> <span>runScanner</span> <span>tc</span> <span>&gt;&gt;&gt;</span> <span>solve</span> <span>&gt;&gt;&gt;</span> <span>format</span>

<span style="color:blue;font-weight:bold;">data</span> <span>Move</span> <span style="color:red;">=</span> <span>Move</span> <span style="color:red;">{</span> <span>a</span> <span style="color:red;">::</span> <span>!</span><span>Int</span><span style="color:red;">,</span> <span>b</span> <span style="color:red;">::</span> <span>!</span><span>Int</span> <span style="color:red;">}</span> <span style="color:blue;font-weight:bold;">deriving</span> <span style="color:red;">(</span><span>Eq</span><span style="color:red;">,</span> <span>Show</span><span style="color:red;">)</span>
<span style="color:blue;font-weight:bold;">data</span> <span>TC</span> <span style="color:red;">=</span> <span>TC</span> <span style="color:red;">{</span> <span>m</span> <span style="color:red;">::</span> <span>Int</span><span style="color:red;">,</span> <span>s0</span> <span style="color:red;">::</span> <span>Int</span><span style="color:red;">,</span> <span>moves</span> <span style="color:red;">::</span> <span style="color:red;">[</span><span>Move</span><span style="color:red;">]</span> <span style="color:red;">}</span> <span style="color:blue;font-weight:bold;">deriving</span> <span style="color:red;">(</span><span>Eq</span><span style="color:red;">,</span> <span>Show</span><span style="color:red;">)</span>

<span>tc</span> <span style="color:red;">::</span> <span>Scanner</span> <span>TC</span>
<span>tc</span> <span style="color:red;">=</span> <span style="color:blue;font-weight:bold;">do</span>
  <span>m</span> <span style="color:red;">&lt;-</span> <span>int</span>
  <span>n</span> <span style="color:red;">&lt;-</span> <span>int</span>
  <span>TC</span> <span>m</span> <span>&lt;$&gt;</span> <span>int</span> <span>&lt;*&gt;</span> <span>n</span> <span>&gt;&lt;</span> <span style="color:red;">(</span><span>Move</span> <span>&lt;$&gt;</span> <span>int</span> <span>&lt;*&gt;</span> <span>int</span><span style="color:red;">)</span>

<span>format</span> <span style="color:red;">::</span> <span>Maybe</span> <span>Int</span> <span style="color:red;">-&gt;</span> <span>ByteString</span>
<span>format</span> <span style="color:red;">=</span> <span>maybe</span> <span style="color:teal;">"-1"</span> <span>showB</span>

<span>solve</span> <span style="color:red;">::</span> <span>TC</span> <span style="color:red;">-&gt;</span> <span>Maybe</span> <span>Int</span>
<span>solve</span> <span>TC</span><span style="color:red;">{</span><span style="color:red;">..</span><span style="color:red;">}</span> <span style="color:red;">=</span> <span>level</span> <span>res</span> <span class="hs-num">0</span>
  <span style="color:blue;font-weight:bold;">where</span>
    <span>res</span> <span style="color:red;">=</span> <span>bfs</span> <span style="color:red;">[</span><span>s0</span><span style="color:red;">]</span> <span style="color:red;">(</span><span style="color:red;">\</span><span>v</span> <span style="color:red;">-&gt;</span> <span>map</span> <span style="color:red;">(</span><span>step</span> <span>v</span><span style="color:red;">)</span> <span>moves</span><span style="color:red;">)</span> <span style="color:red;">(</span><span>==</span><span class="hs-num">0</span><span style="color:red;">)</span>
    <span>step</span> <span>v</span> <span style="color:red;">(</span><span>Move</span> <span>a</span> <span>b</span><span style="color:red;">)</span> <span style="color:red;">=</span> <span style="color:red;">(</span><span>a</span><span>*</span><span>v</span> <span>+</span> <span>b</span><span style="color:red;">)</span> <span>`mod`</span> <span>m</span></code></pre>
<p>We run a BFS from $s_0$, stopping when we reach $0$, and then look up the <code>level</code> of 0 to see the minimum number of steps needed to reach it.</p>
<p>In part 2, I’ll talk about how to implement this API. There are many viable implementation strategies, but the trick is getting it to run fast enough.</p>

