---
title: 'Themes on Streams, Part II'
published: 2011-05-20T20:18:27Z
categories: haskell,math
tags: comonad,free theorem,functor,parametricity,representable
---

<p>In a <a href="http://byorgey.wordpress.com/2011/05/09/themes-on-streams/">previous post</a> I claimed that <em>comonad structures on <code>R -&gt; a</code> are in one-to-one correspondence with monoid structures on <code>R</code></em>. In this post and the next I'll justify that claim.</p><div id="characterizing-comonads-on-R -&gt; a"><h2>Characterizing comonads on <code>R -&gt; a</code></h2><p>Suppose we have a comonad structure on <code>R -&gt; a</code>. What could it possibly look like? Well, we must have two functions</p><pre><code><span>extract</span>   <span style="color:red;">::</span> <span style="color:red;">(</span><span>R</span> <span style="color:red;">-&gt;</span> <span>a</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span>a</span>
<span>duplicate</span> <span style="color:red;">::</span> <span style="color:red;">(</span><span>R</span> <span style="color:red;">-&gt;</span> <span>a</span><span style="color:red;">)</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>R</span> <span style="color:red;">-&gt;</span> <span style="color:red;">(</span><span>R</span> <span style="color:red;">-&gt;</span> <span>a</span><span style="color:red;">)</span><span style="color:red;">)</span></code></pre><p>(these are the duals of <code>return</code> and <code>join</code> for monads). Furthermore, <code>extract</code> and <code>duplicate</code> must satisfy some laws; we'll get to those in a minute. For now, let's just think a bit about these functions and their implementations. How would you implement them? They seem awfully constrained. For example, look at the type of <code>extract</code>: it takes a function of type <code>R -&gt; a</code> and must somehow return an <code>a</code>. Intuitively, the only way it could do this is by applying the function to some distinguished value of type <code>R</code>. Similarly, <code>duplicate</code> takes a function <code>R -&gt; a</code> as input and must produce a function of type <code>R -&gt; R -&gt; a</code>. How could this output function behave? It takes two <code>R</code> values and then must produce an <code>a</code>. The only place to get an <code>a</code> is from the argument to <code>duplicate</code>, which must be passed an <code>R</code>; the only possibility is to somehow combine its two <code>R</code> values into one.</p><p>Hmm... a distinguished value of type <code>R</code>... combining two <code>R</code> values into one... this should sound familiar! But how do we formalize all of this?</p><p>Any time we talk about the way a function's <em>type</em> constrains its <em>behavior</em> we should immediately think of <em>parametricity</em> (aka <a href="http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps"><em>free theorems</em></a>). Using the very nice <a href="http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi">free theorem generator</a> (using <code>T0</code> in place of <code>R</code>) we can automatically generate some theorems about <code>extract</code> and <code>duplicate</code> based on their types. I've taken the liberty of specializing and alpha-varying them a bit. First, here's the free theorem for <code>extract</code>:</p><p>$\forall g :: a \to b, \forall p :: R \to a, \forall q :: R \to b, \\ \quad (g \circ p = q) \implies (g\ (\mathit{extract}\ p) = \mathit{extract}\ q)$</p><p>Now watch what happens when we set <code>q = g</code> and <code>p = id</code> (so <code>a = R</code>). The left-hand side of the implication becomes <code>g . id = g</code> which is trivially satisfied. Hence the right-hand side must hold:</p><p>$g\ (\mathit{extract}\ id) = \mathit{extract}\ g$</p><p>What does this give us? Well, flipping it around, it tells us that applying <code>extract</code> to an arbitrary function <code>g</code> is equivalent to applying <code>g</code> to some value of type <code>R</code> (in particular, the value we get when applying <code>extract</code> to the identity function). In other words, up to behavioral equivalence, the only possible implementation of <code>extract g</code> is the one which applies <code>g</code> to some distinguished <code>R</code> value -- which is exactly what our intuition told us before! <code>extract</code> is completely determined by the chosen value of <code>R</code>; let's call it <code>r</code>.</p><p>Similarly, here's the free theorem for <code>duplicate</code>:</p><p>$\forall g :: a \to b, \forall p :: R \to a, \forall q :: R \to b, (g \circ p = q) \implies \\ \quad (\forall y,z :: R, g\ (\mathit{duplicate}\ p\ y\ z) = \mathit{duplicate}\ q\ y\ z)$</p><p>Again setting <code>q = g</code> and <code>p = id</code> gives us</p><p>$g\ (\mathit{duplicate}\ \mathit{id}\ y\ z) = \mathit{duplicate}\ g\ y\ z$</p><p>Writing $\oplus$ for $\mathit{duplicate}\ \mathit{id}$ gives us</p><p>$\mathit{duplicate}\ g\ y\ z = g\ (y \oplus z)$</p><p>that is, the only possible implementation of <code>duplicate g y z</code> is to pass some combination of <code>y</code> and <code>z</code> as an argument to <code>g</code>.</p><p>So now we know that for some value $r :: R$ and some binary function $\oplus :: R \to R \to R$,</p><p>$\mathit{extract}\ g = g\ r \\ \mathit{duplicate}\ g\ y\ z = g\ (y \oplus z)$</p><p>But in order to form a valid comonad instance, these functions must satisfy a few laws. In another post, I'll show what these laws tell us about $r$ and $\oplus$ (you can probably already guess, and might want to try working out the proof yourself... =)</p></div>

